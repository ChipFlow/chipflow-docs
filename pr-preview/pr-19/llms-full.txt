# index.html.md

![image](chipflow-lib/_assets/chipflow-logo.svg)

# ChipFlow IC Design Platform

ChipFlow is an open-source platform for designing, testing, and manufacturing custom silicon.
It provides a streamlined workflow from design to fabrication using Python and the Amaranth HDL.

# Contents

# Getting Started

* [Chip Configurator](configurator/index.md)
  * [Getting Started](configurator/index.md#getting-started)
  * [Working in Your Codespace](configurator/index.md#working-in-your-codespace)
  * [Key Features](configurator/index.md#key-features)
  * [Resources](configurator/index.md#resources)
* [Getting Started with ChipFlow](chipflow-lib/getting-started.md)
  * [What is ChipFlow?](chipflow-lib/getting-started.md#what-is-chipflow)
  * [Prerequisites](chipflow-lib/getting-started.md#prerequisites)
  * [Clone chipflow-examples](chipflow-lib/getting-started.md#clone-chipflow-examples)
  * [Install the dependencies](chipflow-lib/getting-started.md#install-the-dependencies)
  * [Set up authentication](chipflow-lib/getting-started.md#set-up-authentication)
  * [Running a chip build](chipflow-lib/getting-started.md#running-a-chip-build)
* [Introduction to the ChipFlow platform](tutorial-intro-chipflow-platform.md)
  * [Preparing your local environment](tutorial-intro-chipflow-platform.md#preparing-your-local-environment)
  * [Getting started](tutorial-intro-chipflow-platform.md#getting-started)
  * [The example project](tutorial-intro-chipflow-platform.md#the-example-project)
  * [The design](tutorial-intro-chipflow-platform.md#the-design)
  * [Run the design in simulation](tutorial-intro-chipflow-platform.md#run-the-design-in-simulation)
  * [Run the design on a ULX3S board (optional)](tutorial-intro-chipflow-platform.md#run-the-design-on-a-ulx3s-board-optional)
  * [Add a peripheral to the design](tutorial-intro-chipflow-platform.md#add-a-peripheral-to-the-design)
  * [See our new peripheral in action](tutorial-intro-chipflow-platform.md#see-our-new-peripheral-in-action)
  * [Building for Silicon](tutorial-intro-chipflow-platform.md#building-for-silicon)
  * [What’s on the roadmap?](tutorial-intro-chipflow-platform.md#what-s-on-the-roadmap)
  * [Join the Alpha Program](tutorial-intro-chipflow-platform.md#join-the-alpha-program)
  * [Troubleshooting](tutorial-intro-chipflow-platform.md#troubleshooting)

# Examples

* [ChipFlow Examples](examples/index.md)
  * [Available Examples](examples/index.md#available-examples)
  * [Getting Started](examples/index.md#getting-started)

# Reference

* [ChipFlow Library Documentation](chipflow-lib/index.md)
  * [Getting Started with ChipFlow](chipflow-lib/getting-started.md)
  * [ChipFlow Architecture Overview](chipflow-lib/architecture.md)
  * [Simulation Guide](chipflow-lib/simulation-guide.md)
  * [Intro to `chipflow.toml`](chipflow-lib/chipflow-toml-guide.md)
  * [project_name](chipflow-lib/chipflow-toml-guide.md#project-name)
  * [clock_domains](chipflow-lib/chipflow-toml-guide.md#clock-domains)
  * [process](chipflow-lib/chipflow-toml-guide.md#process)
  * [package](chipflow-lib/chipflow-toml-guide.md#package)
  * [The `chipflow` command](chipflow-lib/chipflow-commands.md)
  * [Using Pin Signatures and Software Drivers](chipflow-lib/using-pin-signatures.md)
  * [Platform API Reference](platform-api.md)
  * [Pin Signature Architecture (Contributor Guide)](chipflow-lib/contributor-pin-signature-internals.md)
* [Digital IP Library](chipflow-digital-ip/index.md)
  * [Base Peripherals](chipflow-digital-ip/base.md)
  * [I/O Peripherals](chipflow-digital-ip/io.md)
  * [Memory Peripherals](chipflow-digital-ip/memory.md)
  * [Processors](chipflow-digital-ip/processors.md)
* [Indices and tables](chipflow-digital-ip/index.md#indices-and-tables)
* [Amaranth Language and Toolchain](amaranth/index.md)
  * [Introduction](amaranth/intro.md)
  * [Installation](amaranth/install.md)
  * [Getting started](amaranth/start.md)
  * [Tutorial](amaranth/tutorial.md)
  * [Language guide](amaranth/guide.md)
  * [Language reference](amaranth/reference.md)
  * [Standard library](amaranth/stdlib.md)
  * [Simulator](amaranth/simulator.md)
  * [Platform integration](amaranth/platform.md)
  * [Changelog](amaranth/changes.md)
  * [Contributing](amaranth/contrib.md)
* [Amaranth System-on-a-Chip toolkit](amaranth-soc/index.md)
  * [Memory maps](amaranth-soc/memory.md)
  * [Wishbone](amaranth-soc/wishbone.md)
  * [CSR](amaranth-soc/csr.md)
  * [GPIO](amaranth-soc/gpio.md)
* [Support](support.md)


# index.html.md

# Digital IP Library

A curated collection of parameterised and configurable RTL cores implemented or wrapped with
[Amaranth](https://github.com/amaranth-lang/amaranth) along with metadata for use with the
[ChipFlow platform](https://docs.chipflow.io).

# Contents:

* [Base Peripherals](base.md)
* [I/O Peripherals](io.md)
* [Memory Peripherals](memory.md)
* [Processors](processors.md)

# Indices and tables

* [Index](../genindex.md)
* [Module Index](../py-modindex.md)
* [Search Page](../search.md)


# index.html.md

# ChipFlow Examples

The [chipflow-examples](https://github.com/ChipFlow/chipflow-examples) repository contains example designs demonstrating how to build chips using the ChipFlow platform.

These examples show you how to:

- Structure a ChipFlow project
- Configure your design with `chipflow.toml`
- Run simulations to test your design
- Submit your design to the ChipFlow cloud builder

## Available Examples

**Minimal SoC** ([Minimal SoC Example](minimal.md))
: A minimal System-on-Chip with a RISC-V core. This is the simplest starting point for understanding ChipFlow projects.

**MCU SoC** ([MCU SoC Example](mcu-soc.md))
: A more complete MCU-style SoC with additional peripherals. Demonstrates a more realistic design with GPIO, UART, and other interfaces.

## Getting Started

See [Getting Started with ChipFlow Examples](getting-started.md) for instructions on how to clone the examples repository and run your first chip build.


# index.html.md

# Chip Configurator

The [ChipFlow Configurator](https://configurator.chipflow.io) is a web-based tool for
designing and visualizing custom chip layouts. It provides an intuitive interface
for configuring IP blocks, pin assignments, and bus connections - then generates
a complete development environment for you to build and simulate your design.

![ChipFlow Configurator main view](configurator/_screenshots/01-main-view.png)

## Getting Started

1. **Open the Configurator**

   Visit [configurator.chipflow.io](https://configurator.chipflow.io) in your browser.
2. **Select a Template**

   Use the dropdown selector to choose a chip template. Templates define the chip’s
   pin count, available IP blocks, and layout constraints.
   ![Template selector dropdown](configurator/_screenshots/03-config-selector.png)
3. **Configure Your Design**
   - Enable or disable IP blocks using the sidebar controls
   - View pin assignments on the chip edges
   - See bus connections between components
4. **Navigate the View**
   - **Pan**: Click and drag to move around
   - **Zoom**: Use mouse wheel or pinch gestures to zoom in/out

   ![Zoomed out view showing full chip](configurator/_screenshots/04-zoomed-out.png)
5. **Generate Your Design**

   When you’re happy with your configuration, click the **Generate Design** button.
   This will:
   - Create a GitHub repository with your design
   - Launch a GitHub Codespace with everything pre-configured
   - Open a welcome page with next steps

## Working in Your Codespace

After clicking “Generate Design”, you’ll be taken to a GitHub Codespace with your
chip design ready to build and simulate. The welcome page shows your design summary
and provides the commands you need.

### Build Your Design

Generate Verilog and compile the simulation:

```bash
chipflow sim build
```

### Run Simulation

Execute the simulation and see results:

```bash
chipflow sim run
```

### Submit for Fabrication

When your design is ready, submit it for silicon fabrication:

```bash
chipflow silicon submit
```

### Next Steps in the Codespace

1. **Build your design** - Run `chipflow sim build` to generate Verilog and compile
2. **Run simulation** - Execute `chipflow sim run` to test your design
3. **Explore results** - Check generated Verilog, waveforms, and test output
4. **Iterate and refine** - Modify your design and rebuild as needed
5. **Submit for fabrication** - Run `chipflow silicon submit` when ready

## Key Features

### Interactive Layout

- Drag, zoom, and pan the chip visualization
- Click on IP blocks to see their details
- Real-time updates as you make changes

### Configurable IP Blocks

- Enable or disable individual IP blocks
- Scale and customize IP block parameters
- View pin assignments and signal mappings

### Visual Bus Routing

- Color-coded connections between components
- Toggle bus visibility in the sidebar
- See which blocks share common buses

### One-Click Development Environment

- Generates a complete GitHub repository
- Pre-configured Codespace with all tools installed
- Ready to build, simulate, and submit your design

## Resources

- [ChipFlow Documentation](https://docs.chipflow.io) - Complete guides and API reference
- [Report Issues](https://github.com/ChipFlow/chipflow-central/issues) - Found a problem? Let us know


# index.html.md

# Language & toolchain

#### WARNING
This manual is a work in progress and is seriously incomplete!

* [Introduction](intro.md)
  * [The Amaranth language](intro.md#the-amaranth-language)
  * [The Amaranth standard library](intro.md#the-amaranth-standard-library)
  * [The Amaranth simulator](intro.md#the-amaranth-simulator)
  * [The Amaranth build system](intro.md#the-amaranth-build-system)
* [Installation](install.md)
  * [In-browser playground](install.md#in-browser-playground)
  * [System requirements](install.md#system-requirements)
  * [Installing prerequisites](install.md#installing-prerequisites)
  * [Installing Amaranth](install.md#installing-amaranth)
  * [Installing board definitions](install.md#installing-board-definitions)
* [Getting started](start.md)
  * [A counter](start.md#a-counter)
  * [A blinking LED](start.md#a-blinking-led)
* [Tutorial](tutorial.md)
* [Language guide](guide.md)
  * [The prelude](guide.md#the-prelude)
  * [Shapes](guide.md#shapes)
  * [Values](guide.md#values)
  * [Constants](guide.md#constants)
  * [Shape casting](guide.md#shape-casting)
  * [Value casting](guide.md#value-casting)
  * [Constant casting](guide.md#constant-casting)
  * [Signals](guide.md#signals)
  * [Operators](guide.md#operators)
  * [Arrays](guide.md#arrays)
  * [Data structures](guide.md#data-structures)
  * [Modules](guide.md#modules)
  * [Control domains](guide.md#control-domains)
  * [Control flow](guide.md#control-flow)
  * [Combinational evaluation](guide.md#combinational-evaluation)
  * [Synchronous evaluation](guide.md#synchronous-evaluation)
  * [Assertions](guide.md#assertions)
  * [Debug printing](guide.md#debug-printing)
  * [Clock domains](guide.md#clock-domains)
  * [Elaboration](guide.md#elaboration)
  * [Memories](guide.md#memories)
  * [I/O values](guide.md#i-o-values)
  * [Instances](guide.md#instances)
  * [I/O buffer instances](guide.md#i-o-buffer-instances)
* [Language reference](reference.md)
  * [Backwards compatibility](reference.md#backwards-compatibility)
  * [Importing syntax](reference.md#importing-syntax)
  * [Source locations](reference.md#source-locations)
  * [Shapes](reference.md#shapes)
  * [Values](reference.md#values)
* [Standard library](stdlib.md)
  * [Enumerations](stdlib/enum.md)
  * [Data structures](stdlib/data.md)
  * [Interfaces and connections](stdlib/wiring.md)
  * [Interface metadata](stdlib/meta.md)
  * [Data streams](stdlib/stream.md)
  * [Memory arrays](stdlib/memory.md)
  * [Input/output buffers](stdlib/io.md)
  * [Clock domain crossing](stdlib/cdc.md)
  * [Code conversion](stdlib/coding.md)
  * [First-in first-out queues](stdlib/fifo.md)
  * [Cyclic redundancy checks](stdlib/crc.md)
* [Simulator](simulator.md)
  * [Simulating circuits](simulator.md#simulating-circuits)
  * [Replacing circuits with code](simulator.md#replacing-circuits-with-code)
  * [Reference](simulator.md#reference)
* [Platform integration](platform.md)
  * [Altera](platform/altera.md)
  * [Gowin](platform/gowin.md)
  * [Lattice](platform/lattice.md)
  * [Quicklogic](platform/quicklogic.md)
  * [SiliconBlue](platform/siliconblue.md)
  * [Xilinx](platform/xilinx.md)
* [Changelog](changes.md)
  * [Documentation for past releases](changes.md#documentation-for-past-releases)
  * [Version 0.5.4](changes.md#version-0-5-4)
  * [Version 0.5.3](changes.md#version-0-5-3)
  * [Version 0.5.2](changes.md#version-0-5-2)
  * [Version 0.5.1](changes.md#version-0-5-1)
  * [Version 0.5.0](changes.md#version-0-5-0)
  * [Version 0.4.0](changes.md#version-0-4-0)
  * [Version 0.3](changes.md#version-0-3)
  * [Versions 0.1, 0.2](changes.md#versions-0-1-0-2)
* [Contributing](contrib.md)
  * [Filing problem reports](contrib.md#filing-problem-reports)
  * [Fixing problems](contrib.md#fixing-problems)
  * [Proposing new features](contrib.md#proposing-new-features)
  * [Working with the codebase](contrib.md#working-with-the-codebase)
  * [Documentation style guide](contrib.md#documentation-style-guide)
  * [Contributing your changes](contrib.md#contributing-your-changes)
  * [Weekly meetings](contrib.md#weekly-meetings)


# index.html.md

# ChipFlow Library Documentation

`chipflow` is a Python library and tools for working with the [ChipFlow Platform](https://doc.chipflow.io)

It is developed at [https://github.com/chipFlow/chipflow-lib/](https://github.com/chipFlow/chipflow-lib/) and licensed [BSD 2-Clause](https://github.com/chipFlow/chipflow-lib/?tab=BSD-2-Clause-1-ov-file)

# User Guide

* [Getting Started with ChipFlow](getting-started.md)
  * [What is ChipFlow?](getting-started.md#what-is-chipflow)
  * [Prerequisites](getting-started.md#prerequisites)
  * [Clone chipflow-examples](getting-started.md#clone-chipflow-examples)
  * [Install the dependencies](getting-started.md#install-the-dependencies)
  * [Set up authentication](getting-started.md#set-up-authentication)
  * [Running a chip build](getting-started.md#running-a-chip-build)
* [ChipFlow Architecture Overview](architecture.md)
  * [High-Level Overview](architecture.md#high-level-overview)
  * [Core Components](architecture.md#core-components)
  * [Design Flow in Detail](architecture.md#design-flow-in-detail)
  * [Annotation System Architecture](architecture.md#annotation-system-architecture)
  * [Package System Architecture](architecture.md#package-system-architecture)
  * [Configuration System](architecture.md#configuration-system)
  * [Extending ChipFlow](architecture.md#extending-chipflow)
  * [See Also](architecture.md#see-also)
* [Simulation Guide](simulation-guide.md)
  * [Overview](simulation-guide.md#overview)
  * [Basic Workflow](simulation-guide.md#basic-workflow)
  * [What Happens During Simulation](simulation-guide.md#what-happens-during-simulation)
  * [SimPlatform Internals](simulation-guide.md#simplatform-internals)
  * [Configuration](simulation-guide.md#configuration)
  * [Simulation Commands](simulation-guide.md#simulation-commands)
  * [Debugging with RTL Debugger](simulation-guide.md#debugging-with-rtl-debugger)
  * [Event Logging for Testing](simulation-guide.md#event-logging-for-testing)
  * [Customizing Simulation](simulation-guide.md#customizing-simulation)
  * [Performance Tips](simulation-guide.md#performance-tips)
  * [Common Issues](simulation-guide.md#common-issues)
  * [Example: Complete Simulation Setup](simulation-guide.md#example-complete-simulation-setup)
  * [See Also](simulation-guide.md#see-also)
* [Intro to `chipflow.toml`](chipflow-toml-guide.md)
  * [`[chipflow]` table](chipflow-toml-guide.md#chipflow-table)
* [project_name](chipflow-toml-guide.md#project-name)
* [clock_domains](chipflow-toml-guide.md#clock-domains)
  * [`[chipflow.top]` table](chipflow-toml-guide.md#chipflow-top-table)
  * [`[chipflow.steps]` table](chipflow-toml-guide.md#chipflow-steps-table)
  * [`[chipflow.silicon]`](chipflow-toml-guide.md#chipflow-silicon)
* [process](chipflow-toml-guide.md#process)
* [package](chipflow-toml-guide.md#package)
  * [Power connections](chipflow-toml-guide.md#power-connections)
* [The `chipflow` command](chipflow-commands.md)
  * [`chipflow auth`](chipflow-commands.md#chipflow-auth)
  * [`chipflow pin lock`](chipflow-commands.md#chipflow-pin-lock)
  * [`chipflow silicon`](chipflow-commands.md#chipflow-silicon)
  * [`chipflow sim`](chipflow-commands.md#chipflow-sim)
  * [`chipflow software`](chipflow-commands.md#chipflow-software)
* [Using Pin Signatures and Software Drivers](using-pin-signatures.md)
  * [Overview](using-pin-signatures.md#overview)
  * [Pin Signatures](using-pin-signatures.md#pin-signatures)
  * [Software Driver Signatures](using-pin-signatures.md#software-driver-signatures)
  * [Using Peripherals in Your SoC](using-pin-signatures.md#using-peripherals-in-your-soc)
  * [Attaching Software Binaries](using-pin-signatures.md#attaching-software-binaries)
  * [Complete Example](using-pin-signatures.md#complete-example)
  * [See Also](using-pin-signatures.md#see-also)
* [Platform API Reference](../platform-api.md)
  * [chipflow](autoapi/chipflow/index.md)

# Contributor Guide

* [Pin Signature Architecture (Contributor Guide)](contributor-pin-signature-internals.md)
  * [Overview](contributor-pin-signature-internals.md#overview)
  * [Annotation Infrastructure](contributor-pin-signature-internals.md#annotation-infrastructure)
  * [I/O Signature Base Classes](contributor-pin-signature-internals.md#i-o-signature-base-classes)
  * [Concrete Pin Signatures](contributor-pin-signature-internals.md#concrete-pin-signatures)
  * [Platform Consumption](contributor-pin-signature-internals.md#platform-consumption)
  * [Complete Flow Example](contributor-pin-signature-internals.md#complete-flow-example)
  * [Adding New Pin Signatures](contributor-pin-signature-internals.md#adding-new-pin-signatures)
  * [Adding Custom Platform Backends](contributor-pin-signature-internals.md#adding-custom-platform-backends)
  * [JSON Schema Integration](contributor-pin-signature-internals.md#json-schema-integration)
  * [Key Files](contributor-pin-signature-internals.md#key-files)
  * [See Also](contributor-pin-signature-internals.md#see-also)


# index.html.md

# System on Chip toolkit

#### WARNING
This manual is a work in progress and is seriously incomplete!

* [Memory maps](memory.md)
  * [Introduction](memory.md#introduction)
  * [Resources](memory.md#resources)
  * [Alignment](memory.md#alignment)
  * [Windows](memory.md#windows)
  * [Freezing](memory.md#freezing)
* [Wishbone](wishbone.md)
  * [Wishbone bus](wishbone/bus.md)
* [CSR](csr.md)
  * [CSR bus](csr/bus.md)
  * [CSR registers](csr/reg.md)
  * [CSR fields](csr/action.md)
* [GPIO](gpio.md)
  * [Introduction](gpio.md#introduction)
  * [Pin modes](gpio.md#pin-modes)
  * [Pin interface](gpio.md#pin-interface)
  * [Peripheral](gpio.md#peripheral)


# index.html.md

# chipflow

Chipflow library

This is the main entry point for the ChipFlow library, providing tools for
building ASIC designs using the Amaranth HDL framework.

## Submodules

* [chipflow.auth](auth/index.md)
* [chipflow.auth_command](auth_command/index.md)
* [chipflow.common](common/index.md)
* [chipflow.config](config/index.md)
* [chipflow.packages](packages/index.md)
* [chipflow.packaging](packaging/index.md)
* [chipflow.platform](platform/index.md)
* [chipflow.utils](utils/index.md)

## Exceptions

| [`ChipFlowError`](#chipflow.ChipFlowError)   | Base exception for ChipFlow errors   |
|----------------------------------------------|--------------------------------------|

## Functions

| [`ensure_chipflow_root`](#chipflow.ensure_chipflow_root)()   | Ensure CHIPFLOW_ROOT environment variable is set and return its path.   |
|--------------------------------------------------------------|-------------------------------------------------------------------------|

## Package Contents

### *exception* chipflow.ChipFlowError

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception)

Base exception for ChipFlow errors

### chipflow.ensure_chipflow_root()

Ensure CHIPFLOW_ROOT environment variable is set and return its path.

If CHIPFLOW_ROOT is not set, sets it to the current working directory.
Also ensures the root is in sys.path.

Returns:
: Path to the chipflow root directory

* **Return type:**
  [pathlib.Path](https://docs.python.org/3/library/pathlib.html#pathlib.Path)


# index.html.md

# chipflow.platform

Platform definitions for ChipFlow.

This module provides platform implementations for silicon, simulation,
and software targets, along with their associated build steps.

## Submodules

* [chipflow.platform.base](base/index.md)
* [chipflow.platform.io](io/index.md)

## Classes

| [`SiliconPlatformPort`](#chipflow.platform.SiliconPlatformPort)         | Represents an abstract library I/O port that can be passed to a buffer.                                                                                                                                                                                                                   |
|-------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [`SiliconStep`](#chipflow.platform.SiliconStep)                         | Step to Prepare and submit the design for an ASIC.                                                                                                                                                                                                                                        |
| [`SimStep`](#chipflow.platform.SimStep)                                 | Base class for ChipFlow build steps.                                                                                                                                                                                                                                                      |
| [`SoftwareStep`](#chipflow.platform.SoftwareStep)                       | Base step to build the software.                                                                                                                                                                                                                                                          |
| [`BoardStep`](#chipflow.platform.BoardStep)                             | Build the design for a board.                                                                                                                                                                                                                                                             |
| [`IOSignature`](#chipflow.platform.IOSignature)                         | An [`Amaranth Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) used to decorate wires that would usually be brought out onto a port on the package.                                                                                                       |
| [`IOModel`](#chipflow.platform.IOModel)                                 | Setting for IO Ports (see also base class [`IOModelOptions`](#chipflow.platform.IOModelOptions)).                                                                                                                                                                                         |
| [`IOTripPoint`](#chipflow.platform.IOTripPoint)                         | Models various options for trip points for inputs.                                                                                                                                                                                                                                        |
| [`IOModelOptions`](#chipflow.platform.IOModelOptions)                   | Options for an IO pad/pin.                                                                                                                                                                                                                                                                |
| [`JTAGSignature`](#chipflow.platform.JTAGSignature)                     | Description of an interface object.                                                                                                                                                                                                                                                       |
| [`SPISignature`](#chipflow.platform.SPISignature)                       | Description of an interface object.                                                                                                                                                                                                                                                       |
| [`I2CSignature`](#chipflow.platform.I2CSignature)                       | Description of an interface object.                                                                                                                                                                                                                                                       |
| [`UARTSignature`](#chipflow.platform.UARTSignature)                     | Description of an interface object.                                                                                                                                                                                                                                                       |
| [`GPIOSignature`](#chipflow.platform.GPIOSignature)                     | Description of an interface object.                                                                                                                                                                                                                                                       |
| [`QSPIFlashSignature`](#chipflow.platform.QSPIFlashSignature)           | Description of an interface object.                                                                                                                                                                                                                                                       |
| [`SoftwareDriverSignature`](#chipflow.platform.SoftwareDriverSignature) | Description of an interface object.                                                                                                                                                                                                                                                       |
| [`SoftwareBuild`](#chipflow.platform.SoftwareBuild)                     | This holds the information needed for building software and providing the built outcome                                                                                                                                                                                                   |
| [`Sky130DriveMode`](#chipflow.platform.Sky130DriveMode)                 | Models the potential drive modes of an SkyWater 130 IO cell [sky130_fd_io_\_gpiov2]([https://skywater-pdk.readthedocs.io/en/main/contents/libraries/sky130_fd_io/docs/user_guide.html](https://skywater-pdk.readthedocs.io/en/main/contents/libraries/sky130_fd_io/docs/user_guide.html)) |
| [`StepBase`](#chipflow.platform.StepBase)                               | Base class for ChipFlow build steps.                                                                                                                                                                                                                                                      |

## Functions

| [`OutputIOSignature`](#chipflow.platform.OutputIOSignature)(width, \*\*kwargs)   | This creates an [`Amaranth Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package output signals         |
|----------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [`InputIOSignature`](#chipflow.platform.InputIOSignature)(width, \*\*kwargs)     | This creates an [`Amaranth Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package input signals          |
| [`BidirIOSignature`](#chipflow.platform.BidirIOSignature)(width, \*\*kwargs)     | This creates an [`Amaranth Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package bi-directional signals |
| [`setup_amaranth_tools`](#chipflow.platform.setup_amaranth_tools)()              | Configure environment for Amaranth/WASM tools.                                                                                                                            |
| [`top_components`](#chipflow.platform.top_components)(config)                    | Return the top level components for the design, as configured in `chipflow.toml`.                                                                                         |
| [`get_software_builds`](#chipflow.platform.get_software_builds)(m, component)    | Extract software build information from a component's interfaces.                                                                                                         |

## Package Contents

### *class* chipflow.platform.SiliconPlatformPort(name, port_desc)

Bases: [`amaranth.lib.io.PortLike`](../../../../amaranth/stdlib/io.md#amaranth.lib.io.PortLike), `Generic`[`Pin`]

Represents an abstract library I/O port that can be passed to a buffer.

The port types supported by most platforms are `SingleEndedPort` and
`DifferentialPort`. Platforms may define additional port types where appropriate.

#### NOTE
`amaranth.hdl.IOPort` is not an instance of [`amaranth.lib.io.PortLike`](../../../../amaranth/stdlib/io.md#amaranth.lib.io.PortLike).

* **Parameters:**
  * **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))
  * **port_desc** ([*chipflow.packaging.PortDesc*](../packaging/index.md#chipflow.packaging.PortDesc))

#### *property* direction

Direction of the port.

* **Return type:**
  `Direction`

### *class* chipflow.platform.SiliconStep(config)

Step to Prepare and submit the design for an ASIC.

#### prepare()

Elaborate the design and convert it to RTLIL.

Returns the path to the RTLIL file.

#### submit(rtlil_path, args)

Submit the design to the ChipFlow cloud builder.

Options:
: –dry-run: Don’t actually submit
  –wait: Wait until build has completed. Use ‘-v’ to increase level of verbosity
  –log-file <file>: Log full debug output to file

### *class* chipflow.platform.SimStep(config)

Bases: [`chipflow.platform.base.StepBase`](base/index.md#chipflow.platform.base.StepBase)

Base class for ChipFlow build steps.

#### build_cli_parser(parser)

Build the cli parser for this step

#### run_cli(args)

Called when this step’s is used from chipflow command

#### build(\*args)

Builds the simulation model for the design

#### run(\*args)

Run the simulation. Will ensure that the simulation and the software are both built.

#### check(\*args)

Run the simulation and check events against reference (tests/events_reference.json). Will ensure that the simulation and the software are both built.

### *class* chipflow.platform.SoftwareStep(config)

Bases: [`chipflow.platform.base.StepBase`](base/index.md#chipflow.platform.base.StepBase)

Base step to build the software.

#### build_cli_parser(parser)

Build the cli parser for this step

#### run_cli(args)

Called when this step’s is used from chipflow command

#### build(\*args)

Build the software for your design

### *class* chipflow.platform.BoardStep(config, platform)

Bases: [`chipflow.platform.base.StepBase`](base/index.md#chipflow.platform.base.StepBase)

Build the design for a board.

#### build_cli_parser(parser)

Build the cli parser for this step

#### run_cli(args)

Called when this step’s is used from chipflow command

#### build(\*args)

Build for the given platform

### *class* chipflow.platform.IOSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

An [`Amaranth Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) used to decorate wires that would usually be brought out onto a port on the package.
This class is generally not directly used.  Instead, you would typically utilize the more specific
[`InputIOSignature`](#chipflow.platform.InputIOSignature), [`OutputIOSignature`](#chipflow.platform.OutputIOSignature), or [`BidirIOSignature`](#chipflow.platform.BidirIOSignature) for defining pin interfaces.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*IOModel*](#chipflow.platform.IOModel) *]*)

#### *property* direction *: [amaranth.lib.io.Direction](../../../../amaranth/stdlib/io.md#amaranth.lib.io.Direction)*

The direction of the IO port

* **Return type:**
  [amaranth.lib.io.Direction](../../../../amaranth/stdlib/io.md#amaranth.lib.io.Direction)

#### *property* width *: [int](https://docs.python.org/3/library/functions.html#int)*

The width of the IO port, in wires

* **Return type:**
  [int](https://docs.python.org/3/library/functions.html#int)

#### *property* invert *: [collections.abc.Iterable](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable)[[bool](https://docs.python.org/3/library/functions.html#bool)]*

A tuple as wide as the IO port, with a bool for the polarity inversion for each wire

* **Return type:**
  [collections.abc.Iterable](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable)[[bool](https://docs.python.org/3/library/functions.html#bool)]

#### *property* options *: [IOModelOptions](#chipflow.platform.IOModelOptions)*

Options set on the io port at construction

* **Return type:**
  [IOModelOptions](#chipflow.platform.IOModelOptions)

### *class* chipflow.platform.IOModel

Bases: [`IOModelOptions`](#chipflow.platform.IOModelOptions)

Setting for IO Ports (see also base class [`IOModelOptions`](#chipflow.platform.IOModelOptions)).

Attributes:
: direction: `io.Direction.Input`, `io.Direction.Output` or `io.Direction.Bidir`.
  width: Width of port, default is 1.

### *class* chipflow.platform.IOTripPoint

Bases: [`enum.StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)

Models various options for trip points for inputs.
Depending on process and cell library, these may be statically or dynamically configurable.

You will get an error if the option is not available with the chosen process and cell library

### *class* chipflow.platform.IOModelOptions

Bases: `typing_extensions.TypedDict`

Options for an IO pad/pin.

Attributes:
: invert: Polarity inversion. If the value is a simple `bool`, it specifies
  : inversion for the entire port. If the value is an iterable of `bool`,
    the iterable must have the same length as the width of `io`, and the
    inversion is specified for individual wires.
  <br/>
  individual_oe: Controls whether each output wire is associated with an
  : individual Output Enable bit or if a single OE bit will be used for
    entire port. The default value is False (indicating that a single OE
    bit controls the entire port).
  <br/>
  power_domain: The name of the I/O power domain. NB there is only one of
  : these, so IO with multiple power domains must be split up.
  <br/>
  clock_domain: The name of the I/O’s clock domain (see
  : `amaranth.hdl.ClockDomain`). NB there is only one of these, so IO
    with multiple clocks must be split up.
  <br/>
  buffer_in: Should the IO pad have an input buffer?
  buffer_out: Should the IO pad have an output buffer?
  sky130_drive_mode: Drive mode for output buffer on sky130.
  trip_point: Trip Point configuration for input buffer.
  init: The value for the initial values of the port.
  init_oe: The value for the initial values of the output enable(s) of the port.

### chipflow.platform.OutputIOSignature(width, \*\*kwargs)

This creates an [`Amaranth Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package output signals
intended for connection to the physical pads of the integrated circuit package.

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – specifies the number of individual output wires within this port, each of which will correspond to a separate physical pad on the integrated circuit package.
  * **kwargs** (*typing_extensions.Unpack* *[*[*IOModelOptions*](#chipflow.platform.IOModelOptions) *]*)

### chipflow.platform.InputIOSignature(width, \*\*kwargs)

This creates an [`Amaranth Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package input signals
intended for connection to the physical pads of the integrated circuit package.

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – specifies the number of individual input wires within this port, each of which will correspond to a separate physical pad on the integrated circuit package.
  * **kwargs** (*typing_extensions.Unpack* *[*[*IOModelOptions*](#chipflow.platform.IOModelOptions) *]*)

### chipflow.platform.BidirIOSignature(width, \*\*kwargs)

This creates an [`Amaranth Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package bi-directional signals
intended for connection to the physical pads of the integrated circuit package.

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – specifies the number of individual input/output wires within this port. Each pair of input/output wires will correspond to a separate physical pad on the integrated circuit package.
  * **kwargs** (*typing_extensions.Unpack* *[*[*IOModelOptions*](#chipflow.platform.IOModelOptions) *]*)

### *class* chipflow.platform.JTAGSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](io/iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.SPISignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](io/iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.I2CSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](io/iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.UARTSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](io/iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.GPIOSignature(pin_count=1, \*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](io/iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.QSPIFlashSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](io/iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.SoftwareDriverSignature(members, \*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*DriverModel*](io/signatures/index.md#chipflow.platform.io.signatures.DriverModel) *]*)

### *class* chipflow.platform.SoftwareBuild(\*, sources, includes=[], include_dirs=[], offset=0)

This holds the information needed for building software and providing the built outcome

* **Parameters:**
  * **sources** ([*list*](https://docs.python.org/3/library/stdtypes.html#list) *[*[*pathlib.Path*](https://docs.python.org/3/library/pathlib.html#pathlib.Path) *]*)
  * **includes** ([*list*](https://docs.python.org/3/library/stdtypes.html#list) *[*[*pathlib.Path*](https://docs.python.org/3/library/pathlib.html#pathlib.Path) *]*)

### *class* chipflow.platform.Sky130DriveMode

Bases: [`enum.StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)

Models the potential drive modes of an SkyWater 130 IO cell [sky130_fd_io_\_gpiov2]([https://skywater-pdk.readthedocs.io/en/main/contents/libraries/sky130_fd_io/docs/user_guide.html](https://skywater-pdk.readthedocs.io/en/main/contents/libraries/sky130_fd_io/docs/user_guide.html))
These are both statically configurable and can be set at runtime on the :py:mod:drive_mode.Sky130Port lines on the port.

### *class* chipflow.platform.StepBase(config={})

Bases: [`abc.ABC`](https://docs.python.org/3/library/abc.html#abc.ABC)

Base class for ChipFlow build steps.

#### build_cli_parser(parser)

Build the cli parser for this step

#### run_cli(args)

Called when this step’s is used from chipflow command

#### build(\*args)

builds the design

### chipflow.platform.setup_amaranth_tools()

Configure environment for Amaranth/WASM tools.

### chipflow.platform.top_components(config)

Return the top level components for the design, as configured in `chipflow.toml`.

Args:
: config: The parsed chipflow configuration

Returns:
: Dictionary mapping component names to instantiated Component objects

Raises:
: ChipFlowError: If component references are invalid or instantiation fails

* **Parameters:**
  **config** (*chipflow.config.models.Config*)
* **Return type:**
  Dict[[str](https://docs.python.org/3/library/stdtypes.html#str), [amaranth.lib.wiring.Component](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Component)]

### chipflow.platform.get_software_builds(m, component)

Extract software build information from a component’s interfaces.

Args:
: m: Module containing the component
  component: Name of the component

Returns:
: Dictionary of interface names to SoftwareBuild objects

* **Parameters:**
  **component** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))


# index.html.md

# chipflow.packages

Package definitions for ChipFlow platforms.

This module contains package type definitions for supported IC packages.


# index.html.md

# chipflow.packaging

Package definitions and pin allocation.

This module provides everything needed to define IC packages and
allocate pins to component interfaces, including:

- Pin dataclasses (PowerPins, JTAGPins, BringupPins)
- Port description models (PortDesc, PortMap)
- Lock file models (LockFile, Package)
- Base classes (BasePackageDef, LinearAllocPackageDef)
- Concrete package types (QuadPackageDef, BareDiePackageDef, GAPackageDef, OpenframePackageDef)
- Pin allocation algorithms

## Submodules

* [chipflow.packaging.allocation](allocation/index.md)
* [chipflow.packaging.base](base/index.md)
* [chipflow.packaging.commands](commands/index.md)
* [chipflow.packaging.grid_array](grid_array/index.md)
* [chipflow.packaging.lockfile](lockfile/index.md)
* [chipflow.packaging.openframe](openframe/index.md)
* [chipflow.packaging.pins](pins/index.md)
* [chipflow.packaging.port_desc](port_desc/index.md)
* [chipflow.packaging.standard](standard/index.md)
* [chipflow.packaging.utils](utils/index.md)

## Exceptions

| [`UnableToAllocate`](#chipflow.packaging.UnableToAllocate)   | Raised when pin allocation fails   |
|--------------------------------------------------------------|------------------------------------|

## Classes

| [`PowerType`](#chipflow.packaging.PowerType)                         | Type of power pin (power or ground)                                        |
|----------------------------------------------------------------------|----------------------------------------------------------------------------|
| [`JTAGWire`](#chipflow.packaging.JTAGWire)                           | Wire names in a JTAG interface                                             |
| [`PortType`](#chipflow.packaging.PortType)                           | Type of port                                                               |
| [`PowerPins`](#chipflow.packaging.PowerPins)                         | A matched pair of power pins, with optional notation of the voltage range. |
| [`JTAGPins`](#chipflow.packaging.JTAGPins)                           | Pins for a JTAG interface.                                                 |
| [`BringupPins`](#chipflow.packaging.BringupPins)                     | Essential pins for bringing up an IC, always in fixed locations.           |
| [`PortDesc`](#chipflow.packaging.PortDesc)                           | Description of a port and its pin assignment.                              |
| [`PortMap`](#chipflow.packaging.PortMap)                             | Mapping of components to interfaces to ports.                              |
| [`Package`](#chipflow.packaging.Package)                             | Serializable identifier for a defined packaging option.                    |
| [`LockFile`](#chipflow.packaging.LockFile)                           | Representation of a pin lock file.                                         |
| [`BasePackageDef`](#chipflow.packaging.BasePackageDef)               | Abstract base class for the definition of a package.                       |
| [`LinearAllocPackageDef`](#chipflow.packaging.LinearAllocPackageDef) | Base class for package types with linear pin/pad allocation.               |
| [`BareDiePackageDef`](#chipflow.packaging.BareDiePackageDef)         | Definition of a package with pins on four sides.                           |
| [`QuadPackageDef`](#chipflow.packaging.QuadPackageDef)               | Definition of a quad flat package.                                         |
| [`GAPin`](#chipflow.packaging.GAPin)                                 | Pin identifier for grid array packages (row letter, column number)         |
| [`GALayout`](#chipflow.packaging.GALayout)                           | Layout type for grid array packages                                        |
| [`GAPackageDef`](#chipflow.packaging.GAPackageDef)                   | Definition of a grid array package.                                        |
| [`OFPin`](#chipflow.packaging.OFPin)                                 | Pin identifier for Openframe package                                       |
| [`OpenframePackageDef`](#chipflow.packaging.OpenframePackageDef)     | Definition of the ChipFoundry Openframe harness package.                   |
| [`PinCommand`](#chipflow.packaging.PinCommand)                       | CLI command handler for pin-related operations.                            |

## Functions

| [`load_pinlock`](#chipflow.packaging.load_pinlock)()   | Load the pin lock file from the chipflow root.     |
|--------------------------------------------------------|----------------------------------------------------|
| [`lock_pins`](#chipflow.packaging.lock_pins)([config]) | Create or update the pin lock file for the design. |

## Package Contents

### *class* chipflow.packaging.PowerType

Bases: [`enum.StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)

Type of power pin (power or ground)

### *class* chipflow.packaging.JTAGWire

Bases: [`enum.StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)

Wire names in a JTAG interface

### *class* chipflow.packaging.PortType

Bases: [`enum.StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)

Type of port

### *class* chipflow.packaging.PowerPins

Bases: `Generic`[`Pin`]

A matched pair of power pins, with optional notation of the voltage range.

Attributes:
: power: The power (VDD) pin
  ground: The ground (VSS) pin
  voltage: Optional voltage range or specific voltage
  name: Optional name for this power domain

#### to_set()

Convert power pins to a set

* **Return type:**
  Set[Pin]

### *class* chipflow.packaging.JTAGPins

Bases: `Generic`[`Pin`]

Pins for a JTAG interface.

Attributes:
: trst: Test Reset pin
  tck: Test Clock pin
  tms: Test Mode Select pin
  tdi: Test Data In pin
  tdo: Test Data Out pin

#### to_set()

Convert JTAG pins to a set

* **Return type:**
  Set[Pin]

### *class* chipflow.packaging.BringupPins

Bases: `Generic`[`Pin`]

Essential pins for bringing up an IC, always in fixed locations.

These pins are used for initial testing and debug of the IC.

Attributes:
: core_power: List of core power pin pairs
  core_clock: Core clock input pin
  core_reset: Core reset input pin
  core_heartbeat: Heartbeat output pin (for liveness testing)
  core_jtag: Optional JTAG interface pins

#### to_set()

Convert all bringup pins to a set

* **Return type:**
  Set[Pin]

### *class* chipflow.packaging.PortDesc

Bases: `pydantic.BaseModel`, `Generic`[`chipflow.packaging.pins.Pin`]

Description of a port and its pin assignment.

Attributes:
: type: Type of port (e.g., ‘io’, ‘clock’, ‘reset’, ‘power’, ‘heartbeat’)
  pins: List of pins assigned to this port, or None if not yet allocated
  port_name: Name of the port
  iomodel: IO model configuration for this port

#### *property* width

Width of the port (number of pins)

#### *property* direction

Direction of the port

#### *property* invert *: [collections.abc.Iterable](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable)[[bool](https://docs.python.org/3/library/functions.html#bool)] | [None](https://docs.python.org/3/library/constants.html#None)*

Inversion settings for port wires

* **Return type:**
  [collections.abc.Iterable](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable)[[bool](https://docs.python.org/3/library/functions.html#bool)] | None

### *class* chipflow.packaging.PortMap

Bases: `pydantic.BaseModel`

Mapping of components to interfaces to ports.

This represents the complete pin allocation for an IC package,
organized hierarchically by component and interface.

#### get_ports(component, interface)

Get ports for a specific component and interface.

Args:
: component: Component name
  interface: Interface name

Returns:
: Dictionary of port names to PortDesc, or None if not found

* **Parameters:**
  * **component** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))
  * **interface** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))
* **Return type:**
  [Interface](../../../../amaranth-soc/csr/bus.md#amaranth_soc.csr.bus.Interface) | None

#### get_clocks()

Get all clock ports in the port map

* **Return type:**
  List[[PortDesc](#chipflow.packaging.PortDesc)]

#### get_resets()

Get all reset ports in the port map

* **Return type:**
  List[[PortDesc](#chipflow.packaging.PortDesc)]

### *class* chipflow.packaging.Package

Bases: `pydantic.BaseModel`

Serializable identifier for a defined packaging option.

Attributes:
: package_type: Package type (discriminated union of all PackageDef types)

### *class* chipflow.packaging.LockFile

Bases: `pydantic.BaseModel`

Representation of a pin lock file.

The lock file stores the complete pin allocation for a design,
allowing pins to remain consistent across design iterations.

Attributes:
: process: Semiconductor process being used
  package: Information about the physical package
  port_map: Mapping of components to interfaces to ports
  metadata: Amaranth metadata, for reference

### *class* chipflow.packaging.BasePackageDef

Bases: `pydantic.BaseModel`, `Generic`[`PinType`], [`abc.ABC`](https://docs.python.org/3/library/abc.html#abc.ABC)

Abstract base class for the definition of a package.

Serializing this or any derived classes results in the
description of the package (not serializable directly).

All package definitions must inherit from this class and
implement the required abstract methods.

Attributes:
: name: The name of the package

#### model_post_init(\_\_context)

Initialize internal tracking structures

#### register_component(name, component)

Register a component to be allocated to the pad ring and pins.

Args:
: name: Component name
  component: Amaranth wiring.Component to allocate

* **Parameters:**
  * **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))
  * **component** ([*amaranth.lib.wiring.Component*](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Component))
* **Return type:**
  None

#### allocate_pins(config, process, lockfile)

Allocate package pins to the registered components.

Pins should be allocated in the most usable way for users
of the packaged IC.

This default implementation uses \_linear_allocate_components with
self._allocate for the allocation strategy. Subclasses can override
if they need completely different allocation logic.

Args:
: config: ChipFlow configuration
  process: Semiconductor process
  lockfile: Optional existing lockfile to preserve allocations

Returns:
: LockFile representing the pin allocation

Raises:
: UnableToAllocate: If the ports cannot be allocated

* **Parameters:**
  * **config** ([*chipflow.config.Config*](../config/index.md#chipflow.config.Config))
  * **process** ([*chipflow.config.Process*](../config/index.md#chipflow.config.Process))
  * **lockfile** ([*chipflow.packaging.lockfile.LockFile*](lockfile/index.md#chipflow.packaging.lockfile.LockFile) *|* *None*)
* **Return type:**
  [chipflow.packaging.lockfile.LockFile](lockfile/index.md#chipflow.packaging.lockfile.LockFile)

#### *property* bringup_pins *: [chipflow.packaging.pins.BringupPins](pins/index.md#chipflow.packaging.pins.BringupPins)*

* **Abstractmethod:**
* **Return type:**
  [chipflow.packaging.pins.BringupPins](pins/index.md#chipflow.packaging.pins.BringupPins)

Get the bringup pins for this package.

To aid bringup, these are always in the same place for each
package type. Should include core power, clock and reset.

Power, clocks and resets needed for non-core are allocated
with the port.

Returns:
: BringupPins configuration

### *class* chipflow.packaging.LinearAllocPackageDef

Bases: [`BasePackageDef`](#chipflow.packaging.BasePackageDef)[[`int`](https://docs.python.org/3/library/functions.html#int)]

Base class for package types with linear pin/pad allocation.

This is used for packages where pins are allocated from a
simple linear ordering (e.g., numbered pins around a perimeter).

Subclasses should populate self._ordered_pins in model_post_init
before calling super().model_post_init(_\_context).

Not directly serializable - use concrete subclasses.

### *class* chipflow.packaging.BareDiePackageDef

Bases: [`chipflow.packaging.base.LinearAllocPackageDef`](base/index.md#chipflow.packaging.base.LinearAllocPackageDef)

Definition of a package with pins on four sides.

Sides are labeled north, south, east, west with an integer
identifier within each side, indicating pads across or down
from top-left corner.

This is typically used for direct die attach without traditional
packaging.

Attributes:
: width: Number of die pads on top and bottom sides
  height: Number of die pads on left and right sides

#### model_post_init(\_\_context)

Initialize pin ordering

#### *property* bringup_pins *: [chipflow.packaging.pins.BringupPins](pins/index.md#chipflow.packaging.pins.BringupPins)*

Bringup pins for bare die package

* **Return type:**
  [chipflow.packaging.pins.BringupPins](pins/index.md#chipflow.packaging.pins.BringupPins)

### *class* chipflow.packaging.QuadPackageDef

Bases: [`chipflow.packaging.base.LinearAllocPackageDef`](base/index.md#chipflow.packaging.base.LinearAllocPackageDef)

Definition of a quad flat package.

A package with ‘width’ pins on the top and bottom and ‘height’
pins on the left and right. Pins are numbered anti-clockwise
from the top left pin.

This includes many common package types:

- QFN: quad flat no-leads (bottom pad = substrate)
- BQFP: bumpered quad flat package
- BQFPH: bumpered quad flat package with heat spreader
- CQFP: ceramic quad flat package
- EQFP: plastic enhanced quad flat package
- FQFP: fine pitch quad flat package
- LQFP: low profile quad flat package
- MQFP: metric quad flat package
- NQFP: near chip-scale quad flat package
- SQFP: small quad flat package
- TQFP: thin quad flat package
- VQFP: very small quad flat package
- VTQFP: very thin quad flat package
- TDFN: thin dual flat no-lead package
- CERQUAD: low-cost CQFP

Attributes:
: width: The number of pins across on the top and bottom edges
  height: The number of pins high on the left and right edges

#### model_post_init(\_\_context)

Initialize pin ordering

#### *property* bringup_pins *: [chipflow.packaging.pins.BringupPins](pins/index.md#chipflow.packaging.pins.BringupPins)*

Bringup pins for quad package

* **Return type:**
  [chipflow.packaging.pins.BringupPins](pins/index.md#chipflow.packaging.pins.BringupPins)

### *class* chipflow.packaging.GAPin

Bases: `NamedTuple`

Pin identifier for grid array packages (row letter, column number)

### *class* chipflow.packaging.GALayout

Bases: [`enum.StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)

Layout type for grid array packages

### *class* chipflow.packaging.GAPackageDef

Bases: [`chipflow.packaging.base.BasePackageDef`](base/index.md#chipflow.packaging.base.BasePackageDef)[[`GAPin`](#chipflow.packaging.GAPin)]

Definition of a grid array package.

Pins or pads are arranged in a regular array of ‘width’ by ‘height’.
Pins are identified by a 2-tuple of (row, column), counting from
the bottom left when looking at the underside of the package.
Rows are identified by letter (A-Z), columns by number.

The grid may be complete or have missing pins (e.g., center cutout).

This includes many package types:

- CPGA: Ceramic Pin Grid Array
- OPGA: Organic Pin Grid Array
- SPGA: Staggered Pin Grid Array
- CABGA: Chip Array Ball Grid Array
- CBGA/PBGA: Ceramic/Plastic Ball Grid Array
- CTBGA: Thin Chip Array Ball Grid Array
- CVBGA: Very Thin Chip Array Ball Grid Array
- DSBGA: Die-Size Ball Grid Array
- FBGA: Fine Ball Grid Array / Fine Pitch Ball Grid Array
- FCmBGA: Flip Chip Molded Ball Grid Array
- LBGA: Low-Profile Ball Grid Array
- LFBGA: Low-Profile Fine-Pitch Ball Grid Array
- MBGA: Micro Ball Grid Array
- MCM-PBGA: Multi-Chip Module Plastic Ball Grid Array
- nFBGA: New Fine Ball Grid Array
- SuperBGA (SBGA): Super Ball Grid Array
- TABGA: Tape Array BGA
- TBGA: Thin BGA
- TEPBGA: Thermally Enhanced Plastic Ball Grid Array
- TFBGA: Thin and Fine Ball Grid Array
- UFBGA/UBGA: Ultra Fine Ball Grid Array
- VFBGA: Very Fine Pitch Ball Grid Array
- WFBGA: Very Very Thin Profile Fine Pitch Ball Grid Array
- wWLB: Embedded Wafer Level Ball Grid Array

Attributes:
: width: Number of columns
  height: Number of rows
  layout_type: Pin layout configuration
  channel_width: For PERIMETER/CHANNEL/ISLAND layouts
  island_width: For ISLAND layout, size of center island
  missing_pins: Specific pins to exclude (overrides layout)
  additional_pins: Specific pins to add (overrides layout)

#### model_post_init(\_\_context)

Initialize pin ordering

#### *property* bringup_pins *: [chipflow.packaging.pins.BringupPins](pins/index.md#chipflow.packaging.pins.BringupPins)*

Bringup pins for grid array package

* **Return type:**
  [chipflow.packaging.pins.BringupPins](pins/index.md#chipflow.packaging.pins.BringupPins)

#### *property* heartbeat *: Dict[[int](https://docs.python.org/3/library/functions.html#int), [GAPin](#chipflow.packaging.GAPin)]*

Numbered set of heartbeat pins for the package

* **Return type:**
  Dict[[int](https://docs.python.org/3/library/functions.html#int), [GAPin](#chipflow.packaging.GAPin)]

### *class* chipflow.packaging.OFPin

Bases: `NamedTuple`

Pin identifier for Openframe package

### *class* chipflow.packaging.OpenframePackageDef

Bases: [`chipflow.packaging.base.LinearAllocPackageDef`](base/index.md#chipflow.packaging.base.LinearAllocPackageDef)

Definition of the ChipFoundry Openframe harness package.

This is a standardized package/carrier used for open-source
silicon projects, particularly with the ChipFoundry chipIgnite
and OpenMPW programs.

Attributes:
: name: Package name (default “openframe”)

#### model_post_init(\_\_context)

Initialize pin ordering from GPIO list

#### *property* bringup_pins *: [chipflow.packaging.pins.BringupPins](pins/index.md#chipflow.packaging.pins.BringupPins)*

Bringup pins for Openframe package

* **Return type:**
  [chipflow.packaging.pins.BringupPins](pins/index.md#chipflow.packaging.pins.BringupPins)

### *exception* chipflow.packaging.UnableToAllocate

Bases: [`chipflow.ChipFlowError`](../index.md#chipflow.ChipFlowError)

Raised when pin allocation fails

### chipflow.packaging.load_pinlock()

Load the pin lock file from the chipflow root.

Returns:
: LockFile model

Raises:
: ChipFlowError: If lockfile not found or malformed

* **Return type:**
  [chipflow.packaging.lockfile.LockFile](lockfile/index.md#chipflow.packaging.lockfile.LockFile)

### chipflow.packaging.lock_pins(config=None)

Create or update the pin lock file for the design.

This allocates package pins to component interfaces and writes
the allocation to pins.lock. Will attempt to reuse previous
pin positions if pins.lock already exists.

Args:
: config: Optional Config object. If not provided, will be parsed from chipflow.toml

Raises:
: ChipFlowError: If configuration is invalid or pin allocation fails

* **Parameters:**
  **config** (*Optional* *[*[*chipflow.config.Config*](../config/index.md#chipflow.config.Config) *]*)
* **Return type:**
  None

### *class* chipflow.packaging.PinCommand(config)

CLI command handler for pin-related operations.

This class provides the command-line interface for managing
pin allocations and lock files.

#### build_cli_parser(parser)

Build the CLI parser for pin commands.

Args:
: parser: argparse parser to add subcommands to

#### run_cli(args)

Execute the CLI command.

Args:
: args: Parsed command-line arguments

#### lock()

Lock the pin map for the design.

Will attempt to reuse previous pin positions.


# index.html.md

# chipflow.utils

Core utility functions for ChipFlow

This module provides core utilities used throughout the chipflow library.

## Exceptions

| [`ChipFlowError`](#chipflow.utils.ChipFlowError)   | Base exception for ChipFlow errors   |
|----------------------------------------------------|--------------------------------------|

## Functions

| [`get_cls_by_reference`](#chipflow.utils.get_cls_by_reference)(reference, context)   | Dynamically import and return a class by its module:class reference string.       |
|--------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
| [`ensure_chipflow_root`](#chipflow.utils.ensure_chipflow_root)()                     | Ensure CHIPFLOW_ROOT environment variable is set and return its path.             |
| [`get_src_loc`](#chipflow.utils.get_src_loc)([src_loc_at])                           | Get the source location (filename, line number) of the caller.                    |
| [`compute_invert_mask`](#chipflow.utils.compute_invert_mask)(invert_list)            | Compute a bit mask for signal inversion from a list of boolean invert flags.      |
| [`top_components`](#chipflow.utils.top_components)(config)                           | Return the top level components for the design, as configured in `chipflow.toml`. |
| [`get_software_builds`](#chipflow.utils.get_software_builds)(m, component)           | Extract software build information from a component's interfaces.                 |

## Module Contents

### *exception* chipflow.utils.ChipFlowError

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception)

Base exception for ChipFlow errors

### chipflow.utils.get_cls_by_reference(reference, context)

Dynamically import and return a class by its module:class reference string.

Args:
: reference: String in format “module.path:ClassName”
  context: Description of where this reference came from (for error messages)

Returns:
: The class object

Raises:
: ChipFlowError: If module or class cannot be found

* **Parameters:**
  * **reference** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))
  * **context** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))

### chipflow.utils.ensure_chipflow_root()

Ensure CHIPFLOW_ROOT environment variable is set and return its path.

If CHIPFLOW_ROOT is not set, sets it to the current working directory.
Also ensures the root is in sys.path.

Returns:
: Path to the chipflow root directory

* **Return type:**
  [pathlib.Path](https://docs.python.org/3/library/pathlib.html#pathlib.Path)

### chipflow.utils.get_src_loc(src_loc_at=0)

Get the source location (filename, line number) of the caller.

Args:
: src_loc_at: Number of frames to go back (0 = immediate caller)

Returns:
: Tuple of (filename, line_number)

* **Parameters:**
  **src_loc_at** ([*int*](https://docs.python.org/3/library/functions.html#int))

### chipflow.utils.compute_invert_mask(invert_list)

Compute a bit mask for signal inversion from a list of boolean invert flags.

Args:
: invert_list: List of booleans indicating which bits should be inverted

Returns:
: Integer mask where set bits indicate positions to invert

### chipflow.utils.top_components(config)

Return the top level components for the design, as configured in `chipflow.toml`.

Args:
: config: The parsed chipflow configuration

Returns:
: Dictionary mapping component names to instantiated Component objects

Raises:
: ChipFlowError: If component references are invalid or instantiation fails

* **Parameters:**
  **config** (*chipflow.config.models.Config*)
* **Return type:**
  Dict[[str](https://docs.python.org/3/library/stdtypes.html#str), [amaranth.lib.wiring.Component](../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Component)]

### chipflow.utils.get_software_builds(m, component)

Extract software build information from a component’s interfaces.

Args:
: m: Module containing the component
  component: Name of the component

Returns:
: Dictionary of interface names to SoftwareBuild objects

* **Parameters:**
  **component** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))


# index.html.md

# chipflow.config

Configuration management for ChipFlow.

This module provides configuration models and parsing functionality
for chipflow.toml configuration files.

## Submodules

* [chipflow.config.parser](parser/index.md)

## Classes

| [`Process`](#chipflow.config.Process)               | IC manufacturing process                         |
|-----------------------------------------------------|--------------------------------------------------|
| [`VoltageRange`](#chipflow.config.VoltageRange)     | Models a voltage range for a power domain or IO. |
| [`SiliconConfig`](#chipflow.config.SiliconConfig)   | Configuration for silicon in chipflow.toml.      |
| [`ChipFlowConfig`](#chipflow.config.ChipFlowConfig) | Root configuration for chipflow.toml.            |
| [`Config`](#chipflow.config.Config)                 | Root configuration model for chipflow.toml.      |

## Package Contents

### *class* chipflow.config.Process(\*args, \*\*kwds)

Bases: [`enum.Enum`](https://docs.python.org/3/library/enum.html#enum.Enum)

IC manufacturing process

### *class* chipflow.config.VoltageRange

Bases: `chipflow.serialization.SelectiveSerializationModel`

Models a voltage range for a power domain or IO.

Optional fields (min, max, typical) are omitted from serialization when None.

### *class* chipflow.config.SiliconConfig

Bases: `pydantic.BaseModel`

Configuration for silicon in chipflow.toml.

### *class* chipflow.config.ChipFlowConfig

Bases: `pydantic.BaseModel`

Root configuration for chipflow.toml.

### *class* chipflow.config.Config

Bases: `pydantic.BaseModel`

Root configuration model for chipflow.toml.


# index.html.md

# chipflow.common

Common utilities for ChipFlow.


# index.html.md

# chipflow.auth

ChipFlow authentication helper module.

Handles authentication for ChipFlow API with multiple fallback methods:
1. Environment variable CHIPFLOW_API_KEY
2. GitHub CLI token authentication (if gh is available)
3. OAuth 2.0 Device Flow

## Exceptions

| [`AuthenticationError`](#chipflow.auth.AuthenticationError)   | Exception raised when authentication fails.   |
|---------------------------------------------------------------|-----------------------------------------------|

## Functions

| [`get_credentials_file`](#chipflow.auth.get_credentials_file)()                                              | Get path to credentials file.                       |
|--------------------------------------------------------------------------------------------------------------|-----------------------------------------------------|
| [`save_api_key`](#chipflow.auth.save_api_key)(api_key)                                                       | Save API key to credentials file.                   |
| [`load_saved_api_key`](#chipflow.auth.load_saved_api_key)()                                                  | Load API key from credentials file if it exists.    |
| [`is_gh_authenticated`](#chipflow.auth.is_gh_authenticated)()                                                | Check if GitHub CLI is installed and authenticated. |
| [`get_gh_token`](#chipflow.auth.get_gh_token)()                                                              | Get GitHub token from gh CLI.                       |
| [`authenticate_with_github_token`](#chipflow.auth.authenticate_with_github_token)(api_origin[, interactive]) | Authenticate using GitHub CLI token.                |
| [`authenticate_with_device_flow`](#chipflow.auth.authenticate_with_device_flow)(api_origin[, interactive])   | Authenticate using OAuth 2.0 Device Flow.           |
| [`get_api_key`](#chipflow.auth.get_api_key)([api_origin, interactive, force_login])                          | Get API key using the following priority:           |
| [`logout`](#chipflow.auth.logout)()                                                                          | Remove saved credentials.                           |

## Module Contents

### *exception* chipflow.auth.AuthenticationError

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception)

Exception raised when authentication fails.

### chipflow.auth.get_credentials_file()

Get path to credentials file.

### chipflow.auth.save_api_key(api_key)

Save API key to credentials file.

* **Parameters:**
  **api_key** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))

### chipflow.auth.load_saved_api_key()

Load API key from credentials file if it exists.

### chipflow.auth.is_gh_authenticated()

Check if GitHub CLI is installed and authenticated.

### chipflow.auth.get_gh_token()

Get GitHub token from gh CLI.

### chipflow.auth.authenticate_with_github_token(api_origin, interactive=True)

Authenticate using GitHub CLI token.

Args:
: api_origin: ChipFlow API origin URL
  interactive: Whether to show interactive messages

Returns:
: API key on success, None on failure

* **Parameters:**
  * **api_origin** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))
  * **interactive** ([*bool*](https://docs.python.org/3/library/functions.html#bool))

### chipflow.auth.authenticate_with_device_flow(api_origin, interactive=True)

Authenticate using OAuth 2.0 Device Flow.

Args:
: api_origin: ChipFlow API origin URL
  interactive: Whether to show interactive messages

Returns:
: API key on success, raises AuthenticationError on failure

* **Parameters:**
  * **api_origin** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))
  * **interactive** ([*bool*](https://docs.python.org/3/library/functions.html#bool))

### chipflow.auth.get_api_key(api_origin=None, interactive=True, force_login=False)

Get API key using the following priority:
1. CHIPFLOW_API_KEY environment variable
2. Saved credentials file (unless force_login is True)
3. GitHub CLI token authentication
4. Device flow authentication

Args:
: api_origin: ChipFlow API origin URL (defaults to CHIPFLOW_API_ORIGIN env var or production)
  interactive: Whether to show interactive messages and prompts
  force_login: Force re-authentication even if credentials exist

Returns:
: API key string

Raises:
: AuthenticationError: If all authentication methods fail

* **Parameters:**
  * **api_origin** ([*str*](https://docs.python.org/3/library/stdtypes.html#str) *|* *None*)
  * **interactive** ([*bool*](https://docs.python.org/3/library/functions.html#bool))
  * **force_login** ([*bool*](https://docs.python.org/3/library/functions.html#bool))

### chipflow.auth.logout()

Remove saved credentials.


# index.html.md

# chipflow.auth_command

ChipFlow authentication command for CLI.

Provides chipflow login and chipflow logout commands.

## Classes

| [`AuthCommand`](#chipflow.auth_command.AuthCommand)   | Authentication management for ChipFlow.   |
|-------------------------------------------------------|-------------------------------------------|

## Module Contents

### *class* chipflow.auth_command.AuthCommand(config)

Authentication management for ChipFlow.

#### build_cli_parser(parser)

Build CLI argument parser for auth command.

#### run_cli(args)

Execute the auth command based on parsed arguments.


# index.html.md

# chipflow.config.parser

Configuration file parsing and utilities.


# index.html.md

# chipflow.packaging.allocation

Pin allocation algorithms for package definitions.

This module provides algorithms for allocating pins from available
package pads to component interfaces, including intelligent grouping
and contiguous allocation strategies.

## Exceptions

| [`UnableToAllocate`](#chipflow.packaging.allocation.UnableToAllocate)   | Raised when pin allocation fails   |
|-------------------------------------------------------------------------|------------------------------------|

## Module Contents

### *exception* chipflow.packaging.allocation.UnableToAllocate

Bases: [`chipflow.ChipFlowError`](../../index.md#chipflow.ChipFlowError)

Raised when pin allocation fails


# index.html.md

# chipflow.packaging.standard

Standard package definitions for common package types.

This module provides concrete package definitions for:
- Quad packages (QFN, LQFP, TQFP, etc.)
- Bare die packages

## Classes

| [`BareDiePackageDef`](#chipflow.packaging.standard.BareDiePackageDef)   | Definition of a package with pins on four sides.   |
|-------------------------------------------------------------------------|----------------------------------------------------|
| [`QuadPackageDef`](#chipflow.packaging.standard.QuadPackageDef)         | Definition of a quad flat package.                 |

## Module Contents

### *class* chipflow.packaging.standard.BareDiePackageDef

Bases: [`chipflow.packaging.base.LinearAllocPackageDef`](../base/index.md#chipflow.packaging.base.LinearAllocPackageDef)

Definition of a package with pins on four sides.

Sides are labeled north, south, east, west with an integer
identifier within each side, indicating pads across or down
from top-left corner.

This is typically used for direct die attach without traditional
packaging.

Attributes:
: width: Number of die pads on top and bottom sides
  height: Number of die pads on left and right sides

#### model_post_init(\_\_context)

Initialize pin ordering

#### *property* bringup_pins *: [chipflow.packaging.pins.BringupPins](../pins/index.md#chipflow.packaging.pins.BringupPins)*

Bringup pins for bare die package

* **Return type:**
  [chipflow.packaging.pins.BringupPins](../pins/index.md#chipflow.packaging.pins.BringupPins)

### *class* chipflow.packaging.standard.QuadPackageDef

Bases: [`chipflow.packaging.base.LinearAllocPackageDef`](../base/index.md#chipflow.packaging.base.LinearAllocPackageDef)

Definition of a quad flat package.

A package with ‘width’ pins on the top and bottom and ‘height’
pins on the left and right. Pins are numbered anti-clockwise
from the top left pin.

This includes many common package types:

- QFN: quad flat no-leads (bottom pad = substrate)
- BQFP: bumpered quad flat package
- BQFPH: bumpered quad flat package with heat spreader
- CQFP: ceramic quad flat package
- EQFP: plastic enhanced quad flat package
- FQFP: fine pitch quad flat package
- LQFP: low profile quad flat package
- MQFP: metric quad flat package
- NQFP: near chip-scale quad flat package
- SQFP: small quad flat package
- TQFP: thin quad flat package
- VQFP: very small quad flat package
- VTQFP: very thin quad flat package
- TDFN: thin dual flat no-lead package
- CERQUAD: low-cost CQFP

Attributes:
: width: The number of pins across on the top and bottom edges
  height: The number of pins high on the left and right edges

#### model_post_init(\_\_context)

Initialize pin ordering

#### *property* bringup_pins *: [chipflow.packaging.pins.BringupPins](../pins/index.md#chipflow.packaging.pins.BringupPins)*

Bringup pins for quad package

* **Return type:**
  [chipflow.packaging.pins.BringupPins](../pins/index.md#chipflow.packaging.pins.BringupPins)


# index.html.md

# chipflow.packaging.port_desc

Port description models for pin allocation.

This module provides models for describing port-to-pin mappings
and managing the overall port map for an IC package.

## Classes

| [`PortDesc`](#chipflow.packaging.port_desc.PortDesc)   | Description of a port and its pin assignment.   |
|--------------------------------------------------------|-------------------------------------------------|
| [`PortMap`](#chipflow.packaging.port_desc.PortMap)     | Mapping of components to interfaces to ports.   |

## Module Contents

### *class* chipflow.packaging.port_desc.PortDesc

Bases: `pydantic.BaseModel`, `Generic`[`chipflow.packaging.pins.Pin`]

Description of a port and its pin assignment.

Attributes:
: type: Type of port (e.g., ‘io’, ‘clock’, ‘reset’, ‘power’, ‘heartbeat’)
  pins: List of pins assigned to this port, or None if not yet allocated
  port_name: Name of the port
  iomodel: IO model configuration for this port

#### *property* width

Width of the port (number of pins)

#### *property* direction

Direction of the port

#### *property* invert *: [collections.abc.Iterable](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable)[[bool](https://docs.python.org/3/library/functions.html#bool)] | [None](https://docs.python.org/3/library/constants.html#None)*

Inversion settings for port wires

* **Return type:**
  [collections.abc.Iterable](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable)[[bool](https://docs.python.org/3/library/functions.html#bool)] | None

### *class* chipflow.packaging.port_desc.PortMap

Bases: `pydantic.BaseModel`

Mapping of components to interfaces to ports.

This represents the complete pin allocation for an IC package,
organized hierarchically by component and interface.

#### get_ports(component, interface)

Get ports for a specific component and interface.

Args:
: component: Component name
  interface: Interface name

Returns:
: Dictionary of port names to PortDesc, or None if not found

* **Parameters:**
  * **component** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))
  * **interface** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))
* **Return type:**
  [Interface](../../../../../amaranth-soc/csr/bus.md#amaranth_soc.csr.bus.Interface) | None

#### get_clocks()

Get all clock ports in the port map

* **Return type:**
  List[[PortDesc](#chipflow.packaging.port_desc.PortDesc)]

#### get_resets()

Get all reset ports in the port map

* **Return type:**
  List[[PortDesc](#chipflow.packaging.port_desc.PortDesc)]


# index.html.md

# chipflow.packaging.utils

Utility functions for package and pin lock management.

## Functions

| [`load_pinlock`](#chipflow.packaging.utils.load_pinlock)()   | Load the pin lock file from the chipflow root.     |
|--------------------------------------------------------------|----------------------------------------------------|
| [`lock_pins`](#chipflow.packaging.utils.lock_pins)([config]) | Create or update the pin lock file for the design. |

## Module Contents

### chipflow.packaging.utils.load_pinlock()

Load the pin lock file from the chipflow root.

Returns:
: LockFile model

Raises:
: ChipFlowError: If lockfile not found or malformed

* **Return type:**
  [chipflow.packaging.lockfile.LockFile](../lockfile/index.md#chipflow.packaging.lockfile.LockFile)

### chipflow.packaging.utils.lock_pins(config=None)

Create or update the pin lock file for the design.

This allocates package pins to component interfaces and writes
the allocation to pins.lock. Will attempt to reuse previous
pin positions if pins.lock already exists.

Args:
: config: Optional Config object. If not provided, will be parsed from chipflow.toml

Raises:
: ChipFlowError: If configuration is invalid or pin allocation fails

* **Parameters:**
  **config** (*Optional* *[*[*chipflow.config.Config*](../../config/index.md#chipflow.config.Config) *]*)
* **Return type:**
  None


# index.html.md

# chipflow.packaging.commands

CLI commands for pin lock management.

## Classes

| [`PinCommand`](#chipflow.packaging.commands.PinCommand)   | CLI command handler for pin-related operations.   |
|-----------------------------------------------------------|---------------------------------------------------|

## Module Contents

### *class* chipflow.packaging.commands.PinCommand(config)

CLI command handler for pin-related operations.

This class provides the command-line interface for managing
pin allocations and lock files.

#### build_cli_parser(parser)

Build the CLI parser for pin commands.

Args:
: parser: argparse parser to add subcommands to

#### run_cli(args)

Execute the CLI command.

Args:
: args: Parsed command-line arguments

#### lock()

Lock the pin map for the design.

Will attempt to reuse previous pin positions.


# index.html.md

# chipflow.packaging.openframe

Openframe package definition.

This module provides the package definition for the ChipFoundry Openframe
harness, commonly used with open-source silicon projects.

## Classes

| [`OFPin`](#chipflow.packaging.openframe.OFPin)                             | Pin identifier for Openframe package                     |
|----------------------------------------------------------------------------|----------------------------------------------------------|
| [`OpenframePackageDef`](#chipflow.packaging.openframe.OpenframePackageDef) | Definition of the ChipFoundry Openframe harness package. |

## Module Contents

### *class* chipflow.packaging.openframe.OFPin

Bases: `NamedTuple`

Pin identifier for Openframe package

### *class* chipflow.packaging.openframe.OpenframePackageDef

Bases: [`chipflow.packaging.base.LinearAllocPackageDef`](../base/index.md#chipflow.packaging.base.LinearAllocPackageDef)

Definition of the ChipFoundry Openframe harness package.

This is a standardized package/carrier used for open-source
silicon projects, particularly with the ChipFoundry chipIgnite
and OpenMPW programs.

Attributes:
: name: Package name (default “openframe”)

#### model_post_init(\_\_context)

Initialize pin ordering from GPIO list

#### *property* bringup_pins *: [chipflow.packaging.pins.BringupPins](../pins/index.md#chipflow.packaging.pins.BringupPins)*

Bringup pins for Openframe package

* **Return type:**
  [chipflow.packaging.pins.BringupPins](../pins/index.md#chipflow.packaging.pins.BringupPins)


# index.html.md

# chipflow.packaging.pins

Pin dataclasses and types for package definitions.

This module contains the fundamental building blocks for defining
physical pin assignments and power/signal groupings in IC packages.

## Classes

| [`PowerType`](#chipflow.packaging.pins.PowerType)     | Type of power pin (power or ground)                                        |
|-------------------------------------------------------|----------------------------------------------------------------------------|
| [`JTAGWire`](#chipflow.packaging.pins.JTAGWire)       | Wire names in a JTAG interface                                             |
| [`PortType`](#chipflow.packaging.pins.PortType)       | Type of port                                                               |
| [`PowerPins`](#chipflow.packaging.pins.PowerPins)     | A matched pair of power pins, with optional notation of the voltage range. |
| [`JTAGPins`](#chipflow.packaging.pins.JTAGPins)       | Pins for a JTAG interface.                                                 |
| [`BringupPins`](#chipflow.packaging.pins.BringupPins) | Essential pins for bringing up an IC, always in fixed locations.           |

## Module Contents

### *class* chipflow.packaging.pins.PowerType

Bases: [`enum.StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)

Type of power pin (power or ground)

### *class* chipflow.packaging.pins.JTAGWire

Bases: [`enum.StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)

Wire names in a JTAG interface

### *class* chipflow.packaging.pins.PortType

Bases: [`enum.StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)

Type of port

### *class* chipflow.packaging.pins.PowerPins

Bases: `Generic`[`Pin`]

A matched pair of power pins, with optional notation of the voltage range.

Attributes:
: power: The power (VDD) pin
  ground: The ground (VSS) pin
  voltage: Optional voltage range or specific voltage
  name: Optional name for this power domain

#### to_set()

Convert power pins to a set

* **Return type:**
  Set[Pin]

### *class* chipflow.packaging.pins.JTAGPins

Bases: `Generic`[`Pin`]

Pins for a JTAG interface.

Attributes:
: trst: Test Reset pin
  tck: Test Clock pin
  tms: Test Mode Select pin
  tdi: Test Data In pin
  tdo: Test Data Out pin

#### to_set()

Convert JTAG pins to a set

* **Return type:**
  Set[Pin]

### *class* chipflow.packaging.pins.BringupPins

Bases: `Generic`[`Pin`]

Essential pins for bringing up an IC, always in fixed locations.

These pins are used for initial testing and debug of the IC.

Attributes:
: core_power: List of core power pin pairs
  core_clock: Core clock input pin
  core_reset: Core reset input pin
  core_heartbeat: Heartbeat output pin (for liveness testing)
  core_jtag: Optional JTAG interface pins

#### to_set()

Convert all bringup pins to a set

* **Return type:**
  Set[Pin]


# index.html.md

# chipflow.packaging.grid_array

Grid array package definitions.

This module provides package definitions for grid array packages
like BGA (Ball Grid Array) and PGA (Pin Grid Array) types.

## Classes

| [`GAPin`](#chipflow.packaging.grid_array.GAPin)               | Pin identifier for grid array packages (row letter, column number)   |
|---------------------------------------------------------------|----------------------------------------------------------------------|
| [`GALayout`](#chipflow.packaging.grid_array.GALayout)         | Layout type for grid array packages                                  |
| [`GAPackageDef`](#chipflow.packaging.grid_array.GAPackageDef) | Definition of a grid array package.                                  |

## Module Contents

### *class* chipflow.packaging.grid_array.GAPin

Bases: `NamedTuple`

Pin identifier for grid array packages (row letter, column number)

### *class* chipflow.packaging.grid_array.GALayout

Bases: [`enum.StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)

Layout type for grid array packages

### *class* chipflow.packaging.grid_array.GAPackageDef

Bases: [`chipflow.packaging.base.BasePackageDef`](../base/index.md#chipflow.packaging.base.BasePackageDef)[[`GAPin`](#chipflow.packaging.grid_array.GAPin)]

Definition of a grid array package.

Pins or pads are arranged in a regular array of ‘width’ by ‘height’.
Pins are identified by a 2-tuple of (row, column), counting from
the bottom left when looking at the underside of the package.
Rows are identified by letter (A-Z), columns by number.

The grid may be complete or have missing pins (e.g., center cutout).

This includes many package types:

- CPGA: Ceramic Pin Grid Array
- OPGA: Organic Pin Grid Array
- SPGA: Staggered Pin Grid Array
- CABGA: Chip Array Ball Grid Array
- CBGA/PBGA: Ceramic/Plastic Ball Grid Array
- CTBGA: Thin Chip Array Ball Grid Array
- CVBGA: Very Thin Chip Array Ball Grid Array
- DSBGA: Die-Size Ball Grid Array
- FBGA: Fine Ball Grid Array / Fine Pitch Ball Grid Array
- FCmBGA: Flip Chip Molded Ball Grid Array
- LBGA: Low-Profile Ball Grid Array
- LFBGA: Low-Profile Fine-Pitch Ball Grid Array
- MBGA: Micro Ball Grid Array
- MCM-PBGA: Multi-Chip Module Plastic Ball Grid Array
- nFBGA: New Fine Ball Grid Array
- SuperBGA (SBGA): Super Ball Grid Array
- TABGA: Tape Array BGA
- TBGA: Thin BGA
- TEPBGA: Thermally Enhanced Plastic Ball Grid Array
- TFBGA: Thin and Fine Ball Grid Array
- UFBGA/UBGA: Ultra Fine Ball Grid Array
- VFBGA: Very Fine Pitch Ball Grid Array
- WFBGA: Very Very Thin Profile Fine Pitch Ball Grid Array
- wWLB: Embedded Wafer Level Ball Grid Array

Attributes:
: width: Number of columns
  height: Number of rows
  layout_type: Pin layout configuration
  channel_width: For PERIMETER/CHANNEL/ISLAND layouts
  island_width: For ISLAND layout, size of center island
  missing_pins: Specific pins to exclude (overrides layout)
  additional_pins: Specific pins to add (overrides layout)

#### model_post_init(\_\_context)

Initialize pin ordering

#### *property* bringup_pins *: [chipflow.packaging.pins.BringupPins](../pins/index.md#chipflow.packaging.pins.BringupPins)*

Bringup pins for grid array package

* **Return type:**
  [chipflow.packaging.pins.BringupPins](../pins/index.md#chipflow.packaging.pins.BringupPins)

#### *property* heartbeat *: Dict[[int](https://docs.python.org/3/library/functions.html#int), [GAPin](#chipflow.packaging.grid_array.GAPin)]*

Numbered set of heartbeat pins for the package

* **Return type:**
  Dict[[int](https://docs.python.org/3/library/functions.html#int), [GAPin](#chipflow.packaging.grid_array.GAPin)]


# index.html.md

# chipflow.packaging.lockfile

Lock file models for pin assignments.

The lock file captures the complete pin allocation for a design,
allowing pins to be locked and reused across design iterations.

## Classes

| [`Package`](#chipflow.packaging.lockfile.Package)   | Serializable identifier for a defined packaging option.   |
|-----------------------------------------------------|-----------------------------------------------------------|
| [`LockFile`](#chipflow.packaging.lockfile.LockFile) | Representation of a pin lock file.                        |

## Module Contents

### *class* chipflow.packaging.lockfile.Package

Bases: `pydantic.BaseModel`

Serializable identifier for a defined packaging option.

Attributes:
: package_type: Package type (discriminated union of all PackageDef types)

### *class* chipflow.packaging.lockfile.LockFile

Bases: `pydantic.BaseModel`

Representation of a pin lock file.

The lock file stores the complete pin allocation for a design,
allowing pins to remain consistent across design iterations.

Attributes:
: process: Semiconductor process being used
  package: Information about the physical package
  port_map: Mapping of components to interfaces to ports
  metadata: Amaranth metadata, for reference


# index.html.md

# chipflow.packaging.base

Base classes for package definitions.

This module provides the abstract base classes that all package
definitions inherit from, defining the common interface for
pin allocation and package description.

## Classes

| [`BasePackageDef`](#chipflow.packaging.base.BasePackageDef)               | Abstract base class for the definition of a package.         |
|---------------------------------------------------------------------------|--------------------------------------------------------------|
| [`LinearAllocPackageDef`](#chipflow.packaging.base.LinearAllocPackageDef) | Base class for package types with linear pin/pad allocation. |

## Module Contents

### *class* chipflow.packaging.base.BasePackageDef

Bases: `pydantic.BaseModel`, `Generic`[`PinType`], [`abc.ABC`](https://docs.python.org/3/library/abc.html#abc.ABC)

Abstract base class for the definition of a package.

Serializing this or any derived classes results in the
description of the package (not serializable directly).

All package definitions must inherit from this class and
implement the required abstract methods.

Attributes:
: name: The name of the package

#### model_post_init(\_\_context)

Initialize internal tracking structures

#### register_component(name, component)

Register a component to be allocated to the pad ring and pins.

Args:
: name: Component name
  component: Amaranth wiring.Component to allocate

* **Parameters:**
  * **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))
  * **component** ([*amaranth.lib.wiring.Component*](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Component))
* **Return type:**
  None

#### allocate_pins(config, process, lockfile)

Allocate package pins to the registered components.

Pins should be allocated in the most usable way for users
of the packaged IC.

This default implementation uses \_linear_allocate_components with
self._allocate for the allocation strategy. Subclasses can override
if they need completely different allocation logic.

Args:
: config: ChipFlow configuration
  process: Semiconductor process
  lockfile: Optional existing lockfile to preserve allocations

Returns:
: LockFile representing the pin allocation

Raises:
: UnableToAllocate: If the ports cannot be allocated

* **Parameters:**
  * **config** ([*chipflow.config.Config*](../../config/index.md#chipflow.config.Config))
  * **process** ([*chipflow.config.Process*](../../config/index.md#chipflow.config.Process))
  * **lockfile** ([*chipflow.packaging.lockfile.LockFile*](../lockfile/index.md#chipflow.packaging.lockfile.LockFile) *|* *None*)
* **Return type:**
  [chipflow.packaging.lockfile.LockFile](../lockfile/index.md#chipflow.packaging.lockfile.LockFile)

#### *property* bringup_pins *: [chipflow.packaging.pins.BringupPins](../pins/index.md#chipflow.packaging.pins.BringupPins)*

* **Abstractmethod:**
* **Return type:**
  [chipflow.packaging.pins.BringupPins](../pins/index.md#chipflow.packaging.pins.BringupPins)

Get the bringup pins for this package.

To aid bringup, these are always in the same place for each
package type. Should include core power, clock and reset.

Power, clocks and resets needed for non-core are allocated
with the port.

Returns:
: BringupPins configuration

### *class* chipflow.packaging.base.LinearAllocPackageDef

Bases: [`BasePackageDef`](#chipflow.packaging.base.BasePackageDef)[[`int`](https://docs.python.org/3/library/functions.html#int)]

Base class for package types with linear pin/pad allocation.

This is used for packages where pins are allocated from a
simple linear ordering (e.g., numbered pins around a perimeter).

Subclasses should populate self._ordered_pins in model_post_init
before calling super().model_post_init(_\_context).

Not directly serializable - use concrete subclasses.


# index.html.md

# chipflow.platform.io

IO signatures and utilities for ChipFlow platforms.

This module provides IO signature definitions, annotations, and
platform-specific IO utilities.

## Submodules

* [chipflow.platform.io.annotate](annotate/index.md)
* [chipflow.platform.io.iosignature](iosignature/index.md)
* [chipflow.platform.io.signatures](signatures/index.md)
* [chipflow.platform.io.sky130](sky130/index.md)

## Classes

| [`IOTripPoint`](#chipflow.platform.io.IOTripPoint)                         | Models various options for trip points for inputs.                                                                                                                                                                                                                                        |
|----------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [`IOModelOptions`](#chipflow.platform.io.IOModelOptions)                   | Options for an IO pad/pin.                                                                                                                                                                                                                                                                |
| [`IOModel`](#chipflow.platform.io.IOModel)                                 | Setting for IO Ports (see also base class [`IOModelOptions`](#chipflow.platform.io.IOModelOptions)).                                                                                                                                                                                      |
| [`IOSignature`](#chipflow.platform.io.IOSignature)                         | An [`Amaranth Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) used to decorate wires that would usually be brought out onto a port on the package.                                                                                                    |
| [`JTAGSignature`](#chipflow.platform.io.JTAGSignature)                     | Description of an interface object.                                                                                                                                                                                                                                                       |
| [`SPISignature`](#chipflow.platform.io.SPISignature)                       | Description of an interface object.                                                                                                                                                                                                                                                       |
| [`I2CSignature`](#chipflow.platform.io.I2CSignature)                       | Description of an interface object.                                                                                                                                                                                                                                                       |
| [`UARTSignature`](#chipflow.platform.io.UARTSignature)                     | Description of an interface object.                                                                                                                                                                                                                                                       |
| [`GPIOSignature`](#chipflow.platform.io.GPIOSignature)                     | Description of an interface object.                                                                                                                                                                                                                                                       |
| [`QSPIFlashSignature`](#chipflow.platform.io.QSPIFlashSignature)           | Description of an interface object.                                                                                                                                                                                                                                                       |
| [`SoftwareDriverSignature`](#chipflow.platform.io.SoftwareDriverSignature) | Description of an interface object.                                                                                                                                                                                                                                                       |
| [`SoftwareBuild`](#chipflow.platform.io.SoftwareBuild)                     | This holds the information needed for building software and providing the built outcome                                                                                                                                                                                                   |
| [`Sky130DriveMode`](#chipflow.platform.io.Sky130DriveMode)                 | Models the potential drive modes of an SkyWater 130 IO cell [sky130_fd_io_\_gpiov2]([https://skywater-pdk.readthedocs.io/en/main/contents/libraries/sky130_fd_io/docs/user_guide.html](https://skywater-pdk.readthedocs.io/en/main/contents/libraries/sky130_fd_io/docs/user_guide.html)) |

## Functions

| [`InputIOSignature`](#chipflow.platform.io.InputIOSignature)(width, \*\*kwargs)                         | This creates an [`Amaranth Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package input signals          |
|---------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [`OutputIOSignature`](#chipflow.platform.io.OutputIOSignature)(width, \*\*kwargs)                       | This creates an [`Amaranth Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package output signals         |
| [`BidirIOSignature`](#chipflow.platform.io.BidirIOSignature)(width, \*\*kwargs)                         | This creates an [`Amaranth Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package bi-directional signals |
| [`submodule_metadata`](#chipflow.platform.io.submodule_metadata)(fragment, component_name[, recursive]) | Generator that finds `component_name` in `fragment` and yields metadata.                                                                                                     |

## Package Contents

### *class* chipflow.platform.io.IOTripPoint

Bases: [`enum.StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)

Models various options for trip points for inputs.
Depending on process and cell library, these may be statically or dynamically configurable.

You will get an error if the option is not available with the chosen process and cell library

### *class* chipflow.platform.io.IOModelOptions

Bases: `typing_extensions.TypedDict`

Options for an IO pad/pin.

Attributes:
: invert: Polarity inversion. If the value is a simple `bool`, it specifies
  : inversion for the entire port. If the value is an iterable of `bool`,
    the iterable must have the same length as the width of `io`, and the
    inversion is specified for individual wires.
  <br/>
  individual_oe: Controls whether each output wire is associated with an
  : individual Output Enable bit or if a single OE bit will be used for
    entire port. The default value is False (indicating that a single OE
    bit controls the entire port).
  <br/>
  power_domain: The name of the I/O power domain. NB there is only one of
  : these, so IO with multiple power domains must be split up.
  <br/>
  clock_domain: The name of the I/O’s clock domain (see
  : `amaranth.hdl.ClockDomain`). NB there is only one of these, so IO
    with multiple clocks must be split up.
  <br/>
  buffer_in: Should the IO pad have an input buffer?
  buffer_out: Should the IO pad have an output buffer?
  sky130_drive_mode: Drive mode for output buffer on sky130.
  trip_point: Trip Point configuration for input buffer.
  init: The value for the initial values of the port.
  init_oe: The value for the initial values of the output enable(s) of the port.

### *class* chipflow.platform.io.IOModel

Bases: [`IOModelOptions`](#chipflow.platform.io.IOModelOptions)

Setting for IO Ports (see also base class [`IOModelOptions`](#chipflow.platform.io.IOModelOptions)).

Attributes:
: direction: `io.Direction.Input`, `io.Direction.Output` or `io.Direction.Bidir`.
  width: Width of port, default is 1.

### *class* chipflow.platform.io.IOSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

An [`Amaranth Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) used to decorate wires that would usually be brought out onto a port on the package.
This class is generally not directly used.  Instead, you would typically utilize the more specific
[`InputIOSignature`](#chipflow.platform.io.InputIOSignature), [`OutputIOSignature`](#chipflow.platform.io.OutputIOSignature), or [`BidirIOSignature`](#chipflow.platform.io.BidirIOSignature) for defining pin interfaces.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*IOModel*](#chipflow.platform.io.IOModel) *]*)

#### *property* direction *: [amaranth.lib.io.Direction](../../../../../amaranth/stdlib/io.md#amaranth.lib.io.Direction)*

The direction of the IO port

* **Return type:**
  [amaranth.lib.io.Direction](../../../../../amaranth/stdlib/io.md#amaranth.lib.io.Direction)

#### *property* width *: [int](https://docs.python.org/3/library/functions.html#int)*

The width of the IO port, in wires

* **Return type:**
  [int](https://docs.python.org/3/library/functions.html#int)

#### *property* invert *: [collections.abc.Iterable](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable)[[bool](https://docs.python.org/3/library/functions.html#bool)]*

A tuple as wide as the IO port, with a bool for the polarity inversion for each wire

* **Return type:**
  [collections.abc.Iterable](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable)[[bool](https://docs.python.org/3/library/functions.html#bool)]

#### *property* options *: [IOModelOptions](#chipflow.platform.io.IOModelOptions)*

Options set on the io port at construction

* **Return type:**
  [IOModelOptions](#chipflow.platform.io.IOModelOptions)

### chipflow.platform.io.InputIOSignature(width, \*\*kwargs)

This creates an [`Amaranth Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package input signals
intended for connection to the physical pads of the integrated circuit package.

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – specifies the number of individual input wires within this port, each of which will correspond to a separate physical pad on the integrated circuit package.
  * **kwargs** (*typing_extensions.Unpack* *[*[*IOModelOptions*](#chipflow.platform.io.IOModelOptions) *]*)

### chipflow.platform.io.OutputIOSignature(width, \*\*kwargs)

This creates an [`Amaranth Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package output signals
intended for connection to the physical pads of the integrated circuit package.

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – specifies the number of individual output wires within this port, each of which will correspond to a separate physical pad on the integrated circuit package.
  * **kwargs** (*typing_extensions.Unpack* *[*[*IOModelOptions*](#chipflow.platform.io.IOModelOptions) *]*)

### chipflow.platform.io.BidirIOSignature(width, \*\*kwargs)

This creates an [`Amaranth Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package bi-directional signals
intended for connection to the physical pads of the integrated circuit package.

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – specifies the number of individual input/output wires within this port. Each pair of input/output wires will correspond to a separate physical pad on the integrated circuit package.
  * **kwargs** (*typing_extensions.Unpack* *[*[*IOModelOptions*](#chipflow.platform.io.IOModelOptions) *]*)

### *class* chipflow.platform.io.JTAGSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.io.SPISignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.io.I2CSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.io.UARTSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.io.GPIOSignature(pin_count=1, \*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.io.QSPIFlashSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.io.SoftwareDriverSignature(members, \*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*DriverModel*](signatures/index.md#chipflow.platform.io.signatures.DriverModel) *]*)

### *class* chipflow.platform.io.SoftwareBuild(\*, sources, includes=[], include_dirs=[], offset=0)

This holds the information needed for building software and providing the built outcome

* **Parameters:**
  * **sources** ([*list*](https://docs.python.org/3/library/stdtypes.html#list) *[*[*pathlib.Path*](https://docs.python.org/3/library/pathlib.html#pathlib.Path) *]*)
  * **includes** ([*list*](https://docs.python.org/3/library/stdtypes.html#list) *[*[*pathlib.Path*](https://docs.python.org/3/library/pathlib.html#pathlib.Path) *]*)

### *class* chipflow.platform.io.Sky130DriveMode

Bases: [`enum.StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)

Models the potential drive modes of an SkyWater 130 IO cell [sky130_fd_io_\_gpiov2]([https://skywater-pdk.readthedocs.io/en/main/contents/libraries/sky130_fd_io/docs/user_guide.html](https://skywater-pdk.readthedocs.io/en/main/contents/libraries/sky130_fd_io/docs/user_guide.html))
These are both statically configurable and can be set at runtime on the :py:mod:drive_mode.Sky130Port lines on the port.

### chipflow.platform.io.submodule_metadata(fragment, component_name, recursive=False)

Generator that finds `component_name` in `fragment` and yields metadata.

Yields the `wiring.Component` instances of that component’s submodule, along
with their names and metadata.

Can only be run once for a given component (or its children).

Args:
: fragment: The fragment to search in.
  component_name: The name of the component to find.
  recursive: If True, name is a tuple of the hierarchy of names. Otherwise,
  <br/>
  > name is the string name of the first level component.

Yields:
: Tuple of (component, name, metadata) for each submodule.

* **Parameters:**
  * **fragment** (*amaranth.Fragment*)
  * **component_name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))
* **Return type:**
  [collections.abc.Generator](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator)[Tuple[[amaranth.lib.wiring.Component](../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Component), [str](https://docs.python.org/3/library/stdtypes.html#str) | [tuple](https://docs.python.org/3/library/stdtypes.html#tuple), [dict](https://docs.python.org/3/library/stdtypes.html#dict)]]


# index.html.md

# chipflow.platform.base

Base classes and utilities for ChipFlow platform steps.

## Classes

| [`StepBase`](#chipflow.platform.base.StepBase)   | Base class for ChipFlow build steps.   |
|--------------------------------------------------|----------------------------------------|

## Functions

| [`setup_amaranth_tools`](#chipflow.platform.base.setup_amaranth_tools)()   | Configure environment for Amaranth/WASM tools.   |
|----------------------------------------------------------------------------|--------------------------------------------------|

## Module Contents

### chipflow.platform.base.setup_amaranth_tools()

Configure environment for Amaranth/WASM tools.

### *class* chipflow.platform.base.StepBase(config={})

Bases: [`abc.ABC`](https://docs.python.org/3/library/abc.html#abc.ABC)

Base class for ChipFlow build steps.

#### build_cli_parser(parser)

Build the cli parser for this step

#### run_cli(args)

Called when this step’s is used from chipflow command

#### build(\*args)

builds the design


# index.html.md

# chipflow.platform.io.signatures

Common interface signatures for ChipFlow platforms.

## Classes

| [`SimInterface`](#chipflow.platform.io.signatures.SimInterface)                       | Simulation interface metadata for ChipFlow components.                                             |
|---------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------|
| [`DataclassProtocol`](#chipflow.platform.io.signatures.DataclassProtocol)             | Base class for protocol classes.                                                                   |
| [`SoftwareBuild`](#chipflow.platform.io.signatures.SoftwareBuild)                     | This holds the information needed for building software and providing the built outcome            |
| [`BinaryData`](#chipflow.platform.io.signatures.BinaryData)                           | This holds the information needed for building software and providing the built outcome            |
| [`Data`](#chipflow.platform.io.signatures.Data)                                       | Container for data associated with a ChipFlow component.                                           |
| [`DriverModel`](#chipflow.platform.io.signatures.DriverModel)                         | Options for [`SoftwareDriverSignature`](#chipflow.platform.io.signatures.SoftwareDriverSignature). |
| [`JTAGSignature`](#chipflow.platform.io.signatures.JTAGSignature)                     | Description of an interface object.                                                                |
| [`SPISignature`](#chipflow.platform.io.signatures.SPISignature)                       | Description of an interface object.                                                                |
| [`QSPIFlashSignature`](#chipflow.platform.io.signatures.QSPIFlashSignature)           | Description of an interface object.                                                                |
| [`UARTSignature`](#chipflow.platform.io.signatures.UARTSignature)                     | Description of an interface object.                                                                |
| [`I2CSignature`](#chipflow.platform.io.signatures.I2CSignature)                       | Description of an interface object.                                                                |
| [`GPIOSignature`](#chipflow.platform.io.signatures.GPIOSignature)                     | Description of an interface object.                                                                |
| [`SoftwareDriverSignature`](#chipflow.platform.io.signatures.SoftwareDriverSignature) | Description of an interface object.                                                                |

## Functions

| [`simulatable_interface`](#chipflow.platform.io.signatures.simulatable_interface)([base])   | Decorator for creating simulatable interface signatures.   |
|---------------------------------------------------------------------------------------------|------------------------------------------------------------|

## Module Contents

### *class* chipflow.platform.io.signatures.SimInterface

Bases: `typing_extensions.TypedDict`

Simulation interface metadata for ChipFlow components.

Attributes:
: uid: Unique identifier for the interface.
  parameters: List of (name, value) tuples for interface parameters.

### *class* chipflow.platform.io.signatures.DataclassProtocol

Bases: `Protocol`

Base class for protocol classes.

Protocol classes are defined as:

```default
class Proto(Protocol):
    def meth(self) -> int:
        ...
```

Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing).

For example:

```default
class C:
    def meth(self) -> int:
        return 0

def func(x: Proto) -> int:
    return x.meth()

func(C())  # Passes static type check
```

See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as:

```default
class GenProto[T](Protocol):
    def meth(self) -> T:
        ...
```

### *class* chipflow.platform.io.signatures.SoftwareBuild(\*, sources, includes=[], include_dirs=[], offset=0)

This holds the information needed for building software and providing the built outcome

* **Parameters:**
  * **sources** ([*list*](https://docs.python.org/3/library/stdtypes.html#list) *[*[*pathlib.Path*](https://docs.python.org/3/library/pathlib.html#pathlib.Path) *]*)
  * **includes** ([*list*](https://docs.python.org/3/library/stdtypes.html#list) *[*[*pathlib.Path*](https://docs.python.org/3/library/pathlib.html#pathlib.Path) *]*)

### *class* chipflow.platform.io.signatures.BinaryData(\*, filename, offset=0)

This holds the information needed for building software and providing the built outcome

* **Parameters:**
  **filename** ([*pathlib.Path*](https://docs.python.org/3/library/pathlib.html#pathlib.Path))

### *class* chipflow.platform.io.signatures.Data

Bases: `typing_extensions.TypedDict`, `Generic`[`_T_DataClass`]

Container for data associated with a ChipFlow component.

Attributes:
: data: The dataclass instance containing component data.

### *class* chipflow.platform.io.signatures.DriverModel

Bases: `typing_extensions.TypedDict`

Options for [`SoftwareDriverSignature`](#chipflow.platform.io.signatures.SoftwareDriverSignature).

Attributes:
: component: The `wiring.Component` that this is the signature for.
  regs_struct: The name of the C struct that represents the registers of this component.
  h_files: Header files for the driver.
  c_files: C files for the driver.
  regs_bus: The bus of this `Component` which contains its control registers.
  include_dirs: Any extra include directories needed by the driver.

### chipflow.platform.io.signatures.simulatable_interface(base='com.chipflow.chipflow')

Decorator for creating simulatable interface signatures.

The decorated class will have a `__chipflow_parameters__` method that returns
a list of tuples (name, value). It is expected that a model that takes parameters
is implemented as a template, with the parameters in the order given.

Args:
: base: Base UID string for the interface (default: “com.chipflow.chipflow”).

Returns:
: A decorator function that adds chipflow annotation support to a class.

### *class* chipflow.platform.io.signatures.JTAGSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](../iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.io.signatures.SPISignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](../iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.io.signatures.QSPIFlashSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](../iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.io.signatures.UARTSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](../iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.io.signatures.I2CSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](../iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.io.signatures.GPIOSignature(pin_count=1, \*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*chipflow.platform.io.iosignature.IOModelOptions*](../iosignature/index.md#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### *class* chipflow.platform.io.signatures.SoftwareDriverSignature(members, \*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a `Signature` object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when `connect()`ing two interface objects
together. See the [introduction to interfaces](../../../../../../amaranth/stdlib/wiring.md#wiring-intro1) for a more detailed
explanation of why this is useful.

`Signature` can be used as a base class to define [customized](../../../../../../amaranth/stdlib/wiring.md#wiring-customizing)
signatures and interface objects.

#### WARNING
`Signature` objects are immutable. Classes inheriting from `Signature` must
ensure this remains the case when additional functionality is added.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*DriverModel*](#chipflow.platform.io.signatures.DriverModel) *]*)


# index.html.md

# chipflow.platform.io.iosignature

IO signature definitions for ChipFlow platforms.

## Classes

| [`IOTripPoint`](#chipflow.platform.io.iosignature.IOTripPoint)       | Models various options for trip points for inputs.                                                                                                                                        |
|----------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [`IOModelOptions`](#chipflow.platform.io.iosignature.IOModelOptions) | Options for an IO pad/pin.                                                                                                                                                                |
| [`IOModel`](#chipflow.platform.io.iosignature.IOModel)               | Setting for IO Ports (see also base class [`IOModelOptions`](#chipflow.platform.io.iosignature.IOModelOptions)).                                                                          |
| [`IOSignature`](#chipflow.platform.io.iosignature.IOSignature)       | An [`Amaranth Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) used to decorate wires that would usually be brought out onto a port on the package. |

## Functions

| [`OutputIOSignature`](#chipflow.platform.io.iosignature.OutputIOSignature)(width, \*\*kwargs)   | This creates an [`Amaranth Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package output signals         |
|-------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [`InputIOSignature`](#chipflow.platform.io.iosignature.InputIOSignature)(width, \*\*kwargs)     | This creates an [`Amaranth Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package input signals          |
| [`BidirIOSignature`](#chipflow.platform.io.iosignature.BidirIOSignature)(width, \*\*kwargs)     | This creates an [`Amaranth Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package bi-directional signals |

## Module Contents

### *class* chipflow.platform.io.iosignature.IOTripPoint

Bases: [`enum.StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)

Models various options for trip points for inputs.
Depending on process and cell library, these may be statically or dynamically configurable.

You will get an error if the option is not available with the chosen process and cell library

### *class* chipflow.platform.io.iosignature.IOModelOptions

Bases: `typing_extensions.TypedDict`

Options for an IO pad/pin.

Attributes:
: invert: Polarity inversion. If the value is a simple `bool`, it specifies
  : inversion for the entire port. If the value is an iterable of `bool`,
    the iterable must have the same length as the width of `io`, and the
    inversion is specified for individual wires.
  <br/>
  individual_oe: Controls whether each output wire is associated with an
  : individual Output Enable bit or if a single OE bit will be used for
    entire port. The default value is False (indicating that a single OE
    bit controls the entire port).
  <br/>
  power_domain: The name of the I/O power domain. NB there is only one of
  : these, so IO with multiple power domains must be split up.
  <br/>
  clock_domain: The name of the I/O’s clock domain (see
  : `amaranth.hdl.ClockDomain`). NB there is only one of these, so IO
    with multiple clocks must be split up.
  <br/>
  buffer_in: Should the IO pad have an input buffer?
  buffer_out: Should the IO pad have an output buffer?
  sky130_drive_mode: Drive mode for output buffer on sky130.
  trip_point: Trip Point configuration for input buffer.
  init: The value for the initial values of the port.
  init_oe: The value for the initial values of the output enable(s) of the port.

### *class* chipflow.platform.io.iosignature.IOModel

Bases: [`IOModelOptions`](#chipflow.platform.io.iosignature.IOModelOptions)

Setting for IO Ports (see also base class [`IOModelOptions`](#chipflow.platform.io.iosignature.IOModelOptions)).

Attributes:
: direction: `io.Direction.Input`, `io.Direction.Output` or `io.Direction.Bidir`.
  width: Width of port, default is 1.

### *class* chipflow.platform.io.iosignature.IOSignature(\*\*kwargs)

Bases: [`amaranth.lib.wiring.Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature)

An [`Amaranth Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) used to decorate wires that would usually be brought out onto a port on the package.
This class is generally not directly used.  Instead, you would typically utilize the more specific
[`InputIOSignature`](#chipflow.platform.io.iosignature.InputIOSignature), [`OutputIOSignature`](#chipflow.platform.io.iosignature.OutputIOSignature), or [`BidirIOSignature`](#chipflow.platform.io.iosignature.BidirIOSignature) for defining pin interfaces.

* **Parameters:**
  **kwargs** (*typing_extensions.Unpack* *[*[*IOModel*](#chipflow.platform.io.iosignature.IOModel) *]*)

#### *property* direction *: [amaranth.lib.io.Direction](../../../../../../amaranth/stdlib/io.md#amaranth.lib.io.Direction)*

The direction of the IO port

* **Return type:**
  [amaranth.lib.io.Direction](../../../../../../amaranth/stdlib/io.md#amaranth.lib.io.Direction)

#### *property* width *: [int](https://docs.python.org/3/library/functions.html#int)*

The width of the IO port, in wires

* **Return type:**
  [int](https://docs.python.org/3/library/functions.html#int)

#### *property* invert *: [collections.abc.Iterable](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable)[[bool](https://docs.python.org/3/library/functions.html#bool)]*

A tuple as wide as the IO port, with a bool for the polarity inversion for each wire

* **Return type:**
  [collections.abc.Iterable](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable)[[bool](https://docs.python.org/3/library/functions.html#bool)]

#### *property* options *: [IOModelOptions](#chipflow.platform.io.iosignature.IOModelOptions)*

Options set on the io port at construction

* **Return type:**
  [IOModelOptions](#chipflow.platform.io.iosignature.IOModelOptions)

### chipflow.platform.io.iosignature.OutputIOSignature(width, \*\*kwargs)

This creates an [`Amaranth Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package output signals
intended for connection to the physical pads of the integrated circuit package.

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – specifies the number of individual output wires within this port, each of which will correspond to a separate physical pad on the integrated circuit package.
  * **kwargs** (*typing_extensions.Unpack* *[*[*IOModelOptions*](#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### chipflow.platform.io.iosignature.InputIOSignature(width, \*\*kwargs)

This creates an [`Amaranth Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package input signals
intended for connection to the physical pads of the integrated circuit package.

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – specifies the number of individual input wires within this port, each of which will correspond to a separate physical pad on the integrated circuit package.
  * **kwargs** (*typing_extensions.Unpack* *[*[*IOModelOptions*](#chipflow.platform.io.iosignature.IOModelOptions) *]*)

### chipflow.platform.io.iosignature.BidirIOSignature(width, \*\*kwargs)

This creates an [`Amaranth Signature`](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature) which is then used to decorate package bi-directional signals
intended for connection to the physical pads of the integrated circuit package.

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – specifies the number of individual input/output wires within this port. Each pair of input/output wires will correspond to a separate physical pad on the integrated circuit package.
  * **kwargs** (*typing_extensions.Unpack* *[*[*IOModelOptions*](#chipflow.platform.io.iosignature.IOModelOptions) *]*)


# index.html.md

# chipflow.platform.io.sky130

Sky130-specific IO definitions.

## Classes

| [`Sky130DriveMode`](#chipflow.platform.io.sky130.Sky130DriveMode)   | Models the potential drive modes of an SkyWater 130 IO cell [sky130_fd_io_\_gpiov2]([https://skywater-pdk.readthedocs.io/en/main/contents/libraries/sky130_fd_io/docs/user_guide.html](https://skywater-pdk.readthedocs.io/en/main/contents/libraries/sky130_fd_io/docs/user_guide.html))   |
|---------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|

## Module Contents

### *class* chipflow.platform.io.sky130.Sky130DriveMode

Bases: [`enum.StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)

Models the potential drive modes of an SkyWater 130 IO cell [sky130_fd_io_\_gpiov2]([https://skywater-pdk.readthedocs.io/en/main/contents/libraries/sky130_fd_io/docs/user_guide.html](https://skywater-pdk.readthedocs.io/en/main/contents/libraries/sky130_fd_io/docs/user_guide.html))
These are both statically configurable and can be set at runtime on the :py:mod:drive_mode.Sky130Port lines on the port.


# index.html.md

# chipflow.platform.io.annotate

Amaranth annotation utilities for ChipFlow.

## Functions

| [`submodule_metadata`](#chipflow.platform.io.annotate.submodule_metadata)(fragment, component_name[, recursive])   | Generator that finds `component_name` in `fragment` and yields metadata.   |
|--------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------|

## Module Contents

### chipflow.platform.io.annotate.submodule_metadata(fragment, component_name, recursive=False)

Generator that finds `component_name` in `fragment` and yields metadata.

Yields the `wiring.Component` instances of that component’s submodule, along
with their names and metadata.

Can only be run once for a given component (or its children).

Args:
: fragment: The fragment to search in.
  component_name: The name of the component to find.
  recursive: If True, name is a tuple of the hierarchy of names. Otherwise,
  <br/>
  > name is the string name of the first level component.

Yields:
: Tuple of (component, name, metadata) for each submodule.

* **Parameters:**
  * **fragment** (*amaranth.Fragment*)
  * **component_name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str))
* **Return type:**
  [collections.abc.Generator](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator)[Tuple[[amaranth.lib.wiring.Component](../../../../../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Component), [str](https://docs.python.org/3/library/stdtypes.html#str) | [tuple](https://docs.python.org/3/library/stdtypes.html#tuple), [dict](https://docs.python.org/3/library/stdtypes.html#dict)]]


# action.html.md

# CSR fields

The [`amaranth_soc.csr.action`](#module-amaranth_soc.csr.action) module provides built-in [`FieldAction`](reg.md#amaranth_soc.csr.reg.FieldAction) implementations intended for common use cases, which are split in three categories: [basic fields](#csr-action-basic) for numerical values, [flag fields](#csr-action-flag) for arrays of bits, and [reserved fields](#csr-action-reserved) to serve as placeholders for compatibility.

<a id="csr-action-basic"></a>

## Basic fields

Such fields are either exclusively writable by a CSR bus initiator (e.g. [`W`](#amaranth_soc.csr.action.W), [`RW`](#amaranth_soc.csr.action.RW)) or the peripheral itself (e.g. [`R`](#amaranth_soc.csr.action.R)). This effectively removes the possibility of a write conflict between a CSR bus initiator and the peripheral.

### *class* amaranth_soc.csr.action.R

A read-only [`FieldAction`](reg.md#amaranth_soc.csr.reg.FieldAction).

* **Parameters:**
  **shape** ([shape-like object](../../amaranth/guide.md#lang-shapelike)) – Shape of the field.
* **Members:**
  * **port** (`In(csr.reg.FieldPort.Signature(shape, "r"))`) – Field port.
  * **r_data** (`In(shape)`) – Read data. Drives `port.r_data`.
  * **r_stb** (`Out(1)`) – Read strobe. Driven by `port.r_stb`.

### *class* amaranth_soc.csr.action.W

A write-only [`FieldAction`](reg.md#amaranth_soc.csr.reg.FieldAction).

* **Parameters:**
  **shape** ([shape-like object](../../amaranth/guide.md#lang-shapelike)) – Shape of the field.
* **Members:**
  * **port** (`In(csr.reg.FieldPort.Signature(shape, "w"))`) – Field port.
  * **w_data** (`Out(shape)`) – Write data. Driven by `port.w_data`.
  * **w_stb** (`Out(1)`) – Write strobe. Driven by `port.w_stb`.

### *class* amaranth_soc.csr.action.RW

A read/write [`FieldAction`](reg.md#amaranth_soc.csr.reg.FieldAction), with built-in storage.

Storage is updated with the value of `port.w_data` one clock cycle after `port.w_stb` is
asserted.

* **Parameters:**
  * **shape** ([shape-like object](../../amaranth/guide.md#lang-shapelike)) – Shape of the field.
  * **init** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Storage initial value.
* **Members:**
  * **port** (`In(csr.reg.FieldPort.Signature(shape, "rw"))`) – Field port.
  * **data** (`Out(shape)`) – Storage output.

#### *property* init

Storage initial value.

* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

<a id="csr-action-flag"></a>

## Flag fields

Flag fields may be concurrently written by a CSR bus initiator and the peripheral. Each bit of a flag field may be set or cleared independently of others.

### Suggested use cases

- [`RW1C`](#amaranth_soc.csr.action.RW1C) flags may be used when a peripheral needs to notify the CPU of a given condition, such as an error or a pending interrupt. To acknowledge the notification, the CPU would then write 1 to the flag bit.
- [`RW1S`](#amaranth_soc.csr.action.RW1S) flags may be used for self-clearing bits, such as the enable bit of a one-shot timer. When the timer reaches its maximum value, it would automatically disable itself by clearing its enable bit.
- A pair of [`RW1C`](#amaranth_soc.csr.action.RW1C) and [`RW1S`](#amaranth_soc.csr.action.RW1S) flags may be used to target the same range of bits (e.g. that drives an array of GPIO pins). This allows a CSR bus initiator to set and clear bits in one write transaction (which is guaranteed to be atomic). If a single [`RW`](#amaranth_soc.csr.action.RW) field was used instead, a read-modify-write transaction would be needed, and would require locking to insure its atomicity in a multi-tasked environment.

### *class* amaranth_soc.csr.action.RW1C

A read/write-one-to-clear [`FieldAction`](reg.md#amaranth_soc.csr.reg.FieldAction), with built-in storage.

Storage bits are:

> * cleared by high bits in `port.w_data`, one clock cycle after `port.w_stb` is asserted;
> * set by high bits in `set`, one clock cycle after they are asserted.

If a storage bit is set and cleared on the same clock cycle, setting it has precedence.

* **Parameters:**
  * **shape** ([shape-like object](../../amaranth/guide.md#lang-shapelike)) – Shape of the field.
  * **init** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Storage initial value.
* **Members:**
  * **port** (`In(csr.reg.FieldPort.Signature(shape, "rw"))`) – Field port.
  * **data** (`Out(shape)`) – Storage output.
  * **set** (`In(shape)`) – Mask to set storage bits.

#### *property* init

Storage initial value.

* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

### *class* amaranth_soc.csr.action.RW1S

A read/write-one-to-set [`FieldAction`](reg.md#amaranth_soc.csr.reg.FieldAction), with built-in storage.

Storage bits are:

> * set by high bits in `port.w_data`, one clock cycle after `port.w_stb` is asserted;
> * cleared by high bits in `clear`, one clock cycle after they are asserted.

If a storage bit is set and cleared on the same clock cycle, setting it has precedence.

* **Parameters:**
  * **shape** ([shape-like object](../../amaranth/guide.md#lang-shapelike)) – Shape of the field.
  * **init** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Storage initial value.
* **Members:**
  * **port** (`In(csr.reg.FieldPort.Signature(shape, "rw"))`) – Field port.
  * **data** (`Out(shape)`) – Storage output.
  * **clear** (`In(shape)`) – Mask to clear storage bits.

#### *property* init

Storage initial value.

* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

<a id="csr-action-reserved"></a>

## Reserved fields

Reserved fields may be defined to provide placeholders for past, future or undocumented functions of a peripheral.

### Suggested use cases

#### Reserved for future use (as value)

A [`ResRAWL`](#amaranth_soc.csr.action.ResRAWL) field can be used as a placeholder to ensure forward compatibility of software binaries with future SoC revisions, where it may be replaced with a [basic field](#csr-action-basic).

The value returned by reads (and written back) must have defined semantics (e.g. a no-op) that can be relied upon in future SoC revisions. When writing to this field, software drivers targeting the current SoC revision must set up an atomic read-modify-write transaction.

#### Reserved for future use (as flag)

If a field is expected to be implemented as a [flag](#csr-action-flag) in a future SoC revision, it can be defined as a [`ResRAW0`](#amaranth_soc.csr.action.ResRAW0) field in the current revision to ensure forward compatibility of software binaries.

Software drivers targeting the current SoC revision should ignore the value returned by reads. Writing a value of 0 must be a no-op if the field is implemented in a future SoC revision.

#### Defined but deprecated

If a field was deprecated in a previous SoC revision, it can be replaced with a [`ResR0WA`](#amaranth_soc.csr.action.ResR0WA) field to ensure backward compatibility of software binaries.

The value of 0 returned by reads (and written back) must retain the semantics defined in the SoC revision where this field was deprecated.

#### Defined but unimplemented

If a field is only implemented in some variants of a peripheral, it can be replaced by a [`ResR0W0`](#amaranth_soc.csr.action.ResR0W0) field in the others.

### *class* amaranth_soc.csr.action.ResRAW0

A reserved read-any/write-zero [`FieldAction`](reg.md#amaranth_soc.csr.reg.FieldAction).

* **Parameters:**
  **shape** ([shape-like object](../../amaranth/guide.md#lang-shapelike)) – Shape of the field.
* **Members:**
  **port** (`In(csr.reg.FieldPort.Signature(shape, "nc"))`) – Field port.

### *class* amaranth_soc.csr.action.ResRAWL

A reserved read-any/write-last [`FieldAction`](reg.md#amaranth_soc.csr.reg.FieldAction).

* **Parameters:**
  **shape** ([shape-like object](../../amaranth/guide.md#lang-shapelike)) – Shape of the field.
* **Members:**
  **port** (`In(csr.reg.FieldPort.Signature(shape, "nc"))`) – Field port.

### *class* amaranth_soc.csr.action.ResR0WA

A reserved read-zero/write-any [`FieldAction`](reg.md#amaranth_soc.csr.reg.FieldAction).

* **Parameters:**
  **shape** ([shape-like object](../../amaranth/guide.md#lang-shapelike)) – Shape of the field.
* **Members:**
  **port** (`In(csr.reg.FieldPort.Signature(shape, "nc"))`) – Field port.

### *class* amaranth_soc.csr.action.ResR0W0

A reserved read-zero/write-zero [`FieldAction`](reg.md#amaranth_soc.csr.reg.FieldAction).

* **Parameters:**
  **shape** ([shape-like object](../../amaranth/guide.md#lang-shapelike)) – Shape of the field.
* **Members:**
  **port** (`In(csr.reg.FieldPort.Signature(shape, "nc"))`) – Field port.


# altera.html.md

# Altera

The [`AlteraPlatform`](#amaranth.vendor.AlteraPlatform) class provides a base platform to support Altera toolchains.

The Quartus and Mistral toolchains are supported.

### *class* amaranth.vendor.AlteraPlatform(\*, toolchain='Quartus')

### Quartus toolchain

Required tools:
: * `quartus_map`
  * `quartus_fit`
  * `quartus_asm`
  * `quartus_sta`

The environment is populated by running the script specified in the environment variable
`AMARANTH_ENV_QUARTUS`, if present.

Available overrides:
: * `add_settings`: inserts commands at the end of the QSF file.
  * `add_constraints`: inserts commands at the end of the SDC file.
  * `nproc`: sets the number of cores used by all tools.
  * `quartus_map_opts`: adds extra options for `quartus_map`.
  * `quartus_fit_opts`: adds extra options for `quartus_fit`.
  * `quartus_asm_opts`: adds extra options for `quartus_asm`.
  * `quartus_sta_opts`: adds extra options for `quartus_sta`.

Build products:
: * `*.rpt`: toolchain reports.
  * `{{name}}.sof`: bitstream as SRAM object file.
  * `{{name}}.rbf`: bitstream as raw binary file.

### Mistral toolchain

Required tools:
: * `yosys`
  * `nextpnr-mistral`

The environment is populated by running the script specified in the environment variable
`AMARANTH_ENV_MISTRAL`, if present.

> * `verbose`: enables logging of informational messages to standard error.
> * `read_verilog_opts`: adds options for `read_verilog` Yosys command.
> * `synth_opts`: adds options for `synth_intel_alm` Yosys command.
> * `script_after_read`: inserts commands after `read_rtlil` in Yosys script.
> * `script_after_synth`: inserts commands after `synth_intel_alm` in Yosys script.
> * `yosys_opts`: adds extra options for `yosys`.
> * `nextpnr_opts`: adds extra options for `nextpnr-mistral`.


# architecture.html.md

# ChipFlow Architecture Overview

This guide explains the overall architecture of ChipFlow and how different components work together to transform your Python hardware design into manufacturable silicon.

## High-Level Overview

ChipFlow follows a multi-stage flow from Python design to silicon:

```text
┌─────────────────┐
│  Python Design  │  Your Amaranth HDL design with ChipFlow signatures
│  (design.py)    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   Elaboration   │  Amaranth converts to Fragment tree
│                 │  ChipFlow annotations attached
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│     RTLIL       │  Intermediate representation with annotations
│  (design.rtlil) │  JSON schemas embedded as attributes
└────────┬────────┘
         │
         ├─────────────┬────────────────┬──────────────┐
         │             │                │              │
         ▼             ▼                ▼              ▼
┌────────────┐  ┌──────────────┐  ┌──────────┐  ┌──────────┐
│  Silicon   │  │  Simulation  │  │ Software │  │  Board   │
│  Platform  │  │   Platform   │  │ Platform │  │ Platform │
└────────────┘  └──────────────┘  └──────────┘  └──────────┘
     │                │                 │             │
     ▼                ▼                 ▼             ▼
 GDS-II          CXXRTL C++        soc.h + .elf    Bitstream
```

## Core Components

ChipFlow consists of several key subsystems that work together:

1. **Pin Signatures** - Define external interfaces (UART, GPIO, SPI, etc.)
2. **Annotation System** - Attach metadata to designs for platform consumption
3. **Package Definitions** - Map abstract ports to physical pins
4. **Platforms** - Transform RTLIL to target-specific outputs
5. **Steps** - Orchestrate the build process via CLI commands
6. **Configuration** - TOML-based project configuration

## Design Flow in Detail

### 1. User Defines Design

You write your design in Python using Amaranth HDL and ChipFlow signatures:

```python
class MySoC(wiring.Component):
    def __init__(self):
        super().__init__({
            "uart": Out(UARTSignature()),
            "gpio": Out(GPIOSignature(pin_count=8)),
        })

    def elaborate(self, platform):
        m = Module()
        # Your design logic here
        return m

# Verify the design can be instantiated
design = MySoC()
assert hasattr(design, 'uart')
assert hasattr(design, 'gpio')
```

### 2. Signatures Add Metadata

ChipFlow signatures are decorated with `@amaranth_annotate` which adds JSON schema metadata:

- **IOModel**: I/O configuration for external interfaces of the IC (direction, width, drive modes, trip points)
- **SimInterface**: Interface type identification for matching simulation models (UID, parameters)
- **DriverModel**: Software drivers for the IP block (C/H files, register structures)
- **Data**: Software binaries to load into memory (flash images, bootloaders)

This metadata is preserved through the entire flow.

### 3. Pin Allocation

When you run `chipflow pin lock`:

```text
Top-level Interface
(MySoC.uart, MySoC.gpio)
       │
       ▼
Extract IOSignatures
(UARTSignature, GPIOSignature)
       │
       ▼
Calculate Pin Requirements
(UART: 2 pins, GPIO: 8 pins)
       │
       ▼
Package Allocator
(Selects pins from package definition)
       │
       ▼
pins.lock File
(Persists allocation)
```

The `pins.lock` file maps abstract interface names to concrete package pin locations:

```javascript
{
  "uart.tx": {"pin": "42", "loc": "A12"},
  "uart.rx": {"pin": "43", "loc": "A13"},
  "gpio.gpio[0]": {"pin": "44", "loc": "B12"},
  ...
}
```

### 4. Elaboration & RTLIL Generation

Amaranth elaborates your design into a `Fragment` tree, then converts to RTLIL:

```text
Fragment Tree                RTLIL
┌──────────┐                ┌────────────────────────┐
│   Top    │                │ module \MySoC          │
│          │                │   (* chipflow.io = ... │
├──────────┤   ────────>    │   wire \uart$tx$o      │
│ MySoC    │                │   ...                  │
│  - uart  │                │ endmodule              │
│  - gpio  │                │                        │
└──────────┘                └────────────────────────┘
```

Annotations from signatures are embedded in RTLIL as attributes:

```verilog
(* chipflow.annotation.io-model = "{\"direction\": \"output\", \"width\": 1}" *)
wire \uart$tx$o;
```

### 5. Platform Consumption

Different platforms consume the RTLIL + annotations:

#### Silicon Platform

```text
RTLIL + pins.lock
      │
      ▼
Read IOModel annotations
(drive mode, trip point, etc.)
      │
      ▼
Create SiliconPlatformPort
(Sky130Port, etc.)
      │
      ▼
Generate I/O cell configuration
(PAD instances with controls)
      │
      ▼
Synthesis → Place & Route → GDS-II
```

#### Simulation Platform

```text
RTLIL
  │
  ▼
Read SimInterface annotations
(UID, parameters)
  │
  ▼
Match to C++ models
(UART model, SPI flash model)
  │
  ▼
Generate CXXRTL C++
  │
  ▼
Compile with models → Executable simulator
```

#### Software Platform

```text
Design Fragment
      │
      ▼
Read DriverModel annotations
(C/H files, regs_struct)
      │
      ▼
Extract memory map from Wishbone decoder
      │
      ▼
Generate soc.h with peripheral pointers
      │
      ▼
Compile user code + drivers → ELF binary
```

### 6. Step Orchestration

The `chipflow` CLI uses “Steps” to orchestrate the flow:

```text
$ chipflow silicon prepare
       │
       ▼
┌─────────────┐
│ SiliconStep │
│  .prepare() │
└─────────────┘
       │
       ├─> Load config (chipflow.toml)
       ├─> Instantiate top components
       ├─> Load pins.lock
       ├─> Create SiliconPlatform
       ├─> Elaborate design
       └─> Convert to RTLIL → build/silicon/design.rtlil

$ chipflow silicon submit
       │
       ▼
┌─────────────┐
│ SiliconStep │
│  .submit()  │
└─────────────┘
       │
       ├─> Package RTLIL + pins.lock
       ├─> Authenticate with API
       └─> Upload to ChipFlow cloud
```

## Annotation System Architecture

The annotation system is central to how ChipFlow propagates metadata:

1. **Decorator Application** (Design time)
   ```python
   @amaranth_annotate(IOModel, "https://chipflow.com/schemas/io-model/v0", "_model")
   class IOSignature(wiring.Signature):
       def __init__(self, width, direction, **kwargs):
           self._model = IOModel(width=width, direction=direction, **kwargs)
           # Decorator will extract self._model when serializing
   ```
2. **JSON Schema Generation** (Elaboration time)

   Pydantic TypeAdapter generates JSON schema from TypedDict:
   ```javascript
   {
     "$schema": "https://json-schema.org/draft/2020-12/schema",
     "$id": "https://chipflow.com/schemas/io-model/v0",
     "type": "object",
     "properties": {
       "direction": {"type": "string", "enum": ["input", "output", "bidir"]},
       "width": {"type": "integer"},
       "invert": {"type": "boolean"},
       ...
     }
   }
   ```
3. **RTLIL Embedding** (Conversion time)

   Amaranth calls `Annotation.as_json()` and embeds in RTLIL:
   ```verilog
   (* chipflow.annotation.io-model = "{\"direction\": \"output\", \"width\": 1}" *)
   ```
4. **Platform Extraction** (Build time)

   Platform uses `submodule_metadata()` to walk Fragment and extract:
   ```python
   for component, name, meta in submodule_metadata(frag, "top"):
       annotations = meta['annotations']
       if IO_ANNOTATION_SCHEMA in annotations:
           io_model = TypeAdapter(IOModel).validate_python(annotations[IO_ANNOTATION_SCHEMA])
           # Use io_model to configure platform
   ```

## Package System Architecture

Packages define the physical constraints of your chip:

```text
BasePackageDef
     ├── bringup_pins() → PowerPins, JTAGPins, etc.
     ├── allocate() → Assigns ports to pins
     └── instantiate() → Creates PortDesc for each allocation

LinearAllocPackageDef (extends BasePackageDef)
     └── Sequential allocation strategy

QuadPackageDef (extends LinearAllocPackageDef)
     └── PGA-style packages (pga144)

GAPackageDef (extends BasePackageDef)
     └── Grid array packages with row/col addressing

OpenframePackageDef (extends BasePackageDef)
     └── Open-frame packages with custom layouts
```

Allocation Flow:

```text
User runs: chipflow pin lock
       │
       ▼
┌──────────────────────┐
│ Load chipflow.toml   │
│ - process: sky130    │
│ - package: pga144    │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│ Instantiate package  │
│ PACKAGE_DEFS[pkg]    │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│ Elaborate top design │
│ Extract interfaces   │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│ For each interface:  │
│ - Get IOModel        │
│ - Create PortDesc    │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│ package.allocate()   │
│ - Assign pins        │
│ - Check constraints  │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│ Write pins.lock      │
│ - Persist mapping    │
└──────────────────────┘
```

## Configuration System

ChipFlow uses Pydantic models for configuration:

```text
chipflow.toml
     │ (parsed by tomllib)
     ▼
dict[str, Any]
     │ (validated by Pydantic)
     ▼
Config dataclass
├── chipflow: ChipFlowConfig
│   ├── project_name: str
│   ├── top: dict[str, str]
│   ├── clock_domains: list[str]
│   ├── silicon: SiliconConfig
│   │   ├── process: Process
│   │   └── package: str
│   ├── software: SoftwareConfig
│   │   └── riscv: CompilerConfig
│   └── simulation: SimulationConfig
└── tool: dict[str, Any]
```

Steps access config during execution:

```python
class SiliconStep(StepBase):
    def prepare(self):
        process = self.config.chipflow.silicon.process
        package = PACKAGE_DEFS[self.config.chipflow.silicon.package]
        # Use process and package to build...
```

## Extending ChipFlow

ChipFlow is designed to be extensible at multiple levels:

### Custom Pin Signatures

Create new interface types:

```python
@simulatable_interface()
class MyCustomSignature(wiring.Signature):
    def __init__(self, **kwargs):
        super().__init__({
            "custom": Out(BidirIOSignature(4, **kwargs))
        })
```

To attach a simulation model to your custom signature:

```python
from chipflow.platform import SimModel, BasicCxxBuilder

# Define the C++ model
MY_BUILDER = BasicCxxBuilder(
    models=[
        SimModel('my_custom', 'my_namespace', MyCustomSignature),
    ],
    hpp_files=[Path('design/sim/my_custom_model.h')],
)

# In your custom SimStep
class MySimPlatform(SimPlatform):
    def __init__(self, config):
        super().__init__(config)
        self._builders.append(MY_BUILDER)
```

See simulation-guide for complete examples of creating custom simulation models.

### Custom Steps

Override default behavior:

```python
from chipflow.platform import SiliconStep

class MySiliconStep(SiliconStep):
    def prepare(self):
        # Custom pre-processing
        result = super().prepare()
        # Custom post-processing
        return result
```

Reference in `chipflow.toml`:

```toml
[chipflow.steps]
silicon = "my_project.steps:MySiliconStep"
```

### Custom Packages

Define new package types:

```python
from chipflow.packaging import BasePackageDef

class MyPackageDef(BasePackageDef):
    def __init__(self):
        # Define pin layout
        pass

    def allocate(self, ports):
        # Custom allocation algorithm
        pass
```

### Custom Platforms

Add new target platforms:

```python
from chipflow.platform import StepBase

class MyPlatformStep(StepBase):
    def build(self, m, top):
        # Extract annotations
        # Generate output for custom platform
        pass
```

## See Also

- using-pin-signatures - User guide for pin signatures
- contributor-pin-signature-internals - Deep dive into annotation system
- chipflow-toml-guide - Configuration reference
- chipflow-commands - CLI command reference


# base.html.md

# Base Peripherals

Core system peripherals for SoC identification and timing.


# bus.html.md

# Wishbone bus

#### WARNING
This manual is a work in progress and is seriously incomplete!

<a id="module-amaranth_soc.wishbone.bus"></a>

The [`amaranth_soc.wishbone.bus`](#module-amaranth_soc.wishbone.bus) module provides Wishbone bus primitives.

### *class* amaranth_soc.wishbone.bus.CycleType

Wishbone Registered Feedback cycle type.

#### CLASSIC *= 0*

#### CONST_BURST *= 1*

#### INCR_BURST *= 2*

#### END_OF_BURST *= 7*

### *class* amaranth_soc.wishbone.bus.BurstTypeExt

Wishbone Registered Feedback burst type extension.

#### LINEAR *= 0*

#### WRAP_4 *= 1*

#### WRAP_8 *= 2*

#### WRAP_16 *= 3*

### *class* amaranth_soc.wishbone.bus.Feature

Optional Wishbone interface signals.

#### ERR *= 'err'*

#### RTY *= 'rty'*

#### STALL *= 'stall'*

#### LOCK *= 'lock'*

#### CTI *= 'cti'*

#### BTE *= 'bte'*

### *class* amaranth_soc.wishbone.bus.Signature

Wishbone interface signature.

See the [Wishbone specification](https://opencores.org/howto/wishbone) for description
of the Wishbone signals. The `RST_I` and `CLK_I` signals are provided as a part of
the clock domain that drives the interface.

The correspondence between the Amaranth-SoC signals and the Wishbone signals changes depending
on whether the interface acts as an initiator or a target.

* **Parameters:**
  * **addr_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Width of the address signal.
  * **data_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Width of the data signals (“port size” in Wishbone terminology).
    One of 8, 16, 32, 64.
  * **granularity** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Granularity of select signals (“port granularity” in Wishbone terminology).
    One of 8, 16, 32, 64.
    Optional. If `None` (by default), the granularity is equal to `data_width`.
  * **features** (iterable of [`Feature`](#amaranth_soc.wishbone.bus.Feature)) – Selects additional signals that will be a part of this interface.
    Optional.
* **Members:**
  * **adr** (`unsigned(addr_width)`) – Corresponds to Wishbone signal `ADR_O` (initiator) or `ADR_I` (target).
  * **dat_w** (`unsigned(data_width)`) – Corresponds to Wishbone signal `DAT_O` (initiator) or `DAT_I` (target).
  * **dat_r** (`unsigned(data_width)`) – Corresponds to Wishbone signal `DAT_I` (initiator) or `DAT_O` (target).
  * **sel** (`unsigned(data_width // granularity)`) – Corresponds to Wishbone signal `SEL_O` (initiator) or `SEL_I` (target).
  * **cyc** (`unsigned(1)`) – Corresponds to Wishbone signal `CYC_O` (initiator) or `CYC_I` (target).
  * **stb** (`unsigned(1)`) – Corresponds to Wishbone signal `STB_O` (initiator) or `STB_I` (target).
  * **we** (`unsigned(1)`) – Corresponds to Wishbone signal `WE_O`  (initiator) or `WE_I`  (target).
  * **ack** (`unsigned(1)`) – Corresponds to Wishbone signal `ACK_I` (initiator) or `ACK_O` (target).
  * **err** (`unsigned(1)`) – Optional. Corresponds to Wishbone signal `ERR_I` (initiator) or `ERR_O` (target).
  * **rty** (`unsigned(1)`) – Optional. Corresponds to Wishbone signal `RTY_I` (initiator) or `RTY_O` (target).
  * **stall** (`unsigned(1)`) – Optional. Corresponds to Wishbone signal `STALL_I` (initiator) or `STALL_O` (target).
  * **lock** (`unsigned(1)`) – Optional. Corresponds to Wishbone signal `LOCK_O` (initiator) or `LOCK_I` (target).
    Amaranth-SoC Wishbone support assumes that initiators that don’t want bus arbitration to
    happen in between two transactions need to use `lock` feature to guarantee this. An
    initiator without the `lock` feature may be arbitrated in between two transactions even
    if `cyc` is kept high.
  * **cti** (`unsigned(1)`) – Optional. Corresponds to Wishbone signal `CTI_O` (initiator) or `CTI_I` (target).
  * **bte** (`unsigned(1)`) – Optional. Corresponds to Wishbone signal `BTE_O` (initiator) or `BTE_I` (target).

#### addr_width

Width of the address signal.

* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

#### data_width

Width of the data signals (“port size” in Wishbone terminology).

* **Return type:**
  One of 8, 16, 32, 64.

#### granularity

Granularity of select signals (“port granularity” in Wishbone terminology).

* **Return type:**
  One of 8, 16, 32, 64.

#### features

Additional signals that will be a part of this interface.

* **Return type:**
  [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) of [`Feature`](#amaranth_soc.wishbone.bus.Feature)

#### create(\*, path=None, src_loc_at=0)

Create a compatible interface.

See [`amaranth.lib.wiring.Signature.create()`](../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature.create) for details.

* **Return type:**
  [`Interface`](#amaranth_soc.wishbone.bus.Interface)

#### \_\_eq_\_(other)

Compare signatures.

Two signatures are equal if they have the same address width, data width, granularity and
features.

### *class* amaranth_soc.wishbone.bus.Interface

Wishbone bus interface.

#### NOTE
The data width of the underlying [`MemoryMap`](../memory.md#amaranth_soc.memory.MemoryMap) of the interface is equal to port
granularity, not port size. If port granularity is less than port size, then the address
width of the underlying memory map is extended to reflect that.

* **Parameters:**
  * **addr_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Width of the address signal. See [`Signature`](#amaranth_soc.wishbone.bus.Signature).
  * **data_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Width of the data signals. See [`Signature`](#amaranth_soc.wishbone.bus.Signature).
  * **granularity** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Granularity of select signals. Optional. See [`Signature`](#amaranth_soc.wishbone.bus.Signature).
  * **features** (iterable of [`Feature`](#amaranth_soc.wishbone.bus.Feature)) – Describes additional signals of this interface. Optional. See [`Signature`](#amaranth_soc.wishbone.bus.Signature).
  * **path** (iter([`str`](https://docs.python.org/3/library/stdtypes.html#str))) – Path to this Wishbone interface. Optional. See [`amaranth.lib.wiring.PureInterface`](../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.PureInterface).

#### addr_width

Width of the address signal.

* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

#### data_width

Width of the data signals (“port size” in Wishbone terminology).

* **Return type:**
  One of 8, 16, 32, 64.

#### granularity

Granularity of select signals (“port granularity” in Wishbone terminology).

* **Return type:**
  One of 8, 16, 32, 64.

#### features

Additional signals that are part of this interface.

* **Return type:**
  [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) of [`Feature`](#amaranth_soc.wishbone.bus.Feature)

#### memory_map

Memory map of the bus.

* **Return type:**
  [`MemoryMap`](../memory.md#amaranth_soc.memory.MemoryMap) or `None`

### *class* amaranth_soc.wishbone.bus.Decoder

Wishbone bus decoder.

An address decoder for subordinate Wishbone buses.

* **Parameters:**
  * **addr_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Address width. See [`Signature`](#amaranth_soc.wishbone.bus.Signature).
  * **data_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Data width. See [`Signature`](#amaranth_soc.wishbone.bus.Signature).
  * **granularity** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Granularity. See [`Signature`](#amaranth_soc.wishbone.bus.Signature)
  * **features** (iterable of [`Feature`](#amaranth_soc.wishbone.bus.Feature)) – Optional signal set. See [`Signature`](#amaranth_soc.wishbone.bus.Signature).
  * **alignment** ([`int`](https://docs.python.org/3/library/functions.html#int), power-of-2 exponent) – Window alignment. Optional. See [`MemoryMap`](../memory.md#amaranth_soc.memory.MemoryMap).
* **Members:**
  **bus** (`In(wishbone.Signature(addr_width, data_width, granularity, features))`) – Wishbone bus providing access to subordinate buses.

#### align_to(alignment)

Align the implicit address of the next window.

See [`align_to()`](../memory.md#amaranth_soc.memory.MemoryMap.align_to) for details.

* **Returns:**
  Implicit next address.
* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

#### add(sub_bus, \*, name=None, addr=None, sparse=False)

Add a window to a subordinate bus.

See [`add_window()`](../memory.md#amaranth_soc.memory.MemoryMap.add_window) for details.

#### NOTE
The [`Decoder`](#amaranth_soc.wishbone.bus.Decoder) can perform either *sparse* or *dense* address translation:

> - If dense address translation is used (the default), the subordinate bus must have
>   the same data width as the [`Decoder`](#amaranth_soc.wishbone.bus.Decoder); the window will be contiguous.
> - If sparse address translation is used, the subordinate bus may have data width less
>   than the data width of the [`Decoder`](#amaranth_soc.wishbone.bus.Decoder); the window may be discontiguous.

In either case, the granularity of the subordinate bus must be equal to or less than
the granularity of the [`Decoder`](#amaranth_soc.wishbone.bus.Decoder).

* **Returns:**
  A tuple `(start, end, ratio)` describing the address range assigned to the window.
  When bridging buses of unequal data width, `ratio` is the amount of contiguous
  addresses on the narrower bus that are accessed for each transaction on the wider bus.
  Otherwise, it is always 1.
* **Return type:**
  [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of ([`int`](https://docs.python.org/3/library/functions.html#int), [`int`](https://docs.python.org/3/library/functions.html#int), [`int`](https://docs.python.org/3/library/functions.html#int))
* **Raises:**
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the subordinate bus granularity is greater than the [`Decoder`](#amaranth_soc.wishbone.bus.Decoder) granularity.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If dense address translation is used and the subordinate bus data width is not equal
        to the [`Decoder`](#amaranth_soc.wishbone.bus.Decoder) data width.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If sparse address translation is used and the subordinate bus data width is not the
        equal to the subordinate bus granularity.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the subordinate bus as an optional output signal that is not present in the
        [`Decoder`](#amaranth_soc.wishbone.bus.Decoder) interface.

### *class* amaranth_soc.wishbone.bus.Arbiter

Wishbone bus arbiter.

A round-robin arbiter for initiators accessing a shared Wishbone bus.

* **Parameters:**
  * **addr_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Address width. See [`Signature`](#amaranth_soc.wishbone.bus.Signature).
  * **data_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Data width. See [`Signature`](#amaranth_soc.wishbone.bus.Signature).
  * **granularity** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Granularity. See [`Signature`](#amaranth_soc.wishbone.bus.Signature)
  * **features** (iterable of [`Feature`](#amaranth_soc.wishbone.bus.Feature)) – Optional signal set. See [`Signature`](#amaranth_soc.wishbone.bus.Signature).
* **Members:**
  **bus** (`Out(wishbone.Signature(addr_width, data_width, granularity, features))`) – Shared Wishbone bus.

#### add(intr_bus)

Add an initiator bus to the arbiter.

* **Raises:**
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the initiator bus address width is not equal to the [`Arbiter`](#amaranth_soc.wishbone.bus.Arbiter) address width.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the initiator bus granularity is lesser than the [`Arbiter`](#amaranth_soc.wishbone.bus.Arbiter) granularity.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the initiator bus data width is not equal to the [`Arbiter`](#amaranth_soc.wishbone.bus.Arbiter) data width.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the [`Arbiter`](#amaranth_soc.wishbone.bus.Arbiter) has an optional output signal that is not present in the
        initiator bus.


# bus.html.md

# CSR bus

The [`amaranth_soc.csr.bus`](#module-amaranth_soc.csr.bus) module contains primitives to implement and access the registers of peripherals through a bus interface.

<!-- from amaranth import *
from amaranth.lib import wiring
from amaranth.lib.wiring import In, Out, flipped, connect

from amaranth_soc import csr
from amaranth_soc.memory import * -->

<a id="csr-bus-introduction"></a>

## Introduction

### Overview

The CSR bus API provides unopinionated primitives for defining and connecting the *Control and Status Registers* of SoC peripherals, with an emphasis on safety and resource efficiency. It is composed of low-level [register interfaces](#csr-bus-element), [multiplexers](#csr-bus-multiplexer) that provide access to the registers of a peripheral, and [bus decoders](#csr-bus-decoder) that provide access to subordinate bus interfaces.

This diagram shows a CSR bus decoder being used to provide access to the registers of two peripherals:

![image](amaranth-soc/csr/_images/csr-bus.png)

## Examples

<a id="csr-bus-element"></a>

### Defining registers

A CSR register is a [`Component`](../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Component) with an [`Element`](#amaranth_soc.csr.bus.Element) member in its interface, oriented as input and named `"element"`.

For example, this component is a read/write register with a configurable width:

```python
class MyRegister(wiring.Component):
    def __init__(self, width):
        super().__init__({
            "element": In(csr.Element.Signature(width, "rw")),
            "data": Out(width),
        })

    def elaborate(self, platform):
        m = Module()
        storage = Signal.like(self.data)

        with m.If(self.element.w_stb):
            m.d.sync += storage.eq(self.element.w_data)

        m.d.comb += [
            self.element.r_data.eq(storage),
            self.data.eq(storage),
        ]

        return m
```

CSR bus transactions go through the [`Element`](#amaranth_soc.csr.bus.Element) port and always target the entire register. Transactions are completed in one clock cycle, regardless of the register width. A read and a write access can be part of the same transaction.

<a id="csr-bus-multiplexer"></a>

### Accessing registers

A [`Multiplexer`](#amaranth_soc.csr.bus.Multiplexer) can provide access to the registers of a peripheral through a CSR bus [`Interface`](#amaranth_soc.csr.bus.Interface). Registers must first be added to a `MemoryMap`, which is used to instantiate the multiplexer.

The following example shows a very basic timer peripheral with an 8-bit CSR bus and two 24-bit registers, `Cnt` and `Rst`. The value of `Cnt` is incremented every clock cycle, and can be reset by a CSR bus write to `Rst`:

```python
class BasicTimer(wiring.Component):
    class Cnt(wiring.Component):
        element: In(csr.Element.Signature(width=24, access="r"))
        r_stb:   Out(1)
        r_data:  In(unsigned(24))

        def elaborate(self, platform):
            m = Module()
            m.d.comb += [
                self.r_stb.eq(self.element.r_stb),
                self.element.r_data.eq(self.r_data),
            ]
            return m

    class Rst(wiring.Component):
        element: In(csr.Element.Signature(width=24, access="w"))
        w_stb:   Out(1)
        w_data:  Out(unsigned(24))

        def elaborate(self, platform):
            m = Module()
            m.d.comb += [
                self.w_stb.eq(self.element.w_stb),
                self.w_data.eq(self.element.w_data),
            ]
            return m

    def __init__(self):
        super().__init__({
            "csr_bus": In(csr.Signature(addr_width=3, data_width=8)),
        })

        self._reg_cnt = self.Cnt()
        self._reg_rst = self.Rst()

        self.csr_bus.memory_map = MemoryMap(addr_width=3, data_width=8, alignment=2)
        self.csr_bus.memory_map.add_resource(self._reg_cnt, size=3, name=("cnt",))
        self.csr_bus.memory_map.add_resource(self._reg_rst, size=3, name=("rst",))

        self._csr_mux = csr.Multiplexer(self.csr_bus.memory_map)

    def elaborate(self, platform):
        m = Module()
        m.submodules.reg_cnt = self._reg_cnt
        m.submodules.reg_rst = self._reg_rst
        m.submodules.csr_mux = self._csr_mux

        connect(m, flipped(self.csr_bus), self._csr_mux.bus)

        count = Signal(unsigned(24))

        m.d.comb += self._reg_cnt.r_data.eq(count)

        with m.If(self._reg_rst.w_stb):
            m.d.sync += count.eq(self._reg_rst.w_data)
        with m.Else():
            m.d.sync += count.eq(count + 1)

        return m
```

```pycon
>>> timer = BasicTimer()
>>> for res_info in timer.csr_bus.memory_map.all_resources():
...     print(res_info)
ResourceInfo(path=(Name('cnt'),), start=0x0, end=0x4, width=8)
ResourceInfo(path=(Name('rst'),), start=0x4, end=0x8, width=8)
```

Registers are always accessed atomically, regardless of their size. Each register is split into chunks according to the CSR bus data width, and each chunk is assigned a consecutive address on the bus.

In this example, the sizes of `Cnt` and `Rst` are extended from 24 to 32 bits, because they were added to `csr_bus.memory_map` with an [alignment](../memory.md#memory-alignment) of 32 bits.

The following diagram shows a read transaction from the `Cnt` register:

The [`Multiplexer`](#amaranth_soc.csr.bus.Multiplexer) adds a delay of 1 clock cycle to CSR bus reads (represented by *t1*) between the time of assertion of `csr_bus.r_stb` and the time the first chunk is transmitted to `csr_bus.r_data`.

A read transaction targeting `Cnt` requires 4 bus reads to complete and has a latency of 4 clock cycles (represented by *t2*).

When the first chunk of `Cnt` is read, the value of all of its chunks (at point labelled *a*) is captured by a shadow register internal to the multiplexer (at point labelled *b*). Reads from any chunk return the captured values (at points labelled *1*, *2*, *3*, *4*).

The following diagram shows a write transaction to the `Rst` register, which resets the value of the `Cnt` register as a side-effect:

A write transaction targeting `Rst` requires 4 bus writes to complete and has a latency of 4 clock cycles (represented by *t1*).

When a chunk of `Rst` is written (at point labelled *1*), the written value is captured by a shadow register internal to the multiplexer (at point labelled *a*). A write to the last chunk (at point labelled *4*) causes all captured values to be written to the register (at point labelled *c*).

The [`Multiplexer`](#amaranth_soc.csr.bus.Multiplexer) adds a delay of 1 clock cycle to CSR bus writes (represented by *t2*) between the time of assertion of `csr_bus.w_stb` and the time of assertion of `reg_rst.w_stb`.

As a side-effect of the transaction, the next value of `Cnt` becomes the value that was written to `Rst` (at point labelled *d*).

#### WARNING
To safely access registers over the bus interface of a [`Multiplexer`](#amaranth_soc.csr.bus.Multiplexer), the following
rules apply:

> 1. the bus initiator must have exclusive ownership over the address range of the multiplexer until the register transaction is either completed or aborted.
> 2. the bus initiator must access a register in ascending order of addresses, but it may abort the transaction after any bus cycle.

<a id="csr-bus-decoder"></a>

### Accessing a hierarchy of registers

A [`Decoder`](#amaranth_soc.csr.bus.Decoder) can provide access to group of [`Multiplexer`](#amaranth_soc.csr.bus.Multiplexer)s and subordinate [`Decoder`](#amaranth_soc.csr.bus.Decoder)s, forming a hierarchical address space of CSR registers.

In the following example, a CSR decoder provides access to the registers of two peripherals:

```python
timer0 = BasicTimer()
timer1 = BasicTimer()

csr_dec = csr.Decoder(addr_width=16, data_width=8)
csr_dec.add(timer0.csr_bus, addr=0x0000, name="timer0")
csr_dec.add(timer1.csr_bus, addr=0x1000, name="timer1")
```

```pycon
>>> for res_info in csr_dec.bus.memory_map.all_resources():
...     print(res_info)
ResourceInfo(path=(Name('timer0'), Name('cnt')), start=0x0, end=0x4, width=8)
ResourceInfo(path=(Name('timer0'), Name('rst')), start=0x4, end=0x8, width=8)
ResourceInfo(path=(Name('timer1'), Name('cnt')), start=0x1000, end=0x1004, width=8)
ResourceInfo(path=(Name('timer1'), Name('rst')), start=0x1004, end=0x1008, width=8)
```

Although there is no functional difference between adding a group of registers directly to a [`Multiplexer`](#amaranth_soc.csr.bus.Multiplexer) and adding them to multiple [`Multiplexer`](#amaranth_soc.csr.bus.Multiplexer)s that are aggregated with a [`Decoder`](#amaranth_soc.csr.bus.Decoder), hierarchical CSR buses are useful for organizing a hierarchical design.

If many peripherals are directly served by a single [`Multiplexer`](#amaranth_soc.csr.bus.Multiplexer), a very large amount of ports will connect the peripheral registers to the multiplexer, and the cost of decoding logic would not be attributed to specific peripherals. With a [`Decoder`](#amaranth_soc.csr.bus.Decoder), only five signals per peripheral will be used, and the logic could be kept together with the peripheral.

## Register interfaces

#### *class* Element.Access

Register access mode.

Coarse access mode for the entire register. Individual fields can have more restrictive
access mode, e.g. R/O fields can be a part of an R/W register.

#### R *= 'r'*

Read-only mode.

#### W *= 'w'*

Write-only mode.

#### RW *= 'rw'*

Read/write mode.

#### readable()

Readable access mode.

* **Returns:**
  `True` if equal to [`R`](#amaranth_soc.csr.bus.Element.Access.R) or [`RW`](#amaranth_soc.csr.bus.Element.Access.RW).
* **Return type:**
  [`bool`](https://docs.python.org/3/library/functions.html#bool)

#### writable()

Writable access mode.

* **Returns:**
  `True` if equal to [`W`](#amaranth_soc.csr.bus.Element.Access.W) or [`RW`](#amaranth_soc.csr.bus.Element.Access.RW).
* **Return type:**
  [`bool`](https://docs.python.org/3/library/functions.html#bool)

#### *class* Element.Signature

CSR register signature.

* **Parameters:**
  * **width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Width of the register.
  * **access** ([`Element.Access`](#amaranth_soc.csr.bus.Element.Access)) – Register access mode.
* **Members:**
  * **r_data** (`In(width)`) – Read data. Must be always valid, and is sampled when `r_stb` is asserted.
  * **r_stb** (`Out(1)`) – Read strobe. Registers with read side effects should perform the read side effect when
    this strobe is asserted.
  * **w_data** (`Out(width)`) – Write data. Valid only when `w_stb` is asserted.
  * **w_stb** (`Out(1)`) – Write strobe. Registers should update their value or perform the write side effect when
    this strobe is asserted.

#### create(\*, path=None, src_loc_at=0)

Create a compatible interface.

See [`amaranth.lib.wiring.Signature.create()`](../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature.create) for details.

* **Return type:**
  [`Element`](#amaranth_soc.csr.bus.Element).

#### \_\_eq_\_(other)

Compare signatures.

Two signatures are equal if they have the same width and register access mode.

### *class* amaranth_soc.csr.bus.Element

CSR register interface.

A low-level interface to a single atomically readable and writable register in a peripheral.
This interface supports any register width and semantics, provided that both reads and writes
always succeed and complete in one cycle.

* **Parameters:**
  * **width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Width of the register.
  * **access** ([`Element.Access`](#amaranth_soc.csr.bus.Element.Access)) – Register access mode.
  * **path** (iterable of [`str`](https://docs.python.org/3/library/stdtypes.html#str)) – Path to this interface. Optional. See [`amaranth.lib.wiring.PureInterface`](../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.PureInterface).

<a id="csr-bus-interface"></a>

## Bus interfaces

### *class* amaranth_soc.csr.bus.Signature

CSR bus signature.

* **Parameters:**
  * **addr_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Address width. At most `(2 ** addr_width) * data_width` register bits will be available.
  * **data_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Data width. Registers are accessed in `data_width` sized chunks.
* **Members:**
  * **addr** (`Out(addr_width)`) – Address for reads and writes.
  * **r_data** (`In(data_width)`) – Read data. Valid on the next cycle after `r_stb` is asserted. Otherwise, zero. (Keeping
    read data of an unused interface at zero simplifies multiplexers.)
  * **r_stb** (`Out(1)`) – Read strobe. If `addr` points to the first chunk of a register, captures register value
    and causes read side effects to be performed (if any). If `addr` points to any chunk
    of a register, latches the captured value to `r_data`. Otherwise, latches zero
    to `r_data`.
  * **w_data** (`Out(data_width)`) – Write data. Must be valid when `w_stb` is asserted.
  * **w_stb** (`Out(1)`) – Write strobe. If `addr` points to the last chunk of a register, writes captured value
    to the register and causes write side effects to be performed (if any). If `addr` points
    to any chunk of a register, latches `w_data` to the captured value. Otherwise, does
    nothing.

#### create(\*, path=None, src_loc_at=0)

Create a compatible interface.

See [`amaranth.lib.wiring.Signature.create()`](../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature.create) for details.

* **Return type:**
  [`Interface`](#amaranth_soc.csr.bus.Interface)

#### \_\_eq_\_(other)

Compare signatures.

Two signatures are equal if they have the same address width and data width.

### *class* amaranth_soc.csr.bus.Interface

CSR bus interface.

A low-level interface to a set of atomically readable and writable peripheral CSR registers.

* **Parameters:**
  * **addr_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Address width. See [`Signature`](#amaranth_soc.csr.bus.Signature).
  * **data_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Data width. See [`Signature`](#amaranth_soc.csr.bus.Signature).
  * **path** (iterable of [`str`](https://docs.python.org/3/library/stdtypes.html#str)) – Path to this CSR interface. Optional. See [`amaranth.lib.wiring.PureInterface`](../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.PureInterface).

#### memory_map

Memory map of the bus.

* **Return type:**
  [`MemoryMap`](../memory.md#amaranth_soc.memory.MemoryMap) or `None`
* **Raises:**
  [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If set to a memory map that does not have the same address and data widths as the bus
      interface.

## Bus primitives

### *class* amaranth_soc.csr.bus.Multiplexer

CSR register multiplexer.

An address-based multiplexer for CSR registers implementing atomic updates.

Writes are registered, and are performed 1 cycle after `w_stb` is asserted.

#### NOTE
Because the CSR bus conserves logic and routing resources, it is common to e.g. bridge a CSR
bus with a narrow *N*-bit datapath to a CPU with a wider *W*-bit datapath (*W>N*) in cases
where CSR access latency is less important than resource usage.

In this case, two strategies are possible for connecting the CSR bus to the CPU:

> * The CPU could access the CSR bus directly (with no intervening logic other than simple
>   translation of control signals). The register alignment should be set to 1 (i.e.
>   `memory_map.alignment` should be 0), and each *R*-bit register would occupy
>   *ceil(R/N)* addresses from the CPU perspective, requiring the same amount of memory
>   instructions to access.
> * The CPU could access the CSR bus through a width down-converter, which would issue
>   *W/N* CSR accesses for each CPU access. The register alignment should be set to *W/N*,
>   and each *R*-bit register would occupy *ceil(R/K)* addresses from the CPU perspective,
>   requiring the same amount of memory instructions to access.

If the register alignment is greater than 1, it affects which CSR bus write is considered a
write to the last register chunk. For example, if a 24-bit register is accessed through an
8-bit CSR bus and a CPU with a 32-bit datapath, a write to this register requires 4 CSR bus
writes to complete, and the last write is the one that actually writes the value to the
register. This allows determining write latency solely from the amount of addresses occupied
by the register in the CPU address space, and the CSR bus data width.

* **Parameters:**
  * **memory_map** ([`MemoryMap`](../memory.md#amaranth_soc.memory.MemoryMap)) – Memory map of CSR registers.
  * **shadow_overlaps** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Maximum number of CSR registers that can share a chunk of a shadow register.
    Optional. If `None`, any number of CSR registers can share a shadow chunk.
* **Members:**
  **bus** (`In(csr.Signature(memory_map.addr_width, memory_map.data_width))`) – CSR bus providing access to registers.

### *class* amaranth_soc.csr.bus.Decoder

CSR bus decoder.

An address decoder for subordinate CSR buses.

* **Parameters:**
  * **addr_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Address width. See [`Interface`](#amaranth_soc.csr.bus.Interface).
  * **data_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Data width. See [`Interface`](#amaranth_soc.csr.bus.Interface).
  * **alignment** ([`int`](https://docs.python.org/3/library/functions.html#int), power-of-2 exponent) – Window alignment. See [`MemoryMap`](../memory.md#amaranth_soc.memory.MemoryMap).
* **Members:**
  **bus** (`In(csr.Signature(addr_width, data_width))`) – CSR bus providing access to subordinate buses.

#### align_to(alignment)

Align the implicit address of the next window.

See [`align_to()`](../memory.md#amaranth_soc.memory.MemoryMap.align_to) for details.

* **Returns:**
  Implicit next address.
* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

#### add(sub_bus, \*, name=None, addr=None)

Add a window to a subordinate bus.

See [`add_window()`](../memory.md#amaranth_soc.memory.MemoryMap.add_window) for details.

* **Returns:**
  A tuple `(start, end, ratio)` describing the address range assigned to the window.
  `ratio` is always 1.
* **Return type:**
  [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of ([`int`](https://docs.python.org/3/library/functions.html#int), [`int`](https://docs.python.org/3/library/functions.html#int), [`int`](https://docs.python.org/3/library/functions.html#int))
* **Raises:**
  [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the subordinate bus data width is not equal to the [`Decoder`](#amaranth_soc.csr.bus.Decoder) data width.


# catalog.html.md

# Algorithm catalog

This module contains a catalog of predefined CRC algorithms, retrieved from the [reveng catalogue](https://reveng.sourceforge.io/crc-catalogue/all.htm)
on 2023-05-25.

See the documentation for the [`crc`](../crc.md#module-amaranth.lib.crc) module for examples.

### amaranth.lib.crc.catalog.CRC3_GSM *= Algorithm(crc_width=3, polynomial=0x3, initial_crc=0x0, reflect_input=False, reflect_output=False, xor_output=0x7)*

### amaranth.lib.crc.catalog.CRC3_ROHC *= Algorithm(crc_width=3, polynomial=0x3, initial_crc=0x7, reflect_input=True, reflect_output=True, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC4_G_704 *= Algorithm(crc_width=4, polynomial=0x3, initial_crc=0x0, reflect_input=True, reflect_output=True, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC4_ITU *= Algorithm(crc_width=4, polynomial=0x3, initial_crc=0x0, reflect_input=True, reflect_output=True, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC4_INTERLAKEN *= Algorithm(crc_width=4, polynomial=0x3, initial_crc=0xf, reflect_input=False, reflect_output=False, xor_output=0xf)*

### amaranth.lib.crc.catalog.CRC5_EPC_C1G2 *= Algorithm(crc_width=5, polynomial=0x9, initial_crc=0x9, reflect_input=False, reflect_output=False, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC5_EPC *= Algorithm(crc_width=5, polynomial=0x9, initial_crc=0x9, reflect_input=False, reflect_output=False, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC5_G_704 *= Algorithm(crc_width=5, polynomial=0x15, initial_crc=0x0, reflect_input=True, reflect_output=True, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC5_ITU *= Algorithm(crc_width=5, polynomial=0x15, initial_crc=0x0, reflect_input=True, reflect_output=True, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC5_USB *= Algorithm(crc_width=5, polynomial=0x5, initial_crc=0x1f, reflect_input=True, reflect_output=True, xor_output=0x1f)*

### amaranth.lib.crc.catalog.CRC6_CDMA2000_A *= Algorithm(crc_width=6, polynomial=0x27, initial_crc=0x3f, reflect_input=False, reflect_output=False, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC6_CDMA2000_B *= Algorithm(crc_width=6, polynomial=0x7, initial_crc=0x3f, reflect_input=False, reflect_output=False, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC6_DARC *= Algorithm(crc_width=6, polynomial=0x19, initial_crc=0x0, reflect_input=True, reflect_output=True, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC6_G_704 *= Algorithm(crc_width=6, polynomial=0x3, initial_crc=0x0, reflect_input=True, reflect_output=True, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC6_ITU *= Algorithm(crc_width=6, polynomial=0x3, initial_crc=0x0, reflect_input=True, reflect_output=True, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC6_GSM *= Algorithm(crc_width=6, polynomial=0x2f, initial_crc=0x0, reflect_input=False, reflect_output=False, xor_output=0x3f)*

### amaranth.lib.crc.catalog.CRC7_MMC *= Algorithm(crc_width=7, polynomial=0x9, initial_crc=0x0, reflect_input=False, reflect_output=False, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC7_ROHC *= Algorithm(crc_width=7, polynomial=0x4f, initial_crc=0x7f, reflect_input=True, reflect_output=True, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC7_UMTS *= Algorithm(crc_width=7, polynomial=0x45, initial_crc=0x0, reflect_input=False, reflect_output=False, xor_output=0x0)*

### amaranth.lib.crc.catalog.CRC8_AUTOSAR *= Algorithm(crc_width=8, polynomial=0x2f, initial_crc=0xff, reflect_input=False, reflect_output=False, xor_output=0xff)*

### amaranth.lib.crc.catalog.CRC8_BLUETOOTH *= Algorithm(crc_width=8, polynomial=0xa7, initial_crc=0x00, reflect_input=True, reflect_output=True, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_CDMA2000 *= Algorithm(crc_width=8, polynomial=0x9b, initial_crc=0xff, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_DARC *= Algorithm(crc_width=8, polynomial=0x39, initial_crc=0x00, reflect_input=True, reflect_output=True, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_DVB_S2 *= Algorithm(crc_width=8, polynomial=0xd5, initial_crc=0x00, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_GSM_A *= Algorithm(crc_width=8, polynomial=0x1d, initial_crc=0x00, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_GSM_B *= Algorithm(crc_width=8, polynomial=0x49, initial_crc=0x00, reflect_input=False, reflect_output=False, xor_output=0xff)*

### amaranth.lib.crc.catalog.CRC8_HITAG *= Algorithm(crc_width=8, polynomial=0x1d, initial_crc=0xff, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_I_432_1 *= Algorithm(crc_width=8, polynomial=0x07, initial_crc=0x00, reflect_input=False, reflect_output=False, xor_output=0x55)*

### amaranth.lib.crc.catalog.CRC8_ITU *= Algorithm(crc_width=8, polynomial=0x07, initial_crc=0x00, reflect_input=False, reflect_output=False, xor_output=0x55)*

### amaranth.lib.crc.catalog.CRC8_I_CODE *= Algorithm(crc_width=8, polynomial=0x1d, initial_crc=0xfd, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_LTE *= Algorithm(crc_width=8, polynomial=0x9b, initial_crc=0x00, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_MAXIM_DOW *= Algorithm(crc_width=8, polynomial=0x31, initial_crc=0x00, reflect_input=True, reflect_output=True, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_MAXIM *= Algorithm(crc_width=8, polynomial=0x31, initial_crc=0x00, reflect_input=True, reflect_output=True, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_MIFARE_MAD *= Algorithm(crc_width=8, polynomial=0x1d, initial_crc=0xc7, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_NRSC_5 *= Algorithm(crc_width=8, polynomial=0x31, initial_crc=0xff, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_OPENSAFETY *= Algorithm(crc_width=8, polynomial=0x2f, initial_crc=0x00, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_ROHC *= Algorithm(crc_width=8, polynomial=0x07, initial_crc=0xff, reflect_input=True, reflect_output=True, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_SAE_J1850 *= Algorithm(crc_width=8, polynomial=0x1d, initial_crc=0xff, reflect_input=False, reflect_output=False, xor_output=0xff)*

### amaranth.lib.crc.catalog.CRC8_SMBUS *= Algorithm(crc_width=8, polynomial=0x07, initial_crc=0x00, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_TECH_3250 *= Algorithm(crc_width=8, polynomial=0x1d, initial_crc=0xff, reflect_input=True, reflect_output=True, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_AES *= Algorithm(crc_width=8, polynomial=0x1d, initial_crc=0xff, reflect_input=True, reflect_output=True, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_ETU *= Algorithm(crc_width=8, polynomial=0x1d, initial_crc=0xff, reflect_input=True, reflect_output=True, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC8_WCDMA *= Algorithm(crc_width=8, polynomial=0x9b, initial_crc=0x00, reflect_input=True, reflect_output=True, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC10_ATM *= Algorithm(crc_width=10, polynomial=0x233, initial_crc=0x00, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC10_I_610 *= Algorithm(crc_width=10, polynomial=0x233, initial_crc=0x00, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC10_CDMA2000 *= Algorithm(crc_width=10, polynomial=0x3d9, initial_crc=0x3ff, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC10_GSM *= Algorithm(crc_width=10, polynomial=0x175, initial_crc=0x00, reflect_input=False, reflect_output=False, xor_output=0x3ff)*

### amaranth.lib.crc.catalog.CRC11_FLEXRAY *= Algorithm(crc_width=11, polynomial=0x385, initial_crc=0x1a, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC11_UMTS *= Algorithm(crc_width=11, polynomial=0x307, initial_crc=0x00, reflect_input=False, reflect_output=False, xor_output=0x00)*

### amaranth.lib.crc.catalog.CRC12_CDMA2000 *= Algorithm(crc_width=12, polynomial=0xf13, initial_crc=0xfff, reflect_input=False, reflect_output=False, xor_output=0x000)*

### amaranth.lib.crc.catalog.CRC12_DECT *= Algorithm(crc_width=12, polynomial=0x80f, initial_crc=0x000, reflect_input=False, reflect_output=False, xor_output=0x000)*

### amaranth.lib.crc.catalog.CRC12_GSM *= Algorithm(crc_width=12, polynomial=0xd31, initial_crc=0x000, reflect_input=False, reflect_output=False, xor_output=0xfff)*

### amaranth.lib.crc.catalog.CRC12_UMTS *= Algorithm(crc_width=12, polynomial=0x80f, initial_crc=0x000, reflect_input=False, reflect_output=True, xor_output=0x000)*

### amaranth.lib.crc.catalog.CRC12_3GPP *= Algorithm(crc_width=12, polynomial=0x80f, initial_crc=0x000, reflect_input=False, reflect_output=True, xor_output=0x000)*

### amaranth.lib.crc.catalog.CRC13_BBC *= Algorithm(crc_width=13, polynomial=0x1cf5, initial_crc=0x000, reflect_input=False, reflect_output=False, xor_output=0x000)*

### amaranth.lib.crc.catalog.CRC14_DARC *= Algorithm(crc_width=14, polynomial=0x805, initial_crc=0x000, reflect_input=True, reflect_output=True, xor_output=0x000)*

### amaranth.lib.crc.catalog.CRC14_GSM *= Algorithm(crc_width=14, polynomial=0x202d, initial_crc=0x000, reflect_input=False, reflect_output=False, xor_output=0x3fff)*

### amaranth.lib.crc.catalog.CRC15_CAN *= Algorithm(crc_width=15, polynomial=0x4599, initial_crc=0x000, reflect_input=False, reflect_output=False, xor_output=0x000)*

### amaranth.lib.crc.catalog.CRC15_MPT1327 *= Algorithm(crc_width=15, polynomial=0x6815, initial_crc=0x000, reflect_input=False, reflect_output=False, xor_output=0x001)*

### amaranth.lib.crc.catalog.CRC16_ARC *= Algorithm(crc_width=16, polynomial=0x8005, initial_crc=0x0000, reflect_input=True, reflect_output=True, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_IBM *= Algorithm(crc_width=16, polynomial=0x8005, initial_crc=0x0000, reflect_input=True, reflect_output=True, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_CDMA2000 *= Algorithm(crc_width=16, polynomial=0xc867, initial_crc=0xffff, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_CMS *= Algorithm(crc_width=16, polynomial=0x8005, initial_crc=0xffff, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_DDS_110 *= Algorithm(crc_width=16, polynomial=0x8005, initial_crc=0x800d, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_DECT_R *= Algorithm(crc_width=16, polynomial=0x0589, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0001)*

### amaranth.lib.crc.catalog.CRC16_DECT_X *= Algorithm(crc_width=16, polynomial=0x0589, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_DNP *= Algorithm(crc_width=16, polynomial=0x3d65, initial_crc=0x0000, reflect_input=True, reflect_output=True, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_EN_13757 *= Algorithm(crc_width=16, polynomial=0x3d65, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_GENIBUS *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xffff, reflect_input=False, reflect_output=False, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_DARC *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xffff, reflect_input=False, reflect_output=False, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_EPC *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xffff, reflect_input=False, reflect_output=False, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_EPC_C1G2 *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xffff, reflect_input=False, reflect_output=False, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_I_CODE *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xffff, reflect_input=False, reflect_output=False, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_GSM *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_IBM_3740 *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xffff, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_AUTOSAR *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xffff, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_CCITT_FALSE *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xffff, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_IBM_SDLC *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xffff, reflect_input=True, reflect_output=True, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_ISO_HDLC *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xffff, reflect_input=True, reflect_output=True, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_ISO_IEC_14443_3_B *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xffff, reflect_input=True, reflect_output=True, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_X25 *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xffff, reflect_input=True, reflect_output=True, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_ISO_IEC_14443_3_A *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xc6c6, reflect_input=True, reflect_output=True, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_KERMIT *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0x0000, reflect_input=True, reflect_output=True, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_BLUETOOTH *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0x0000, reflect_input=True, reflect_output=True, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_CCITT *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0x0000, reflect_input=True, reflect_output=True, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_CCITT_TRUE *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0x0000, reflect_input=True, reflect_output=True, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_V_41_LSB *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0x0000, reflect_input=True, reflect_output=True, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_LJ1200 *= Algorithm(crc_width=16, polynomial=0x6f63, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_M17 *= Algorithm(crc_width=16, polynomial=0x5935, initial_crc=0xffff, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_MAXIM_DOW *= Algorithm(crc_width=16, polynomial=0x8005, initial_crc=0x0000, reflect_input=True, reflect_output=True, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_MAXIM *= Algorithm(crc_width=16, polynomial=0x8005, initial_crc=0x0000, reflect_input=True, reflect_output=True, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_MCRF4XX *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xffff, reflect_input=True, reflect_output=True, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_MODBUS *= Algorithm(crc_width=16, polynomial=0x8005, initial_crc=0xffff, reflect_input=True, reflect_output=True, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_NRSC_5 *= Algorithm(crc_width=16, polynomial=0x080b, initial_crc=0xffff, reflect_input=True, reflect_output=True, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_OPENSAFETY_A *= Algorithm(crc_width=16, polynomial=0x5935, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_OPENSAFETY_B *= Algorithm(crc_width=16, polynomial=0x755b, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_PROFIBUS *= Algorithm(crc_width=16, polynomial=0x1dcf, initial_crc=0xffff, reflect_input=False, reflect_output=False, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_IEC_61158_2 *= Algorithm(crc_width=16, polynomial=0x1dcf, initial_crc=0xffff, reflect_input=False, reflect_output=False, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_RIELLO *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xb2aa, reflect_input=True, reflect_output=True, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_SPI_FUJITSU *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0x1d0f, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_AUG_CCITT *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0x1d0f, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_T10_DIF *= Algorithm(crc_width=16, polynomial=0x8bb7, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_TELEDISK *= Algorithm(crc_width=16, polynomial=0xa097, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_TMS37157 *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0x89ec, reflect_input=True, reflect_output=True, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_UMTS *= Algorithm(crc_width=16, polynomial=0x8005, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_BUYPASS *= Algorithm(crc_width=16, polynomial=0x8005, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_VERIFONE *= Algorithm(crc_width=16, polynomial=0x8005, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_USB *= Algorithm(crc_width=16, polynomial=0x8005, initial_crc=0xffff, reflect_input=True, reflect_output=True, xor_output=0xffff)*

### amaranth.lib.crc.catalog.CRC16_XMODEM *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_ACORN *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_LTE *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_V_41_MSB *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC16_ZMODEM *= Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC17_CAN_FD *= Algorithm(crc_width=17, polynomial=0x1685b, initial_crc=0x0000, reflect_input=False, reflect_output=False, xor_output=0x0000)*

### amaranth.lib.crc.catalog.CRC21_CAN_FD *= Algorithm(crc_width=21, polynomial=0x102899, initial_crc=0x00000, reflect_input=False, reflect_output=False, xor_output=0x00000)*

### amaranth.lib.crc.catalog.CRC24_BLE *= Algorithm(crc_width=24, polynomial=0x00065b, initial_crc=0x555555, reflect_input=True, reflect_output=True, xor_output=0x000000)*

### amaranth.lib.crc.catalog.CRC24_FLEXRAY_A *= Algorithm(crc_width=24, polynomial=0x5d6dcb, initial_crc=0xfedcba, reflect_input=False, reflect_output=False, xor_output=0x000000)*

### amaranth.lib.crc.catalog.CRC24_FLEXRAY_B *= Algorithm(crc_width=24, polynomial=0x5d6dcb, initial_crc=0xabcdef, reflect_input=False, reflect_output=False, xor_output=0x000000)*

### amaranth.lib.crc.catalog.CRC24_INTERLAKEN *= Algorithm(crc_width=24, polynomial=0x328b63, initial_crc=0xffffff, reflect_input=False, reflect_output=False, xor_output=0xffffff)*

### amaranth.lib.crc.catalog.CRC24_LTE_A *= Algorithm(crc_width=24, polynomial=0x864cfb, initial_crc=0x000000, reflect_input=False, reflect_output=False, xor_output=0x000000)*

### amaranth.lib.crc.catalog.CRC24_LTE_B *= Algorithm(crc_width=24, polynomial=0x800063, initial_crc=0x000000, reflect_input=False, reflect_output=False, xor_output=0x000000)*

### amaranth.lib.crc.catalog.CRC24_OPENPGP *= Algorithm(crc_width=24, polynomial=0x864cfb, initial_crc=0xb704ce, reflect_input=False, reflect_output=False, xor_output=0x000000)*

### amaranth.lib.crc.catalog.CRC24_OS_9 *= Algorithm(crc_width=24, polynomial=0x800063, initial_crc=0xffffff, reflect_input=False, reflect_output=False, xor_output=0xffffff)*

### amaranth.lib.crc.catalog.CRC30_CDMA *= Algorithm(crc_width=30, polynomial=0x2030b9c7, initial_crc=0x3fffffff, reflect_input=False, reflect_output=False, xor_output=0x3fffffff)*

### amaranth.lib.crc.catalog.CRC31_PHILIPS *= Algorithm(crc_width=31, polynomial=0x4c11db7, initial_crc=0x7fffffff, reflect_input=False, reflect_output=False, xor_output=0x7fffffff)*

### amaranth.lib.crc.catalog.CRC32_AIXM *= Algorithm(crc_width=32, polynomial=0x814141ab, initial_crc=0x00000000, reflect_input=False, reflect_output=False, xor_output=0x00000000)*

### amaranth.lib.crc.catalog.CRC32_AUTOSAR *= Algorithm(crc_width=32, polynomial=0xf4acfb13, initial_crc=0xffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_BASE91_D *= Algorithm(crc_width=32, polynomial=0xa833982b, initial_crc=0xffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_BZIP2 *= Algorithm(crc_width=32, polynomial=0x04c11db7, initial_crc=0xffffffff, reflect_input=False, reflect_output=False, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_AAL5 *= Algorithm(crc_width=32, polynomial=0x04c11db7, initial_crc=0xffffffff, reflect_input=False, reflect_output=False, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_DECT_B *= Algorithm(crc_width=32, polynomial=0x04c11db7, initial_crc=0xffffffff, reflect_input=False, reflect_output=False, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_CD_ROM_EDC *= Algorithm(crc_width=32, polynomial=0x8001801b, initial_crc=0x00000000, reflect_input=True, reflect_output=True, xor_output=0x00000000)*

### amaranth.lib.crc.catalog.CRC32_CKSUM *= Algorithm(crc_width=32, polynomial=0x04c11db7, initial_crc=0x00000000, reflect_input=False, reflect_output=False, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_POSIX *= Algorithm(crc_width=32, polynomial=0x04c11db7, initial_crc=0x00000000, reflect_input=False, reflect_output=False, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_ISCSI *= Algorithm(crc_width=32, polynomial=0x1edc6f41, initial_crc=0xffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_BASE91_C *= Algorithm(crc_width=32, polynomial=0x1edc6f41, initial_crc=0xffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_CASTAGNOLI *= Algorithm(crc_width=32, polynomial=0x1edc6f41, initial_crc=0xffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_INTERLAKEN *= Algorithm(crc_width=32, polynomial=0x1edc6f41, initial_crc=0xffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_ISO_HDLC *= Algorithm(crc_width=32, polynomial=0x04c11db7, initial_crc=0xffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_ADCCP *= Algorithm(crc_width=32, polynomial=0x04c11db7, initial_crc=0xffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_V_42 *= Algorithm(crc_width=32, polynomial=0x04c11db7, initial_crc=0xffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_XZ *= Algorithm(crc_width=32, polynomial=0x04c11db7, initial_crc=0xffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_PKZIP *= Algorithm(crc_width=32, polynomial=0x04c11db7, initial_crc=0xffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_ETHERNET *= Algorithm(crc_width=32, polynomial=0x04c11db7, initial_crc=0xffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffff)*

### amaranth.lib.crc.catalog.CRC32_JAMCRC *= Algorithm(crc_width=32, polynomial=0x04c11db7, initial_crc=0xffffffff, reflect_input=True, reflect_output=True, xor_output=0x00000000)*

### amaranth.lib.crc.catalog.CRC32_MEF *= Algorithm(crc_width=32, polynomial=0x741b8cd7, initial_crc=0xffffffff, reflect_input=True, reflect_output=True, xor_output=0x00000000)*

### amaranth.lib.crc.catalog.CRC32_MPEG_2 *= Algorithm(crc_width=32, polynomial=0x04c11db7, initial_crc=0xffffffff, reflect_input=False, reflect_output=False, xor_output=0x00000000)*

### amaranth.lib.crc.catalog.CRC32_XFER *= Algorithm(crc_width=32, polynomial=0x000000af, initial_crc=0x00000000, reflect_input=False, reflect_output=False, xor_output=0x00000000)*

### amaranth.lib.crc.catalog.CRC40_GSM *= Algorithm(crc_width=40, polynomial=0x0004820009, initial_crc=0x0000000000, reflect_input=False, reflect_output=False, xor_output=0xffffffffff)*

### amaranth.lib.crc.catalog.CRC64_ECMA_182 *= Algorithm(crc_width=64, polynomial=0x42f0e1eba9ea3693, initial_crc=0x0000000000000000, reflect_input=False, reflect_output=False, xor_output=0x0000000000000000)*

### amaranth.lib.crc.catalog.CRC64_GO_ISO *= Algorithm(crc_width=64, polynomial=0x000000000000001b, initial_crc=0xffffffffffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffffffffffff)*

### amaranth.lib.crc.catalog.CRC64_MS *= Algorithm(crc_width=64, polynomial=0x259c84cba6426349, initial_crc=0xffffffffffffffff, reflect_input=True, reflect_output=True, xor_output=0x0000000000000000)*

### amaranth.lib.crc.catalog.CRC64_REDIS *= Algorithm(crc_width=64, polynomial=0xad93d23594c935a9, initial_crc=0x0000000000000000, reflect_input=True, reflect_output=True, xor_output=0x0000000000000000)*

### amaranth.lib.crc.catalog.CRC64_WE *= Algorithm(crc_width=64, polynomial=0x42f0e1eba9ea3693, initial_crc=0xffffffffffffffff, reflect_input=False, reflect_output=False, xor_output=0xffffffffffffffff)*

### amaranth.lib.crc.catalog.CRC64_XZ *= Algorithm(crc_width=64, polynomial=0x42f0e1eba9ea3693, initial_crc=0xffffffffffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffffffffffff)*

### amaranth.lib.crc.catalog.CRC64_ECMA *= Algorithm(crc_width=64, polynomial=0x42f0e1eba9ea3693, initial_crc=0xffffffffffffffff, reflect_input=True, reflect_output=True, xor_output=0xffffffffffffffff)*

### amaranth.lib.crc.catalog.CRC82_DARC *= Algorithm(crc_width=82, polynomial=0x308c0111011401440411, initial_crc=0x00000000000000000000, reflect_input=True, reflect_output=True, xor_output=0x00000000000000000000)*


# cdc.html.md

# Clock domain crossing

The [`amaranth.lib.cdc`](#module-amaranth.lib.cdc) module provides building blocks for transferring data between clock domains.

### *class* amaranth.lib.cdc.FFSynchronizer

Resynchronise a signal to a different clock domain.

Consists of a chain of flip-flops. Eliminates metastabilities at the output, but provides
no other guarantee as to the safe domain-crossing of a signal.

* **Parameters:**
  * **i** (*Signal* *(**n* *)* *,* *in*) – Signal to be resynchronised.
  * **o** (*Signal* *(**n* *)* *,* *out*) – Signal connected to synchroniser output.
  * **o_domain** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – Name of output clock domain.
  * **init** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Initial and reset value of the flip-flops. On FPGAs, even if `reset_less` is `True`,
    the [`FFSynchronizer`](#amaranth.lib.cdc.FFSynchronizer) is still set to this value during initialization.
  * **reset_less** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – If `True` (the default), this [`FFSynchronizer`](#amaranth.lib.cdc.FFSynchronizer) is unaffected by `o_domain`
    reset. See the note below for details.
  * **stages** ([*int*](https://docs.python.org/3/library/functions.html#int) *,*  *>=2*) – Number of synchronization stages between input and output. The lowest safe number is 2,
    with higher numbers reducing MTBF further, at the cost of increased latency.
  * **max_input_delay** (*None* *or* [*float*](https://docs.python.org/3/library/functions.html#float)) – Maximum delay from the input signal’s clock to the first synchronization stage, in seconds.
    If specified and the platform does not support it, elaboration will fail.

#### NOTE
[`FFSynchronizer`](#amaranth.lib.cdc.FFSynchronizer) is non-resettable by default. Usually this is the safest option;
on FPGAs the [`FFSynchronizer`](#amaranth.lib.cdc.FFSynchronizer) will still be initialized to its `reset` value when
the FPGA loads its configuration.

However, in designs where the value of the [`FFSynchronizer`](#amaranth.lib.cdc.FFSynchronizer) must be valid immediately
after reset, consider setting `reset_less` to `False` if any of the following is true:

- You are targeting an ASIC, or an FPGA that does not allow arbitrary initial flip-flop states;
- Your design features warm (non-power-on) resets of `o_domain`, so the one-time
  initialization at power on is insufficient;
- Your design features a sequenced reset, and the [`FFSynchronizer`](#amaranth.lib.cdc.FFSynchronizer) must maintain
  its reset value until `o_domain` reset specifically is deasserted.

[`FFSynchronizer`](#amaranth.lib.cdc.FFSynchronizer) is reset by the `o_domain` reset only.

### Platform overrides

Define the `get_ff_sync` platform method to override the implementation of
[`FFSynchronizer`](#amaranth.lib.cdc.FFSynchronizer), e.g. to instantiate library cells directly.

### *class* amaranth.lib.cdc.AsyncFFSynchronizer

Synchronize deassertion of an asynchronous signal.

The signal driven by the [`AsyncFFSynchronizer`](#amaranth.lib.cdc.AsyncFFSynchronizer) is asserted asynchronously and deasserted
synchronously, eliminating metastability during deassertion.

This synchronizer is primarily useful for resets and reset-like signals.

* **Parameters:**
  * **i** (*Signal* *(**1* *)* *,* *in*) – Asynchronous input signal, to be synchronized.
  * **o** (*Signal* *(**1* *)* *,* *out*) – Synchronously released output signal.
  * **o_domain** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – Name of clock domain to synchronize to.
  * **stages** ([*int*](https://docs.python.org/3/library/functions.html#int) *,*  *>=2*) – Number of synchronization stages between input and output. The lowest safe number is 2,
    with higher numbers reducing MTBF further, at the cost of increased deassertion latency.
  * **async_edge** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – The edge of the input signal which causes the output to be set. Must be one of “pos” or “neg”.
  * **max_input_delay** (*None* *or* [*float*](https://docs.python.org/3/library/functions.html#float)) – Maximum delay from the input signal’s clock to the first synchronization stage, in seconds.
    If specified and the platform does not support it, elaboration will fail.

### Platform overrides

Define the `get_async_ff_sync` platform method to override the implementation of
[`AsyncFFSynchronizer`](#amaranth.lib.cdc.AsyncFFSynchronizer), e.g. to instantiate library cells directly.

### *class* amaranth.lib.cdc.ResetSynchronizer

Synchronize deassertion of a clock domain reset.

The reset of the clock domain driven by the [`ResetSynchronizer`](#amaranth.lib.cdc.ResetSynchronizer) is asserted
asynchronously and deasserted synchronously, eliminating metastability during deassertion.

The driven clock domain could use a reset that is asserted either synchronously or
asynchronously; a reset is always deasserted synchronously. A domain with an asynchronously
asserted reset is useful if the clock of the domain may be gated, yet the domain still
needs to be reset promptly; otherwise, synchronously asserted reset (the default) should
be used.

* **Parameters:**
  * **arst** (*Signal* *(**1* *)* *,* *in*) – Asynchronous reset signal, to be synchronized.
  * **domain** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – Name of clock domain to reset.
  * **stages** ([*int*](https://docs.python.org/3/library/functions.html#int) *,*  *>=2*) – Number of synchronization stages between input and output. The lowest safe number is 2,
    with higher numbers reducing MTBF further, at the cost of increased deassertion latency.
  * **max_input_delay** (*None* *or* [*float*](https://docs.python.org/3/library/functions.html#float)) – Maximum delay from the input signal’s clock to the first synchronization stage, in seconds.
    If specified and the platform does not support it, elaboration will fail.

### Platform overrides

Define the `get_reset_sync` platform method to override the implementation of
[`ResetSynchronizer`](#amaranth.lib.cdc.ResetSynchronizer), e.g. to instantiate library cells directly.

### *class* amaranth.lib.cdc.PulseSynchronizer

A one-clock pulse on the input produces a one-clock pulse on the output.

If the output clock is faster than the input clock, then the input may be safely asserted at
100% duty cycle. Otherwise, if the clock ratio is `n`:1, the input may be asserted at most
once in every `n` input clocks, else pulses may be dropped. Other than this there is
no constraint on the ratio of input and output clock frequency.

* **Parameters:**
  * **i_domain** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – Name of input clock domain.
  * **o_domain** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – Name of output clock domain.
  * **stages** ([*int*](https://docs.python.org/3/library/functions.html#int) *,*  *>=2*) – Number of synchronization stages between input and output. The lowest safe number is 2,
    with higher numbers reducing MTBF further, at the cost of increased deassertion latency.


# changes.html.md

# Changelog

This document describes changes to the public interfaces in the Amaranth language and standard library. It does not include most bug fixes or implementation changes; versions which do not include notable changes are not listed here.

## Documentation for past releases

Documentation for past releases of the Amaranth language and toolchain is available online:

* [Amaranth 0.5.4](https://amaranth-lang.org/docs/amaranth/v0.5.3/)
* [Amaranth 0.5.3](https://amaranth-lang.org/docs/amaranth/v0.5.3/)
* [Amaranth 0.5.2](https://amaranth-lang.org/docs/amaranth/v0.5.2/)
* [Amaranth 0.5.1](https://amaranth-lang.org/docs/amaranth/v0.5.1/)
* [Amaranth 0.5.0](https://amaranth-lang.org/docs/amaranth/v0.5.0/)
* [Amaranth 0.4.5](https://amaranth-lang.org/docs/amaranth/v0.4.5/)
* [Amaranth 0.4.4](https://amaranth-lang.org/docs/amaranth/v0.4.4/)
* [Amaranth 0.4.3](https://amaranth-lang.org/docs/amaranth/v0.4.3/)
* [Amaranth 0.4.2](https://amaranth-lang.org/docs/amaranth/v0.4.2/)
* [Amaranth 0.4.1](https://amaranth-lang.org/docs/amaranth/v0.4.1/)
* [Amaranth 0.4.0](https://amaranth-lang.org/docs/amaranth/v0.4.0/)
* [Amaranth 0.3](https://amaranth-lang.org/docs/amaranth/v0.3/)

## Version 0.5.4

Updated to address deprecations in Yosys 0.48.

## Version 0.5.3

### Language changes

* Added: individual bits of the same signal can now be assigned from different modules or domains.

### Toolchain changes

* Added: the Amaranth RPC server can now elaborate [`amaranth.lib.wiring.Component`](stdlib/wiring.md#amaranth.lib.wiring.Component) objects on demand.

## Version 0.5.2

### Standard library changes

* Added: constants of [`amaranth.lib.data.ArrayLayout`](stdlib/data.md#amaranth.lib.data.ArrayLayout) can be indexed with negative integers or slices.
* Added: `len()` works on constants of [`amaranth.lib.data.ArrayLayout`](stdlib/data.md#amaranth.lib.data.ArrayLayout).
* Added: constants of [`amaranth.lib.data.ArrayLayout`](stdlib/data.md#amaranth.lib.data.ArrayLayout) are iterable.

### Platform integration changes

* Added: `Platform.request()` accepts `dir="-"` for resources with subsignals.

## Version 0.5.1

### Implemented RFCs

* [RFC 69](https://amaranth-lang.org/rfcs/0069-simulation-port.html): Add a `lib.io.PortLike` object usable in simulation

### Standard library changes

* Added: views of [`amaranth.lib.data.ArrayLayout`](stdlib/data.md#amaranth.lib.data.ArrayLayout) can be indexed with negative integers or slices.
* Added: `len()` works on views of [`amaranth.lib.data.ArrayLayout`](stdlib/data.md#amaranth.lib.data.ArrayLayout).
* Added: views of [`amaranth.lib.data.ArrayLayout`](stdlib/data.md#amaranth.lib.data.ArrayLayout) are iterable.
* Added: [`io.SimulationPort`](stdlib/io.md#amaranth.lib.io.SimulationPort). ([RFC 69](https://amaranth-lang.org/rfcs/0069-simulation-port.html))

## Version 0.5.0

The Migen compatibility layer has been removed.

### Migrating from version 0.4

Apply the following changes to code written against Amaranth 0.4 to migrate it to version 0.5:

* Update uses of `reset=` keyword argument to `init=`.
* Ensure all elaboratables are subclasses of `Elaboratable`.
* Replace uses of `m.Case()` with no patterns with `m.Default()`.
* Replace uses of `Value.matches()` with no patterns with `Const(1)`.
* Ensure clock domains aren’t used outside the module that defines them, or its submodules; move clock domain definitions upwards in the hierarchy as necessary
* Replace imports of `amaranth.asserts.Assert`, `Assume`, and `Cover` with imports from `amaranth.hdl`.
* Remove uses of `name=` keyword argument of `Assert`, `Assume`, and `Cover`; a message can be used instead.
* Replace uses of `amaranth.hdl.Memory` with [`amaranth.lib.memory.Memory`](stdlib/memory.md#amaranth.lib.memory.Memory).
* Update uses of `platform.request` to pass `dir="-"` and use [`amaranth.lib.io`](stdlib/io.md#module-amaranth.lib.io) buffers.
* Remove uses of `amaranth.lib.coding.*` by inlining or copying the implementation of the modules.
* Convert uses of `Simulator.add_sync_process` used as testbenches to [`Simulator.add_testbench`](simulator.md#amaranth.sim.Simulator.add_testbench).
* Convert other uses of `Simulator.add_sync_process` to [`Simulator.add_process`](simulator.md#amaranth.sim.Simulator.add_process).
* Convert simulator processes and testbenches to use the new async API.
* Update uses of [`Simulator.add_clock`](simulator.md#amaranth.sim.Simulator.add_clock) with explicit `phase` to take into account simulator no longer adding implicit `period / 2`. (Previously, [`Simulator.add_clock`](simulator.md#amaranth.sim.Simulator.add_clock) was documented to first toggle the clock at the time `phase`, but actually first toggled the clock at `period / 2 + phase`.)
* Update uses of [`Simulator.run_until`](simulator.md#amaranth.sim.Simulator.run_until) to remove the `run_passive=True` argument. If the code uses `run_passive=False`, ensure it still works with the new behavior.
* Update uses of `amaranth.utils.log2_int(need_pow2=False)` to `amaranth.utils.ceil_log2()`.
* Update uses of `amaranth.utils.log2_int(need_pow2=True)` to `amaranth.utils.exact_log2()`.
* Replace uses of `a.implies(b)` with ~a | b.

### Implemented RFCs

* [RFC 17](https://amaranth-lang.org/rfcs/0017-remove-log2-int.html): Remove `log2_int`
* [RFC 27](https://amaranth-lang.org/rfcs/0027-simulator-testbenches.html): Testbench processes for the simulator
* [RFC 30](https://amaranth-lang.org/rfcs/0030-component-metadata.html): Component metadata
* [RFC 36](https://amaranth-lang.org/rfcs/0036-async-testbench-functions.html): Async testbench functions
* [RFC 39](https://amaranth-lang.org/rfcs/0039-empty-case.html): Change semantics of no-argument `m.Case()`
* [RFC 42](https://amaranth-lang.org/rfcs/0042-const-from-shape-castable.html): `Const` from shape-castable
* [RFC 43](https://amaranth-lang.org/rfcs/0043-rename-reset-to-init.html): Rename `reset=` to `init=`
* [RFC 45](https://amaranth-lang.org/rfcs/0045-lib-memory.html): Move `hdl.Memory` to `lib.Memory`
* [RFC 46](https://amaranth-lang.org/rfcs/0046-shape-range-1.html): Change `Shape.cast(range(1))` to `unsigned(0)`
* [RFC 50](https://amaranth-lang.org/rfcs/0050-print.html): `Print` statement and string formatting
* [RFC 51](https://amaranth-lang.org/rfcs/0051-const-from-bits.html): Add `ShapeCastable.from_bits` and `amaranth.lib.data.Const`
* [RFC 53](https://amaranth-lang.org/rfcs/0053-ioport.html): Low-level I/O primitives
* [RFC 55](https://amaranth-lang.org/rfcs/0055-lib-io.html): New `lib.io` components
* [RFC 58](https://amaranth-lang.org/rfcs/0058-valuecastable-format.html): Core support for `ValueCastable` formatting
* [RFC 59](https://amaranth-lang.org/rfcs/0059-no-domain-upwards-propagation.html): Get rid of upwards propagation of clock domains
* [RFC 61](https://amaranth-lang.org/rfcs/0061-minimal-streams.html): Minimal streams
* [RFC 62](https://amaranth-lang.org/rfcs/0062-memory-data.html): The `MemoryData` class
* [RFC 63](https://amaranth-lang.org/rfcs/0063-remove-lib-coding.html): Remove `amaranth.lib.coding`
* [RFC 65](https://amaranth-lang.org/rfcs/0065-format-struct-enum.html): Special formatting for structures and enums

### Language changes

* Added: `Slice` objects have been made const-castable.
* Added: `amaranth.utils.ceil_log2()`, `amaranth.utils.exact_log2()`. ([RFC 17](https://amaranth-lang.org/rfcs/0017-remove-log2-int.html))
* Added: `Format` objects, `Print` statements, messages in `Assert`, `Assume` and `Cover`. ([RFC 50](https://amaranth-lang.org/rfcs/0050-print.html))
* Added: [`ShapeCastable.from_bits()`](reference.md#amaranth.hdl.ShapeCastable.from_bits) method. ([RFC 51](https://amaranth-lang.org/rfcs/0051-const-from-bits.html))
* Added: IO values, `IOPort` objects, `IOBufferInstance` objects. ([RFC 53](https://amaranth-lang.org/rfcs/0053-ioport.html))
* Added: [`MemoryData`](stdlib/memory.md#amaranth.hdl.MemoryData) objects. ([RFC 62](https://amaranth-lang.org/rfcs/0062-memory-data.html))
* Changed: `m.Case()` with no patterns is never active instead of always active. ([RFC 39](https://amaranth-lang.org/rfcs/0039-empty-case.html))
* Changed: `Value.matches()` with no patterns is `Const(0)` instead of `Const(1)`. ([RFC 39](https://amaranth-lang.org/rfcs/0039-empty-case.html))
* Changed: `Signal(range(stop), init=stop)` warning has been changed into a hard error and made to trigger on any out-of range value.
* Changed: `Signal(range(0))` is now valid without a warning.
* Changed: `Const(value, shape)` now accepts shape-castable objects as `shape`. ([RFC 42](https://amaranth-lang.org/rfcs/0042-const-from-shape-castable.html))
* Changed: `Shape.cast(range(1))` is now `unsigned(0)`. ([RFC 46](https://amaranth-lang.org/rfcs/0046-shape-range-1.html))
* Changed: the `reset=` argument of `Signal`, `Signal.like()`, [`amaranth.lib.wiring.Member`](stdlib/wiring.md#amaranth.lib.wiring.Member), [`amaranth.lib.cdc.FFSynchronizer`](stdlib/cdc.md#amaranth.lib.cdc.FFSynchronizer), and `m.FSM()` has been renamed to `init=`. ([RFC 43](https://amaranth-lang.org/rfcs/0043-rename-reset-to-init.html))
* Changed: [`Shape`](reference.md#amaranth.hdl.Shape) has been made immutable and hashable.
* Changed: `Assert`, `Assume`, `Cover` have been moved to [`amaranth.hdl`](reference.md#module-amaranth.hdl) from `amaranth.asserts`. ([RFC 50](https://amaranth-lang.org/rfcs/0050-print.html))
* Changed: `Instance` IO ports now accept only IO values, not plain values. ([RFC 53](https://amaranth-lang.org/rfcs/0053-ioport.html))
* Deprecated: `amaranth.utils.log2_int()`. ([RFC 17](https://amaranth-lang.org/rfcs/0017-remove-log2-int.html))
* Deprecated: `amaranth.hdl.Memory`. ([RFC 45](https://amaranth-lang.org/rfcs/0045-lib-memory.html))
* Deprecated: upwards propagation of clock domains. ([RFC 59](https://amaranth-lang.org/rfcs/0059-no-domain-upwards-propagation.html))
* Deprecated: `Value.implies()`.
* Removed: (deprecated in 0.4.0) `Const.normalize()`. ([RFC 5](https://amaranth-lang.org/rfcs/0005-remove-const-normalize.html))
* Removed: (deprecated in 0.4.0) `Repl`. ([RFC 10](https://amaranth-lang.org/rfcs/0010-move-repl-to-value.html))
* Removed: (deprecated in 0.4.0) `ast.Sample`, `ast.Past`, `ast.Stable`, `ast.Rose`, `ast.Fell`.
* Removed: assertion names in `Assert`, `Assume` and `Cover`. ([RFC 50](https://amaranth-lang.org/rfcs/0050-print.html))
* Removed: accepting non-subclasses of `Elaboratable` as elaboratables.

### Standard library changes

* Added: [`amaranth.lib.memory`](stdlib/memory.md#module-amaranth.lib.memory). ([RFC 45](https://amaranth-lang.org/rfcs/0045-lib-memory.html))
* Added: [`amaranth.lib.data.Const`](stdlib/data.md#amaranth.lib.data.Const) class. ([RFC 51](https://amaranth-lang.org/rfcs/0051-const-from-bits.html))
* Changed: [`amaranth.lib.data.Layout.const()`](stdlib/data.md#amaranth.lib.data.Layout.const) returns a [`amaranth.lib.data.Const`](stdlib/data.md#amaranth.lib.data.Const), not a view ([RFC 51](https://amaranth-lang.org/rfcs/0051-const-from-bits.html))
* Changed: [`amaranth.lib.wiring.Signature.is_compliant()`](stdlib/wiring.md#amaranth.lib.wiring.Signature.is_compliant) no longer rejects reset-less signals.
* Added: [`amaranth.lib.io.SingleEndedPort`](stdlib/io.md#amaranth.lib.io.SingleEndedPort), [`amaranth.lib.io.DifferentialPort`](stdlib/io.md#amaranth.lib.io.DifferentialPort). ([RFC 55](https://amaranth-lang.org/rfcs/0055-lib-io.html))
* Added: [`amaranth.lib.io.Buffer`](stdlib/io.md#amaranth.lib.io.Buffer), [`amaranth.lib.io.FFBuffer`](stdlib/io.md#amaranth.lib.io.FFBuffer), [`amaranth.lib.io.DDRBuffer`](stdlib/io.md#amaranth.lib.io.DDRBuffer). ([RFC 55](https://amaranth-lang.org/rfcs/0055-lib-io.html))
* Added: [`amaranth.lib.meta`](stdlib/meta.md#module-amaranth.lib.meta), [`amaranth.lib.wiring.ComponentMetadata`](stdlib/wiring.md#amaranth.lib.wiring.ComponentMetadata). ([RFC 30](https://amaranth-lang.org/rfcs/0030-component-metadata.html))
* Added: [`amaranth.lib.stream`](stdlib/stream.md#module-amaranth.lib.stream). ([RFC 61](https://amaranth-lang.org/rfcs/0061-minimal-streams.html))
* Deprecated: [`amaranth.lib.coding`](stdlib/coding.md#module-amaranth.lib.coding). ([RFC 63](https://amaranth-lang.org/rfcs/0063-remove-lib-coding.html))
* Removed: (deprecated in 0.4.0) `amaranth.lib.scheduler`. ([RFC 19](https://amaranth-lang.org/rfcs/0019-remove-scheduler.html))
* Removed: (deprecated in 0.4.0) [`amaranth.lib.fifo.FIFOInterface`](stdlib/fifo.md#amaranth.lib.fifo.FIFOInterface) with `fwft=False`. ([RFC 20](https://amaranth-lang.org/rfcs/0020-deprecate-non-fwft-fifos.html))
* Removed: (deprecated in 0.4.0) [`amaranth.lib.fifo.SyncFIFO`](stdlib/fifo.md#amaranth.lib.fifo.SyncFIFO) with `fwft=False`. ([RFC 20](https://amaranth-lang.org/rfcs/0020-deprecate-non-fwft-fifos.html))

### Toolchain changes

* Added: [`Simulator.add_testbench`](simulator.md#amaranth.sim.Simulator.add_testbench). ([RFC 27](https://amaranth-lang.org/rfcs/0027-simulator-testbenches.html))
* Added: async function support in [`Simulator.add_testbench`](simulator.md#amaranth.sim.Simulator.add_testbench) and [`Simulator.add_process`](simulator.md#amaranth.sim.Simulator.add_process). ([RFC 36](https://amaranth-lang.org/rfcs/0036-async-testbench-functions.html))
* Added: support for `amaranth.hdl.Assert` in simulation. ([RFC 50](https://amaranth-lang.org/rfcs/0050-print.html))
* Changed: [`Simulator.add_clock`](simulator.md#amaranth.sim.Simulator.add_clock) no longer implicitly adds `period / 2` when `phase` is specified, actually matching the documentation.
* Changed: [`Simulator.run_until`](simulator.md#amaranth.sim.Simulator.run_until) always runs the simulation until the given deadline, even when no critical processes or testbenches are present.
* Deprecated: `Settle` simulation command. ([RFC 27](https://amaranth-lang.org/rfcs/0027-simulator-testbenches.html))
* Deprecated: `Simulator.add_sync_process`. ([RFC 27](https://amaranth-lang.org/rfcs/0027-simulator-testbenches.html))
* Deprecated: generator-based simulation processes and testbenches. ([RFC 36](https://amaranth-lang.org/rfcs/0036-async-testbench-functions.html))
* Deprecated: the `run_passive` argument to [`Simulator.run_until`](simulator.md#amaranth.sim.Simulator.run_until) has been deprecated, and does nothing.
* Removed: (deprecated in 0.4.0) use of mixed-case toolchain environment variable names, such as `NMIGEN_ENV_Diamond` or `AMARANTH_ENV_Diamond`; use upper-case environment variable names, such as `AMARANTH_ENV_DIAMOND`.

### Platform integration changes

* Added: `BuildPlan.execute_local_docker()`.
* Added: `BuildPlan.extract()`.
* Added: `build.sh`  begins with `#!/bin/sh`.
* Changed: `IntelPlatform` renamed to `AlteraPlatform`.
* Deprecated: argument `run_script=` in `BuildPlan.execute_local()`.
* Removed: (deprecated in 0.4.0) `vendor.intel`, `vendor.lattice_ecp5`, `vendor.lattice_ice40`, `vendor.lattice_machxo2_3l`, `vendor.quicklogic`, `vendor.xilinx`. ([RFC 18](https://amaranth-lang.org/rfcs/0018-reorganize-vendor-platforms.html))

## Version 0.4.0

Support has been added for a new and improved way of defining data structures in [`amaranth.lib.data`](stdlib/data.md#module-amaranth.lib.data) and component interfaces in [`amaranth.lib.wiring`](stdlib/wiring.md#module-amaranth.lib.wiring), as defined in [RFC 1](https://amaranth-lang.org/rfcs/0001-aggregate-data-structures.html) and [RFC 2](https://amaranth-lang.org/rfcs/0002-interfaces.html). `Record` has been deprecated. In a departure from the usual policy, to give designers additional time to migrate, `Record` will be removed in Amaranth 0.6 (one release later than normal).

Support for enumerations has been extended. A shape for enumeration members can be provided for an enumeration class, as defined in [RFC 3](https://amaranth-lang.org/rfcs/0003-enumeration-shapes.html).

The language includes several new extension points for integration with `Value` based data structures defined outside of the core language. In particular, `Signal(shape)` may now return a `Signal` object wrapped in another if `shape` implements the call protocol, as defined in [RFC 15](https://amaranth-lang.org/rfcs/0015-lifting-shape-castables.html).

Several issues with shape inference have been resolved. Notably, `a - b` where both `a` and `b` are unsigned now returns a signed value.

Support for Python 3.6 and 3.7 has been removed, and support for Python 3.11 and 3.12 has been added.

Features deprecated in version 0.3 have been removed. In particular, the `nmigen.*` namespace is not provided, `# nmigen:` annotations are not recognized, and `NMIGEN_*` envronment variables are not used.

The Migen compatibility layer remains deprecated (as it had been since Amaranth 0.1), and is now scheduled to be removed in version 0.5.

### Migrating from version 0.3

Apply the following changes to code written against Amaranth 0.3 to migrate it to version 0.4:

* Update shell environment to use `AMARANTH_*` environment variables instead of `NMIGEN_*` environment variables.
* Update shell environment to use `AMARANTH_ENV_<TOOLCHAIN>` (with all-uppercase `<TOOLCHAIN>` name) environment variable names instead of `AMARANTH_ENV_<Toolchain>` or `NMIGEN_ENV_<Toolchain>` (with mixed-case `<Toolchain>` name).
* Update imports of the form `from amaranth.vendor.some_vendor import SomeVendorPlatform` to `from amaranth.vendor import SomeVendorPlatform`. This change will reduce future churn.
* Replace uses of `Const.normalize(value, shape)` with `Const(value, shape).value`.
* Replace uses of `Repl(value, count)` with `value.replicate(count)`.
* Replace uses of `Record` with [`amaranth.lib.data`](stdlib/data.md#module-amaranth.lib.data) and [`amaranth.lib.wiring`](stdlib/wiring.md#module-amaranth.lib.wiring). The appropriate replacement depends on the use case. If `Record` was being used for data storage and accessing the bit-level representation, use [`amaranth.lib.data`](stdlib/data.md#module-amaranth.lib.data). If `Record` was being used for connecting design components together, use [`amaranth.lib.wiring`](stdlib/wiring.md#module-amaranth.lib.wiring).
* Replace uses of `Sample`, `Past`, `Stable`, `Rose`, `Fell` with a manually instantiated register, e.g. `past_x = Signal.like(x); m.d.sync += past_x.eq(x)`.
* Remove uses of `amaranth.compat` by migrating to native Amaranth syntax.
* Ensure the `Pin` instance returned by `platform.request` is not cast to value directly, but used for its fields. Replace code like `leds = Cat(platform.request(led, n) for n in range(4))` with `leds = Cat(platform.request(led, n).o for n in range(4))` (note the `.o`).
* Remove uses of `amaranth.lib.scheduler.RoundRobin` by inlining or copying the implementation of that class.
* Remove uses of `amaranth.lib.fifo.SyncFIFO(fwft=False)` and `amaranth.lib.fifo.FIFOInterface(fwft=False)` by converting code to use `fwft=True` FIFOs or copying the implementation of those classes.

While code that uses the features listed as deprecated below will work in Amaranth 0.4, they will be removed in the next version.

### Implemented RFCs

* [RFC 1](https://amaranth-lang.org/rfcs/0001-aggregate-data-structures.html): Aggregate data structure library
* [RFC 2](https://amaranth-lang.org/rfcs/0002-interfaces.html): Interface definition library
* [RFC 3](https://amaranth-lang.org/rfcs/0003-enumeration-shapes.html): Enumeration shapes
* [RFC 4](https://amaranth-lang.org/rfcs/0004-const-castable-exprs.html): Constant-castable expressions
* [RFC 5](https://amaranth-lang.org/rfcs/0005-remove-const-normalize.html): Remove `Const.normalize`
* [RFC 6](https://amaranth-lang.org/rfcs/0006-stdlib-crc.html): CRC generator
* [RFC 8](https://amaranth-lang.org/rfcs/0008-aggregate-extensibility.html): Aggregate extensibility
* [RFC 9](https://amaranth-lang.org/rfcs/0009-const-init-shape-castable.html): Constant initialization for shape-castable objects
* [RFC 10](https://amaranth-lang.org/rfcs/0010-move-repl-to-value.html): Move `Repl` to `Value.replicate`
* [RFC 18](https://amaranth-lang.org/rfcs/0018-reorganize-vendor-platforms.html): Reorganize vendor platforms
* [RFC 19](https://amaranth-lang.org/rfcs/0019-remove-scheduler.html): Remove `amaranth.lib.scheduler`
* [RFC 15](https://amaranth-lang.org/rfcs/0015-lifting-shape-castables.html): Lifting shape-castable objects
* [RFC 20](https://amaranth-lang.org/rfcs/0020-deprecate-non-fwft-fifos.html): Deprecate non-FWFT FIFOs
* [RFC 22](https://amaranth-lang.org/rfcs/0022-valuecastable-shape.html): Define `ValueCastable.shape()`
* [RFC 28](https://amaranth-lang.org/rfcs/0028-override-value-operators.html): Allow overriding `Value` operators
* [RFC 31](https://amaranth-lang.org/rfcs/0031-enumeration-type-safety.html): Enumeration type safety
* [RFC 34](https://amaranth-lang.org/rfcs/0034-interface-rename.html): Rename `amaranth.lib.wiring.Interface` to `PureInterface`
* [RFC 35](https://amaranth-lang.org/rfcs/0035-shapelike-valuelike.html): Add `ShapeLike`, `ValueLike`
* [RFC 37](https://amaranth-lang.org/rfcs/0037-make-signature-immutable.html): Make `Signature` immutable
* [RFC 38](https://amaranth-lang.org/rfcs/0038-component-signature-immutability.html): `Component.signature` immutability

### Language changes

* Added: [`ShapeCastable`](reference.md#amaranth.hdl.ShapeCastable), similar to [`ValueCastable`](reference.md#amaranth.hdl.ValueCastable).
* Added: [`ShapeLike`](reference.md#amaranth.hdl.ShapeLike) and [`ValueLike`](reference.md#amaranth.hdl.ValueLike). ([RFC 35](https://amaranth-lang.org/rfcs/0035-shapelike-valuelike.html))
* Added: [`Value.as_signed()`](reference.md#amaranth.hdl.Value.as_signed) and [`Value.as_unsigned()`](reference.md#amaranth.hdl.Value.as_unsigned) can be used on left-hand side of assignment (with no difference in behavior).
* Added: `Const.cast()`. ([RFC 4](https://amaranth-lang.org/rfcs/0004-const-castable-exprs.html))
* Added: `Signal(reset=)`, [`Value.matches()`](reference.md#amaranth.hdl.Value.matches), `with m.Case():` accept any constant-castable objects. ([RFC 4](https://amaranth-lang.org/rfcs/0004-const-castable-exprs.html))
* Added: [`Value.replicate()`](reference.md#amaranth.hdl.Value.replicate), superseding `Repl`. ([RFC 10](https://amaranth-lang.org/rfcs/0010-move-repl-to-value.html))
* Added: `Memory` supports transparent read ports with read enable.
* Changed: creating a `Signal` with a shape that is a [`ShapeCastable`](reference.md#amaranth.hdl.ShapeCastable) implementing [`ShapeCastable.__call__()`](reference.md#amaranth.hdl.ShapeCastable.__call__) wraps the returned object using that method. ([RFC 15](https://amaranth-lang.org/rfcs/0015-lifting-shape-castables.html))
* Changed: [`Value.cast()`](reference.md#amaranth.hdl.Value.cast) casts [`ValueCastable`](reference.md#amaranth.hdl.ValueCastable) objects recursively.
* Changed: [`Value.cast()`](reference.md#amaranth.hdl.Value.cast) treats instances of classes derived from both [`enum.Enum`](https://docs.python.org/3/library/enum.html#enum.Enum) and [`int`](https://docs.python.org/3/library/functions.html#int) (including [`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum)) as enumerations rather than integers.
* Changed: [`Value.matches()`](reference.md#amaranth.hdl.Value.matches) with an empty list of patterns returns `Const(1)` rather than `Const(0)`, to match the behavior of `with m.Case():`.
* Changed: `Cat()` warns if an enumeration without an explicitly specified shape is used. ([RFC 3](https://amaranth-lang.org/rfcs/0003-enumeration-shapes.html))
* Changed: `signed(0)` is no longer constructible. (The semantics of this shape were never defined.)
* Changed: [`Value.__abs__()`](reference.md#amaranth.hdl.Value.__abs__) returns an unsigned value.
* Deprecated: `ast.Sample`, `ast.Past`, `ast.Stable`, `ast.Rose`, `ast.Fell`. (Predating the RFC process.)
* Deprecated: `Const.normalize()`; use `Const(value, shape).value` instead of `Const.normalize(value, shape)`. ([RFC 5](https://amaranth-lang.org/rfcs/0005-remove-const-normalize.html))
* Deprecated: `Repl`; use [`Value.replicate()`](reference.md#amaranth.hdl.Value.replicate) instead. ([RFC 10](https://amaranth-lang.org/rfcs/0010-move-repl-to-value.html))
* Deprecated: `Record`; use [`amaranth.lib.data`](stdlib/data.md#module-amaranth.lib.data) and [`amaranth.lib.wiring`](stdlib/wiring.md#module-amaranth.lib.wiring) instead. ([RFC 1](https://amaranth-lang.org/rfcs/0001-aggregate-data-structures.html), [RFC 2](https://amaranth-lang.org/rfcs/0002-interfaces.html))
* Removed: (deprecated in 0.1) casting of [`Shape`](reference.md#amaranth.hdl.Shape) to and from a `(width, signed)` tuple.
* Removed: (deprecated in 0.3) `ast.UserValue`.
* Removed: (deprecated in 0.3) support for `# nmigen:` linter instructions at the beginning of file.

### Standard library changes

* Added: [`amaranth.lib.enum`](stdlib/enum.md#module-amaranth.lib.enum). ([RFC 3](https://amaranth-lang.org/rfcs/0003-enumeration-shapes.html))
* Added: [`amaranth.lib.data`](stdlib/data.md#module-amaranth.lib.data). ([RFC 1](https://amaranth-lang.org/rfcs/0001-aggregate-data-structures.html))
* Added: [`amaranth.lib.wiring`](stdlib/wiring.md#module-amaranth.lib.wiring). ([RFC 2](https://amaranth-lang.org/rfcs/0002-interfaces.html))
* Added: [`amaranth.lib.crc`](stdlib/crc.md#module-amaranth.lib.crc). ([RFC 6](https://amaranth-lang.org/rfcs/0006-stdlib-crc.html))
* Deprecated: `amaranth.lib.scheduler`. ([RFC 19](https://amaranth-lang.org/rfcs/0019-remove-scheduler.html))
* Deprecated: [`amaranth.lib.fifo.FIFOInterface`](stdlib/fifo.md#amaranth.lib.fifo.FIFOInterface) with `fwft=False`. ([RFC 20](https://amaranth-lang.org/rfcs/0020-deprecate-non-fwft-fifos.html))
* Deprecated: [`amaranth.lib.fifo.SyncFIFO`](stdlib/fifo.md#amaranth.lib.fifo.SyncFIFO) with `fwft=False`. ([RFC 20](https://amaranth-lang.org/rfcs/0020-deprecate-non-fwft-fifos.html))

### Toolchain changes

* Changed: text files are written with LF line endings on Windows, like on other platforms.
* Added: `debug_verilog` override in `build.TemplatedPlatform`.
* Added: `env=` argument to `build.run.BuildPlan.execute_local()`.
* Changed: `build.run.BuildPlan.add_file()` rejects absolute paths.
* Deprecated: use of mixed-case toolchain environment variable names, such as `NMIGEN_ENV_Diamond` or `AMARANTH_ENV_Diamond`; use upper-case environment variable names, such as `AMARANTH_ENV_DIAMOND`.
* Removed: (deprecated in 0.3) `sim.Simulator.step()`.
* Removed: (deprecated in 0.3) `back.pysim`.
* Removed: (deprecated in 0.3) support for invoking `back.rtlil.convert()` and `back.verilog.convert()` without an explicit ports= argument.
* Removed: (deprecated in 0.3) [`test`](https://docs.python.org/3/library/test.html#module-test).

### Platform integration changes

* Added: `icepack_opts` override in `vendor.LatticeICE40Platform`.
* Added: `OSCH` as `default_clk` clock source in `vendor.LatticeMachXO2Platform`, `vendor.LatticeMachXO3LPlatform`.
* Added: Xray toolchain support in `vendor.XilinxPlatform`.
* Added: Artix UltraScale+ part support in `vendor.XilinxPlatform`.
* Added: `vendor.GowinPlatform`.
* Deprecated: `vendor.intel`, `vendor.lattice_ecp5`, `vendor.lattice_ice40`, `vendor.lattice_machxo2_3l`, `vendor.quicklogic`, `vendor.xilinx`; import platforms directly from `vendor` instead. ([RFC 18](https://amaranth-lang.org/rfcs/0018-reorganize-vendor-platforms.html))
* Removed: (deprecated in 0.3) `lattice_machxo2`
* Removed: (deprecated in 0.3) `lattice_machxo_2_3l.LatticeMachXO2Or3LPlatform` SVF programming vector `{{name}}.svf`.
* Removed: (deprecated in 0.3) `xilinx_spartan_3_6.XilinxSpartan3APlatform`, `xilinx_spartan_3_6.XilinxSpartan6Platform`, `xilinx_7series.Xilinx7SeriesPlatform`, `xilinx_ultrascale.XilinxUltrascalePlatform`.

## Version 0.3

The project has been renamed from nMigen to Amaranth.

Features deprecated in version 0.2 have been removed.

### Migrating from version 0.2

Apply the following changes to code written against nMigen 0.2 to migrate it to Amaranth 0.3:

* Update `import nmigen as nm` [explicit prelude imports](guide.md#lang-prelude) to be `import amaranth as am`, and adjust the code to use the `am.*` namespace.
* Update `import nmigen.*` imports to be `import amaranth.*`.
* Update `import nmigen_boards.*` imports to be `import amaranth_boards.*`.
* Update board definitions using `vendor.lattice_machxo2.LatticeMachXO2Platform` to use `vendor.lattice_machxo_2_3l.LatticeMachXO2Platform`.
* Update board definitions using `vendor.xilinx_spartan_3_6.XilinxSpartan3APlatform`, `vendor.xilinx_spartan_3_6.XilinxSpartan6Platform`, `vendor.xilinx_7series.Xilinx7SeriesPlatform`, `vendor.xilinx_ultrascale.XilinxUltrascalePlatform` to use `vendor.xilinx.XilinxPlatform`.
* Switch uses of `hdl.ast.UserValue` to `ValueCastable`; note that `ValueCastable` does not inherit from `Value`, and inheriting from `Value` is not supported.
* Switch uses of `back.pysim` to `sim`.
* Add an explicit `ports=` argument to uses of `back.rtlil.convert()` and `back.verilog.convert()` if missing.
* Remove uses of `test.utils.FHDLTestCase` and vendor the implementation of `test.utils.FHDLTestCase.assertFormal` if necessary.

While code that uses the features listed as deprecated below will work in Amaranth 0.3, they will be removed in the next version.

### Language changes

* Added: [`Value`](reference.md#amaranth.hdl.Value) can be used with [`abs()`](https://docs.python.org/3/library/functions.html#abs).
* Added: [`Value.rotate_left()`](reference.md#amaranth.hdl.Value.rotate_left) and [`Value.rotate_right()`](reference.md#amaranth.hdl.Value.rotate_right).
* Added: [`Value.shift_left()`](reference.md#amaranth.hdl.Value.shift_left) and [`Value.shift_right()`](reference.md#amaranth.hdl.Value.shift_right).
* Added: [`ValueCastable`](reference.md#amaranth.hdl.ValueCastable).
* Deprecated: `ast.UserValue`; use [`ValueCastable`](reference.md#amaranth.hdl.ValueCastable) instead.
* Added: Division and modulo operators can be used with a negative divisor.
* Deprecated: `# nmigen:` linter instructions at the beginning of file; use `# amaranth:` instead.

### Standard library changes

* Added: [`cdc.PulseSynchronizer`](stdlib/cdc.md#amaranth.lib.cdc.PulseSynchronizer).
* Added: [`cdc.AsyncFFSynchronizer`](stdlib/cdc.md#amaranth.lib.cdc.AsyncFFSynchronizer).
* Changed: [`fifo.AsyncFIFO`](stdlib/fifo.md#amaranth.lib.fifo.AsyncFIFO) is reset when the write domain is reset.
* Added: `fifo.AsyncFIFO.r_rst` is asserted when the write domain is reset.
* Added: `fifo.FIFOInterface.r_level` and `fifo.FIFOInterface.w_level`.

### Toolchain changes

* Changed: Backend and simulator reject wires larger than 65536 bits.
* Added: Backend emits Yosys enumeration attributes for [enumeration-shaped](guide.md#lang-shapeenum) signals.
* Added: If a compatible Yosys version is not installed, `back.verilog` will fall back to the [amaranth-yosys](https://github.com/amaranth-lang/amaranth-yosys) PyPI package. The package can be [installed](install.md#install) as `amaranth[builtin-yosys]` to ensure this dependency is available.
* Added: `back.cxxrtl`.
* Added: `sim`, a simulator interface with support for multiple simulation backends.
* Deprecated: `back.pysim`; use `sim` instead.
* Removed: The `with Simulator(fragment, ...) as sim:` form.
* Removed: [`sim.Simulator.add_process()`](simulator.md#amaranth.sim.Simulator.add_process) with a generator argument.
* Deprecated: `sim.Simulator.step()`; use [`sim.Simulator.advance()`](simulator.md#amaranth.sim.Simulator.advance) instead.
* Added: `build.BuildPlan.execute_remote_ssh()`.
* Deprecated: `test.utils.FHDLTestCase`, with no replacement.
* Deprecated: `back.rtlil.convert()` and `back.verilog.convert()` without an explicit ports= argument.
* Changed: VCD output now uses a top-level “bench” module that contains testbench only signals.
* Deprecated: `NMIGEN_*` environment variables; use `AMARANTH_*` environment variables instead.

### Platform integration changes

* Added: `SB_LFOSC` and `SB_HFOSC` as `default_clk` clock sources in `lattice_ice40.LatticeICE40Platform`.
* Added: `lattice_machxo2.LatticeMachXO2Platform` generates binary (`.bit`) bitstreams.
* Added: `lattice_machxo_2_3l.LatticeMachXO3LPlatform`.
* Deprecated: `lattice_machxo2`; use `lattice_machxo_2_3l.LatticeMachXO2Platform` instead.
* Removed: `xilinx_7series.Xilinx7SeriesPlatform.grade`; this family has no temperature grades.
* Removed: `xilinx_ultrascale.XilinxUltrascalePlatform.grade`; this family has temperature grade as part of speed grade.
* Added: Symbiflow toolchain support for `xilinx_7series.Xilinx7SeriesPlatform`.
* Added: `lattice_machxo_2_3l.LatticeMachXO2Or3LPlatform` generates separate Flash and SRAM SVF programming vectors, `{{name}}_flash.svf` and `{{name}}_sram.svf`.
* Deprecated: `lattice_machxo_2_3l.LatticeMachXO2Or3LPlatform` SVF programming vector `{{name}}.svf`; use `{{name}}_flash.svf` instead.
* Added: `quicklogic.QuicklogicPlatform`.
* Added: `cyclonev_oscillator` as `default_clk` clock source in `intel.IntelPlatform`.
* Added: `add_settings` and `add_constraints` overrides in `intel.IntelPlatform`.
* Added: `xilinx.XilinxPlatform`.
* Deprecated: `xilinx_spartan_3_6.XilinxSpartan3APlatform`, `xilinx_spartan_3_6.XilinxSpartan6Platform`, `xilinx_7series.Xilinx7SeriesPlatform`, `xilinx_ultrascale.XilinxUltrascalePlatform`; use `xilinx.XilinxPlatform` instead.
* Added: Mistral toolchain support for `intel.IntelPlatform`.
* Added: `synth_design_opts` override in `xilinx.XilinxPlatform`.

## Versions 0.1, 0.2

No changelog is provided for these versions.

The PyPI packages were published under the `nmigen` namespace, rather than `amaranth`.


# chipflow-commands.html.md

# The `chipflow` command

The `chipflow` tool enables you to simulate your design or submit it to the ChipFlow cloud build service.
It implements several subcommands, which can be customised or added to in the `steps` section of [chipflow.toml](chipflow-toml-guide.md#chipflow-toml-steps).

## `chipflow auth`

The `chipflow auth` command manages authentication with the ChipFlow API.

### `chipflow auth login`

Authenticate with the ChipFlow API using one of the following methods (tried in order):

1. **GitHub CLI token** (recommended) - If you have `gh` installed and authenticated, this method is instant
2. **Device flow** - Opens your browser to authorize via GitHub OAuth

Your API key will be saved locally in `~/.config/chipflow/credentials` for future use.

Options:

- `--force`: Force re-authentication even if already logged in

Examples:

```default
# Authenticate (will auto-detect best method)
chipflow auth login

# Force re-authentication
chipflow auth login --force
```

### `chipflow auth logout`

Remove saved credentials from your system:

```default
chipflow auth logout
```

## `chipflow pin lock`

The `chipflow pin lock` command performs pin locking for the current design.
For every new top level interface with containing external pins with a `IOSignature` that is discovered, the necessary number of package pins is allocated and the mapping saved in the `pins.lock` file.
This means that, unless the `pins.lock` file is deleted or manually modified, the pin assignments of all existing pins will always remain the same.

## `chipflow silicon`

The `chipflow silicon` subcommand is used to send the design to the cloud builder for build and tapeout. In general, it would be run inside GitHub Actions as part of a CI job.

> - `chipflow silicon prepare` links the design, including all Amaranth modules and any external Verilog components, into a single RTLIL file that is ready to be sent to the cloud builder.
> - `chipflow silicon submit` sends the linked design along with the `pins.lock` file containing pinout information to the ChipFlow cloud service for the build. With the `--dry-run` argument, it can be used for a local test that the design is ready to be submitted.

Authentication for submission:

1. If you’ve run `chipflow auth login`, your saved credentials will be used automatically
2. If `CHIPFLOW_API_KEY` environment variable is set, it will be used
3. Otherwise, if `gh` (GitHub CLI) is installed and authenticated, it will authenticate automatically
4. As a last resort, you’ll be prompted to complete device flow authentication

Most users should simply run `chipflow auth login` once and authentication will be automatic for all future submissions.

## `chipflow sim`

The `chipflow sim build` command is used to build a CXXRTL simulation of the design; converting the design to a fast compiled C++ format along with C++ models of any peripherals.

Extra C++ model files for the simulation, and any custom build steps required, can be added to the `sim/doit_build.py` [doit](https://pydoit.org/) build script inside the user project.

A default simulation driver (the C++ code that runs the simulation) is included as [main.cc](https://github.com/ChipFlow/chipflow-examples/blob/main/minimal/design/sim/main.cc) in the example projects. This code:

> - Instantiates the user design; and the simulation models for the peripherals (SPI flash, UART and GPIO)
> - Initialises the CXXRTL debug agent, which is required to perform debugging with the [RTL Debugger](https://github.com/amaranth-lang/rtl-debugger) VS Code extension
> - Configures input and output JSON files for stimuli and results respectively (for automated integration testing)
> - Runs the design for 3,000,000 clock cycles

## `chipflow software`

If the design contains a CPU, the `chipflow software build` command is used to build test firmware for the target CPU. Which C source files to include, and any build options (like the target architecture or enabled RISC-V extensions) can be customised in the `software/doit_build.py` doit build script inside the user project.


# chipflow-toml-guide.html.md

# Intro to `chipflow.toml`

The `chipflow.toml` file provides configuration for your design with the ChipFlow platform.

Let’s start with a typical example:

```toml
[chipflow]
project_name = "test-chip"

[chipflow.top]
soc = "my_design.design:MySoC"

[chipflow.silicon]
process = "gf130bcd"
package = "pga144"
```

<!-- # Assert that example-chipflow.toml matches the current config schema. If
# this test fails, then its likely that the content in this file will need
# to be updated.
from chipflow.config.parser import _parse_config_file
_parse_config_file("docs/example-chipflow.toml") -->

## `[chipflow]` table

Required

The top level configuration for inputs to the ChipFlow tools.

# project_name

Required

The `project_name` is a human-readable identifier for this project. If not set, the tool and library will use the project name configured in `pyproject.toml`.

```TOML
[chipflow]
project_name = 'my_project'
```

# clock_domains

Optional

A list of top-level clock domains for your design. If omitted, defaults to the Amaranth default `sync`, and sync is always assumed to be the name of the core clock for bringup.

```TOML
[chipflow]
clock_domains = ['sync', 'peripheral']
```

## `[chipflow.top]` table

Required

This section outlines the design modules that need to be instantiated.
A new top module will be automatically generated, incorporating all specified modules along with their interfaces.
Each entry follows the format <instance name> = <module class path>.

The instance name is the name the python object will be given in your design, and the [module class path](#term-module-class-path)

```TOML
[chipflow.top]
soc = "my_design.design:MySoC"
```

<a id="term-module-class-path"></a>

module class path
: The module class path offers a way to locate Python objects as entry points.
  It consists of a module’s [qualified name](https://docs.python.org/3/glossary.html#term-qualified-name) followed by a colon (:) and then the [qualified name](https://docs.python.org/3/glossary.html#term-qualified-name) of the class within that module.

<a id="chipflow-toml-steps"></a>

## `[chipflow.steps]` table

Optional

The `steps` section allows overriding or addition to the standard steps available from chipflow.

For example, if you want to override the standard silicon preparation step, you could derive from `chipflow.steps.silicon.SiliconStep`, add your custom functionality
and add the following to your chipflow.toml, with the appropriate [module class path](#term-module-class-path):

```TOML
[chipflow.steps]
silicon = "my_design.steps.silicon:SiliconStep"
```

You probably won’t need to change these if you’re starting from an example repository.

## `[chipflow.silicon]`

Required

The `silicon` section sets the Foundry `process` (i.e. PDK) that we are targeting for manufacturing, and the physical `package` (including pad ring) we want to place our design inside.

You’ll choose the `process` and `package` based in the requirements of your design.

```TOML
[chipflow.silicon]
process = "ihp_sg13g2"
package = "pga144"
```

# process

Required

Foundry process to use

| Process<br/><br/><br/><br/>   | Supported<br/><br/><br/>pad rings<br/><br/>   | Notes<br/><br/><br/><br/>   |
|-------------------------------|-----------------------------------------------|-----------------------------|
| sky130                        | caravel                                       | Skywater 130nm              |
| gf180                         | caravel                                       | GlobalFoundries 180nm       |
| gf130bcd                      | pga144                                        | GlobalFoundries 130nm BCD   |
| ihp_sg13g2                    | pga144                                        | IHP SG13G2 130nm SiGe       |

# package

Required

The form of IC packaging to use

| Pad ring                          | Pad count                 | Pad locations             | Notes                                                                                                            |
|-----------------------------------|---------------------------|---------------------------|------------------------------------------------------------------------------------------------------------------|
|                                   |                           |                           |                                                                                                                  |
| pga144                            | 144                       | `1` … `144`               |                                                                                                                  |
| TBA<br/><br/><br/><br/><br/><br/> | <br/><br/><br/><br/><br/> | <br/><br/><br/><br/><br/> | If you require a different<br/><br/><br/>pad ring, then please contact<br/><br/><br/>customer support.<br/><br/> |

## Power connections

The package definition provides default locations for pins needed for bringup and test, like core power, ground, clock and reset, along with JTAG.

These can be determined by calling BasePackageDef.bringup_pins.

For ports that require their own power lines, you can set `allocate_power` and `power_voltage` in their IOSignature.

<a id="term-loc"></a>

loc
: This is the physical location of the pad on your chosen pad ring. How these are indexed varies by the pad ring.

<a id="term-type"></a>

type
: The [type](#term-type) for each pad can be set to one of [clock](#term-clock) or [reset](#term-reset).

<a id="term-clock"></a>

clock
: External clock input.

<a id="term-reset"></a>

reset
: External reset input.


# coding.html.md

# Code conversion

The [`amaranth.lib.coding`](#module-amaranth.lib.coding) module provides building blocks for conversion between different encodings of binary numbers.

## One-hot coding

### *class* amaranth.lib.coding.Encoder

Encode one-hot to binary.

If one bit in `i` is asserted, `n` is low and `o` indicates the asserted bit.
Otherwise, `n` is high and `o` is `0`.

* **Parameters:**
  **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Bit width of the input
* **Attributes:**
  * **i** (*Signal(width), in*) – One-hot input.
  * **o** (*Signal(range(width)), out*) – Encoded natural binary.
  * **n** (*Signal, out*) – Invalid: either none or multiple input bits are asserted.

### *class* amaranth.lib.coding.Decoder

Decode binary to one-hot.

If `n` is low, only the `i`-th bit in `o` is asserted.
If `n` is high, `o` is `0`.

* **Parameters:**
  **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Bit width of the output.
* **Attributes:**
  * **i** (*Signal(range(width)), in*) – Input binary.
  * **o** (*Signal(width), out*) – Decoded one-hot.
  * **n** (*Signal, in*) – Invalid, no output bits are to be asserted.

## Priority coding

### *class* amaranth.lib.coding.PriorityEncoder

Priority encode requests to binary.

If any bit in `i` is asserted, `n` is low and `o` indicates the least significant
asserted bit.
Otherwise, `n` is high and `o` is `0`.

* **Parameters:**
  **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Bit width of the input.
* **Attributes:**
  * **i** (*Signal(width), in*) – Input requests.
  * **o** (*Signal(range(width)), out*) – Encoded natural binary.
  * **n** (*Signal, out*) – Invalid: no input bits are asserted.

### *class* amaranth.lib.coding.PriorityDecoder

Decode binary to priority request.

Identical to [`Decoder`](#amaranth.lib.coding.Decoder).

## Gray coding

### *class* amaranth.lib.coding.GrayEncoder

Encode binary to Gray code.

* **Parameters:**
  **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Bit width.
* **Attributes:**
  * **i** (*Signal(width), in*) – Natural binary input.
  * **o** (*Signal(width), out*) – Encoded Gray code.

### *class* amaranth.lib.coding.GrayDecoder

Decode Gray code to binary.

* **Parameters:**
  **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Bit width.
* **Attributes:**
  * **i** (*Signal(width), in*) – Gray code input.
  * **o** (*Signal(width), out*) – Decoded natural binary.


# contrib.html.md

# Contributing

The Amaranth project is the collective work of many people collaborating over the years, and it would not be the same without everyone’s unique perspectives and contributions. We’re glad that you are considering joining us! This page will guide you through some of the ways to contribute to the project.

## Filing problem reports

We would like Amaranth to be a best-in-class design tool, and hearing about issues people encounter while using it is crucial for improving it. While we do care a lot about correctness of the results, we care about the experience of using the tool just as much. Amaranth is meant to be a tool that is comfortable to use: with fewer sharp edges (no matter how much technological appeal they might have) and more signs and guardrails.

Please [report](https://github.com/amaranth-lang/amaranth/issues) any problems you encounter using Amaranth. To go beyond that: **If, while you are using Amaranth, you see an error message that is hard to understand or is misleading, please report it as a bug. Even (especially!) if you think you did something wrong.**

When filing problem reports, please include the following information:

* The exact version of Amaranth, which you can find by running `python -c "import amaranth; print(amaranth.__version__)"`;
* A complete, self-contained, and minimal program that demonstrates the problem you are reporting (if minimizing it is not feasible, include the exact sequence of steps that reproduces the problem);
* What you expected to happen, and what actually happened (where possible, including a verbatim copy of the log file or the terminal output);
* For usability issues: your reason for filing the report (i.e. why did you expect a different behavior).

There is no expectation that a person who is filing a problem report should work on fixing it. Submitting an issue is a valuable contribution in its own right.

## Fixing problems

We appreciate that many in the open source community tend to see problems they encounter as opportunities to collaborate, and we enjoy seeing an issue being filed together with a pull request. However, unless you’ve contributed a few times before or the fix is truly trivial, **please discuss it with one of the maintainers first**. It doesn’t take much time and it can sometimes save everyone a lot of unnecessary work and frustration.

## Proposing new features

Amaranth is a programming language and a toolchain, which is different from many other kinds of open source projects in that just about every part of it is, unavoidably, tightly coupled to every other one, the result being that seemingly obvious and apparently minor decisions can have dramatic consequences years later.

To make sure that new features undergo the scrutiny necessary for commitment to many years of support, and to make sure that everyone in the community who will be impacted by the changes has a chance to make their voice heard, **all substantial changes, including feature proposals, must go through a formal Request for Comments process**. The process, as well as the accepted proposals, are described [here](https://amaranth-lang.org/rfcs/). Typically, substantial changes are accepted after one to several rounds of community review achieve near-unanimous consensus.

## Working with the codebase

### Preparing the environment

The Amaranth codebase uses the [PDM](https://pdm-project.org/) package and dependency manager to structure the development workflow. Please [install PDM](https://pdm-project.org/latest/#recommended-installation-method) first and make sure you have downloaded the latest changes to the source files. Once you have done so, run:

```console
$ pdm install --dev
```

This command creates a [virtual environment](https://docs.python.org/3/tutorial/venv.html#tut-venv) located at `./.venv/` and installs the runtime dependencies of Amaranth as well as the necessary development tools in it.

Amaranth itself is installed in the *editable mode*, meaning that the changes to its source files are immediately reflected in running the tests and documentation. However, other changes (addition or removal of source files, or changes to dependencies) will not be picked up, and it is a good habit to run `pdm install` each time after updating the source tree.

### Running the testsuite

Some of the tests make use of [formal methods](https://symbiyosys.readthedocs.io/en/latest/), and to run the complete testsuite, it is necessary to install the [Yosys](https://github.com/YosysHQ/yosys) frontend and the [yices2](https://github.com/SRI-CSL/yices2) SMT solver. These are distributed as a part of the [OSS CAD Suite](https://github.com/YosysHQ/oss-cad-suite-build). Without the tools being installed, the tests that rely on formal verification will be skipped.

To run the testsuite, use:

```console
$ pdm run test
```

### Building the documentation

To build the documentation once, use:

```console
$ pdm run document
```

The documentation index is located at `./docs/_build/index.html`.

Working on documentation usually involves making many small, iterative changes, and it is laborous to rebuild it manually each time. To start a process that rebuilds documentation automatically on change, use:

```console
$ pdm run document-live
```

While it is running you can browse the documentation at [http://127.0.0.1:8000](http://127.0.0.1:8000). The edits you make are reflected on the document open in the browser after a short delay. It is useful to keep an eye on the terminal where this process is running, as the information about syntactic errors, missing references, and other issues will be printed there.

Occasionally, the documentation builder will persist in rendering an incorrect or outdated version of the contents of a Python source file. To fix this, run:

```console
$ pdm run document-live -a
```

## Documentation style guide

#### WARNING
Our documentation style guidelines are evolving, and this section is incomplete.

Some of the fundamental guidelines are:

* **Document the contract and the affordances,** not the implementation. This is especially important because the Amaranth documentation is *the* source of truth for its semantics; the tests and the implementation source code are secondary to it, and the RFCs exist to record the process rather than document the outcome.
* **Shape the code to be documentable.** This is a corollary to the previous guideline. If an interface is difficult to describe in a way that is readily understood, then it may need to be changed. Many breaking changes in Amaranth were done to make the language and libraries easier to understand.
* **Be consistent.** Take inspiration from existing documentation for similar modules. However, don’t be consistent at the expense of clarity.
* **Be concise.** It is easy to write boilerplate, and difficult to navigate through it.
  > * In particular, if the Parameters section of the class docstring describes a parameter, it is expected that the same parameter will be available as a class attribute (usually, but not always, read-only), and there is no need to additionally document this fact. If there isn’t a corresponding attribute it should likely be added.
  > * There is no need to individually document every argument and every return value of every method. This mainly creates clutter. The goal in writing documentation is transferring knowledge, not ticking boxes.

Some of the formatting guidelines are:

* Limit code (including docstrings, where possible–some of the Sphinx syntax does not allow wrapping) to 100 columns in `.py` files, but do not break paragraphs in `.rst` files.
* Use `###...#` for first-level headings, `===...=` for second-level headings, `---...-` for third-level headings.
* Use the `:py:`...`` syntax for inline Python code references (even trivial ones, e.g. `:py:`var_name``), `.. testcode::` for most Python code blocks (use `.. code::` where the code cannot or should not be tested), `.. doctest::` for doctests.
* Use admonitions sparingly, and only of the following kinds:
  > * `.. warning::` for text which MUST be paid attention to, or else unexpected bad things may happen. This is the most noticeable kind, rendered in yellow at the moment.
  > * `.. tip::` for text which SHOULD be paid attention to, otherwise annoyance may happen. This is the second most noticeable kind, rendered in bright blue-green at the moment.
  > * `.. note::` for text which MAY be paid attention to, but which is not key for understanding of the topic as a whole. This is the least noticeable kind, rendered in faint blue at the moment.
  > * `.. todo::` may also be used for incomplete sections.
* For methods, phrase the short description (first line of docstring) like `Do the thing.`, i.e. as an imperative sentence.
* For properties, phrase the short description (first line of docstring) like `Value of thing.`, i.e. as a declarative sentence.
* When documenting signatures of interfaces, as well as components, use the (non-standard) Members section to document their interface members, and only that section; do not document them in an Attributes section.
* If an anchor for a section is needed, namespace it, e.g. the `.. _lang-assignable:` anchor is a part of the `lang` namespace. Anchor names are global.
* To refer to non-sequential logic, use the term “combinational” over “combinatorial”.

## Contributing your changes

#### WARNING
Our code style guidelines are evolving, and we do not yet have a formal document listing them.

We ask that you do your best effort to keep the code that you add or modify similar in style as well as in spirit to the code surrounding it, and we may ask you to change it during review. When in doubt, submit your code as-is.

## Weekly meetings

Every Monday at 17:00 UTC on our IRC channel [#amaranth-lang at libera.chat](https://web.libera.chat/#amaranth-lang) or Matrix channel [#amaranth-lang:matrix.org](https://matrix.to/#/#amaranth-lang:matrix.org) (the channels are bridged together: the same messages appear on both), Amaranth maintainers meet with users and contributors to discuss newly submitted Requests for Comments and any other issues that warrant broad attention. These public meetings are the primary avenue of decision making.

If you want to contribute, have interest in language evolution, or simply want to voice your view on proposed features, feel free to join these meetings; there is no formal attendance. If you are not able to make the time, the meetings are publicly recorded and the summaries are posted in the relevant GitHub thread after the meeting.


# contributor-pin-signature-internals.html.md

# Pin Signature Architecture (Contributor Guide)

This guide explains the internal architecture of ChipFlow’s pin signature system, annotation infrastructure, and how platforms consume this metadata. This is intended for contributors who need to understand or extend the pin signature system.

## Overview

ChipFlow uses a sophisticated annotation system to attach metadata to Amaranth hardware designs. This metadata describes:

1. **I/O configuration** (drive modes, trip points, clock domains)
2. **Simulation models** (UIDs and parameters for testbench generation)
3. **Software drivers** (C/H files and register structures)
4. **Data attachments** (software binaries to load into flash)

This metadata is preserved through the entire flow from Python design → RTLIL → platform backends (silicon, simulation, software).

## Annotation Infrastructure

Core Module: `chipflow/platform/io/annotate.py`

The annotation system uses Amaranth’s `meta.Annotation` framework combined with Pydantic for type-safe JSON schema generation.

### amaranth_annotate() Decorator

The core function is `amaranth_annotate()`:

```python
def amaranth_annotate(
    modeltype: type[TypedDict],      # TypedDict defining the schema
    schema_id: str,                  # JSON schema $id (e.g., "https://chipflow.com/schemas/io-model/v0")
    member: str = '__chipflow_annotation__',  # Attribute name storing the data
    decorate_object: bool = False    # If True, decorates instances; if False, decorates classes
):
```

**How it works:**

1. Takes a `TypedDict` model and generates a JSON schema using Pydantic’s `TypeAdapter`
2. Creates an Amaranth `meta.Annotation` subclass with that schema
3. Returns a decorator that applies the annotation to classes or objects
4. The decorated class/object stores data in `member` attribute (e.g., `self._model`)
5. When serializing to RTLIL, Amaranth calls `Annotation.as_json()` which extracts the data

**Example Usage:**

```python
from typing_extensions import TypedDict, NotRequired
from chipflow.platform.io.annotate import amaranth_annotate

# Define schema as TypedDict
class MyModel(TypedDict):
    name: str
    count: NotRequired[int]

# Create decorator
@amaranth_annotate(MyModel, "https://example.com/my-model/v1", "_my_data")
class MySignature(wiring.Signature):
    def __init__(self, name: str, count: int = 1):
        # Store data in attribute that decorator will extract
        self._my_data = MyModel(name=name, count=count)
        super().__init__({"port": Out(wiring.Signature(...))})
```

**Key Points:**

- The decorator doesn’t modify `__init__` - you must populate the data attribute yourself
- `decorate_object=True` is used with `attach_data()` to annotate signature instances
- Pydantic validates the data and provides JSON schema with proper types
- The schema is embedded in RTLIL annotations for downstream tools

### submodule_metadata() Function

Platforms extract annotations from the design using `submodule_metadata()`:

```python
def submodule_metadata(fragment: Fragment, top_name: str):
    """
    Generator that walks the Fragment tree and yields:
        (component, submodule_name, metadata_dict)

    metadata_dict contains:
        'annotations': dict mapping schema_id → annotation data
        'path': list of component names from root
    """
```

**Usage in Platforms:**

```python
from chipflow.platform.io.annotate import submodule_metadata

frag = Fragment.get(m, None)
for component, name, meta in submodule_metadata(frag, "top"):
    annotations = meta['annotations']
    if DRIVER_MODEL_SCHEMA in annotations:
        driver_model = TypeAdapter(DriverModel).validate_python(
            annotations[DRIVER_MODEL_SCHEMA]
        )
        # Use driver_model data...
```

## I/O Signature Base Classes

Core Module: `chipflow/platform/io/iosignature.py`

### IOModelOptions TypedDict

Defines all options for configuring I/O pins:

```python
class IOModelOptions(TypedDict):
    invert: NotRequired[bool | Tuple[bool, ...]]
    individual_oe: NotRequired[bool]
    power_domain: NotRequired[str]
    clock_domain: NotRequired[str]
    buffer_in: NotRequired[bool]
    buffer_out: NotRequired[bool]
    sky130_drive_mode: NotRequired[Sky130DriveMode]
    trip_point: NotRequired[IOTripPoint]
    init: NotRequired[int | bool]
    init_oe: NotRequired[int | bool]
```

All fields use `NotRequired` to make them optional with sensible defaults.

### IOModel TypedDict

Extends `IOModelOptions` with direction and width information:

```python
class IOModel(IOModelOptions):
    direction: IODirection  # "input", "output", or "bidir"
    width: int
```

This is the complete model that gets annotated on I/O signatures.

### IOSignature Base Class

The base class for all I/O signatures, decorated with `@amaranth_annotate`:

```python
@amaranth_annotate(IOModel, IO_ANNOTATION_SCHEMA, '_model')
class IOSignature(wiring.Signature):
    def __init__(self, width: int, direction: IODirection, **kwargs: Unpack[IOModelOptions]):
        # Build the model from parameters
        model = IOModel(direction=direction, width=width, **kwargs)

        # Create appropriate signal structure based on direction
        if direction == "input":
            members = {"i": In(width)}
        elif direction == "output":
            members = {
                "o": Out(width),
                "oe": Out(1) if not individual_oe else Out(width)
            }
        elif direction == "bidir":
            members = {
                "i": In(width),
                "o": Out(width),
                "oe": Out(1) if not individual_oe else Out(width)
            }

        # Store model for annotation extraction
        self._model = model

        super().__init__(members)
```

**Direction-Specific Subclasses:**

```python
class InputIOSignature(IOSignature):
    def __init__(self, width: int, **kwargs):
        super().__init__(width, "input", **kwargs)

class OutputIOSignature(IOSignature):
    def __init__(self, width: int, **kwargs):
        super().__init__(width, "output", **kwargs)

class BidirIOSignature(IOSignature):
    def __init__(self, width: int, **kwargs):
        super().__init__(width, "bidir", **kwargs)
```

## Concrete Pin Signatures

Core Module: `chipflow/platform/io/signatures.py`

Concrete pin signatures (UART, GPIO, SPI, etc.) combine I/O signatures with simulation metadata.

These signatures are annotations of the **type** of the external interface (UART, GPIO, SPI), allowing ChipFlow to select and typecheck suitable simulation models that match that interface type. The annotations are independent of any particular IP implementation - they describe the interface protocol, not the internal logic of peripherals.

### simulatable_interface() Decorator

This decorator adds simulation model metadata for interface type identification:

```python
def simulatable_interface(base="com.chipflow.chipflow"):
    def decorate(klass):
        # Apply amaranth_annotate for SimInterface
        dec = amaranth_annotate(SimInterface, SIM_ANNOTATION_SCHEMA)
        klass = dec(klass)

        # Wrap __init__ to populate __chipflow_annotation__
        original_init = klass.__init__
        def new_init(self, *args, **kwargs):
            original_init(self, *args, **kwargs)
            self.__chipflow_annotation__ = {
                "uid": klass.__chipflow_uid__,
                "parameters": self.__chipflow_parameters__(),
            }

        klass.__init__ = new_init
        klass.__chipflow_uid__ = f"{base}.{klass.__name__}"
        if not hasattr(klass, '__chipflow_parameters__'):
            klass.__chipflow_parameters__ = lambda self: []

        return klass
    return decorate
```

**What it does:**

1. Applies `amaranth_annotate(SimInterface, ...)` to the class
2. Assigns a unique identifier (UID) like `"com.chipflow.chipflow.UARTSignature"`
3. Wraps `__init__` to populate `__chipflow_annotation__` with UID and parameters
4. Allows signatures to specify parameters via `__chipflow_parameters__()` method

### Example: UARTSignature

```python
@simulatable_interface()
class UARTSignature(wiring.Signature):
    def __init__(self, **kwargs: Unpack[IOModelOptions]):
        super().__init__({
            "tx": Out(OutputIOSignature(1, **kwargs)),
            "rx": Out(InputIOSignature(1, **kwargs)),
        })
```

**Annotations on this signature:**

1. `SIM_ANNOTATION_SCHEMA`: `{"uid": "com.chipflow.chipflow.UARTSignature", "parameters": []}`
2. Nested `IO_ANNOTATION_SCHEMA` on `tx` and `rx` sub-signatures

### Example: GPIOSignature with Parameters

```python
@simulatable_interface()
class GPIOSignature(wiring.Signature):
    def __init__(self, pin_count=1, **kwargs: Unpack[IOModelOptions]):
        self._pin_count = pin_count
        self._options = kwargs
        kwargs['individual_oe'] = True  # Force individual OE for GPIO
        super().__init__({
            "gpio": Out(BidirIOSignature(pin_count, **kwargs))
        })

    def __chipflow_parameters__(self):
        # Expose pin_count as a parameter for simulation models
        return [('pin_count', self._pin_count)]
```

**Annotations:**

1. `SIM_ANNOTATION_SCHEMA`: `{"uid": "...", "parameters": [["pin_count", 8]]}`
2. Nested `IO_ANNOTATION_SCHEMA` on `gpio` with `width=8, individual_oe=True`

### SoftwareDriverSignature

This signature wrapper attaches driver files to peripherals:

```python
class SoftwareDriverSignature(wiring.Signature):
    def __init__(self, members, **kwargs: Unpack[DriverModel]):
        # Extract base path from component's module file
        definition_file = sys.modules[kwargs['component'].__module__].__file__
        base_path = Path(definition_file).parent.absolute()
        kwargs['_base_path'] = base_path

        # Default to 'bus' if not specified
        if 'regs_bus' not in kwargs:
            kwargs['regs_bus'] = 'bus'

        # Convert generators to lists
        for k in ('c_files', 'h_files', 'include_dirs'):
            if k in kwargs:
                kwargs[k] = list(kwargs[k])

        # Store and annotate
        self.__chipflow_driver_model__ = kwargs
        amaranth_annotate(DriverModel, DRIVER_MODEL_SCHEMA,
                        '__chipflow_driver_model__', decorate_object=True)(self)

        super().__init__(members=members)
```

**DriverModel TypedDict:**

```python
class DriverModel(TypedDict):
    component: wiring.Component | dict  # Component metadata
    regs_struct: str                   # C struct name (e.g., "uart_regs_t")
    h_files: NotRequired[list[Path]]   # Header files
    c_files: NotRequired[list[Path]]   # C source files
    include_dirs: NotRequired[list[Path]]  # Include directories
    regs_bus: NotRequired[str]         # Bus member name (default: "bus")
    _base_path: NotRequired[Path]      # Auto-filled: peripheral's directory
```

**Example Usage in a Peripheral:**

```python
from chipflow.platform import UARTSignature, SoftwareDriverSignature
from amaranth_soc import csr

class UARTPeripheral(wiring.Component):
    def __init__(self, *, addr_width=5, data_width=8):
        super().__init__(
            SoftwareDriverSignature(
                members={
                    "bus": In(csr.Signature(addr_width=addr_width, data_width=data_width)),
                    "pins": Out(UARTSignature()),
                },
                component=self,
                regs_struct='uart_regs_t',
                c_files=['drivers/uart.c'],
                h_files=['drivers/uart.h']
            )
        )
```

### attach_data() Function

Attaches data (like `SoftwareBuild`) to both external and internal flash interfaces:

```python
def attach_data(external_interface: wiring.PureInterface,
               component: wiring.Component,
               data: DataclassProtocol):
    # Create Data annotation with the dataclass
    data_dict: Data = {'data': data}

    # Annotate both the component's signature and external interface
    for sig in (component.signature, external_interface.signature):
        setattr(sig, '__chipflow_data__', data_dict)
        amaranth_annotate(Data, DATA_SCHEMA, '__chipflow_data__',
                        decorate_object=True)(sig)
```

**Why annotate both?**

- External interface is visible at top-level for simulation testbench
- Internal component holds the implementation for software platform
- Both need access to the binary data for their respective purposes

## Platform Consumption

### Silicon Platform

Core Module: `chipflow/platform/silicon.py`

The silicon platform creates actual I/O ports from pin signatures.

**SiliconPlatformPort Class:**

```python
class SiliconPlatformPort(io.PortLike, Generic[Pin]):
    def __init__(self, name: str, port_desc: PortDesc):
        self.name = name
        self.port_desc = port_desc

        # Extract IOModel from port_desc
        iomodel = port_desc.iomodel
        direction = iomodel.direction
        width = iomodel.width
        invert = iomodel.get('invert', False)
        init = iomodel.get('init', 0)
        init_oe = iomodel.get('init_oe', 0)
        individual_oe = iomodel.get('individual_oe', False)

        # Create signals based on direction
        if direction in ("input", "bidir"):
            self.i = Signal(width, name=f"{name}__i")
        if direction in ("output", "bidir"):
            self.o = Signal(width, init=init, name=f"{name}__o")
            if individual_oe:
                self.oe = Signal(width, init=init_oe, name=f"{name}__oe")
            else:
                self.oe = Signal(1, init=init_oe, name=f"{name}__oe")

        # Store invert for wire_up
        self._invert = invert
```

**Port Creation from Pinlock:**

The platform reads the top-level signature and creates ports:

```python
# chipflow/platform/silicon.py (in SiliconPlatform.create_ports)
for key in top.signature.members.keys():
    member = getattr(top, key)
    port_desc = self._get_port_desc(member)  # Extracts IOModel from annotations
    port = Sky130Port(key, port_desc)
    self._ports[key] = port
```

**Sky130Port - Process-Specific Extension:**

```python
class Sky130Port(SiliconPlatformPort):
    _DriveMode_map = {
        Sky130DriveMode.STRONG_UP_WEAK_DOWN: 0b011,
        Sky130DriveMode.OPEN_DRAIN_STRONG_UP: 0b101,
        # ...
    }

    _VTrip_map = {
        IOTripPoint.CMOS: (0, 0),
        IOTripPoint.TTL: (0, 1),
        # ...
    }

    def __init__(self, name: str, port_desc: PortDesc):
        super().__init__(name, port_desc)

        # Extract Sky130-specific options
        iomodel = port_desc.iomodel
        drive_mode = iomodel.get('sky130_drive_mode', Sky130DriveMode.STRONG_UP_WEAK_DOWN)
        trip_point = iomodel.get('trip_point', IOTripPoint.CMOS)

        # Create configuration signals for Sky130 I/O cell
        self.dm = Const(self._DriveMode_map[drive_mode], 3)
        self.ib_mode_sel, self.vtrip_sel = self._VTrip_map[trip_point]
        # ... more Sky130-specific configuration
```

### Software Platform

Core Module: `chipflow/platform/software.py`

The software platform extracts driver models and builds software.

**SoftwarePlatform.build():**

```python
class SoftwarePlatform:
    def build(self, m, top):
        frag = Fragment.get(m, None)
        driver_models = {}
        roms = {}

        # Extract annotations from all top-level members
        for key in top.keys():
            for component, name, meta in submodule_metadata(frag, key):
                annotations = meta['annotations']

                # Extract driver models
                if DRIVER_MODEL_SCHEMA in annotations:
                    driver_models[name] = TypeAdapter(DriverModel).validate_python(
                        annotations[DRIVER_MODEL_SCHEMA]
                    )

                # Extract software builds
                if DATA_SCHEMA in annotations:
                    data = annotations[DATA_SCHEMA]
                    if data['data']['type'] == "SoftwareBuild":
                        roms[name] = TypeAdapter(SoftwareBuild).validate_python(
                            data['data']
                        )

        # Find wishbone decoder to get memory map
        wb_decoder = # ... find decoder
        windows = get_windows(wb_decoder)

        # Create software generator
        sw = SoftwareGenerator(...)

        # Add each peripheral with its driver
        for component, driver_model in driver_models.items():
            addr = windows[component][0][0]
            sw.add_periph(component, addr, driver_model)

        return {key: sw}
```

**SoftwareGenerator - Code Generation:**

Located in `chipflow/software/soft_gen.py`:

```python
class SoftwareGenerator:
    def add_periph(self, name, address, model: DriverModel):
        # Resolve driver file paths relative to peripheral's directory
        base_path = model['_base_path']
        for k in ('c_files', 'h_files', 'include_dirs'):
            if k in model:
                for p in model[k]:
                    if not p.is_absolute():
                        self._drivers[k].add(base_path / p)
                    else:
                        self._drivers[k].add(p)

        # Store peripheral info for soc.h generation
        component = model['component']['name']
        regs_struct = model['regs_struct']
        self._periphs.add(Periph(name, component, regs_struct, address))

    def generate(self):
        # Generate soc.h with peripheral #defines
        # Generate start.S with startup code
        # Generate sections.lds with memory layout
        pass
```

**Generated soc.h Example:**

```c
#ifndef SOC_H
#define SOC_H

#include "drivers/uart.h"
#include "drivers/gpio.h"

#define UART_0 ((volatile uart_regs_t *const)0x02000000)
#define GPIO_0 ((volatile gpio_regs_t *const)0x01000000)

#define putc(x) uart_putc(UART_0, x)
#define puts(x) uart_puts(UART_0, x)

#endif
```

## Complete Flow Example

Let’s trace a complete example from signature definition to platform usage.

### Step 1: Define a Peripheral with Driver

```python
# chipflow_digital_ip/io/_uart.py
from chipflow.platform import UARTSignature, SoftwareDriverSignature

class UARTPeripheral(wiring.Component):
    def __init__(self, *, init_divisor=0):
        super().__init__(
            SoftwareDriverSignature(
                members={
                    "bus": In(csr.Signature(addr_width=5, data_width=8)),
                    "pins": Out(UARTSignature()),  # <-- External interface
                },
                component=self,
                regs_struct='uart_regs_t',
                c_files=['drivers/uart.c'],
                h_files=['drivers/uart.h']
            )
        )
        # ... implementation
```

### Step 2: Use in Top-Level Design

```python
# design/design.py
class MySoC(wiring.Component):
    def __init__(self):
        super().__init__({
            "uart": Out(UARTSignature()),  # <-- Top-level interface
        })

    def elaborate(self, platform):
        m = Module()

        # Instantiate peripheral
        m.submodules.uart = uart = UARTPeripheral(init_divisor=217)

        # Connect to top-level
        connect(m, flipped(self.uart), uart.pins)

        return m
```

### Step 3: Annotations Applied

**On \`\`self.uart\`\` (top-level):**

- `SIM_ANNOTATION_SCHEMA`: `{"uid": "com.chipflow.chipflow.UARTSignature", "parameters": []}`
- `IO_ANNOTATION_SCHEMA` on `tx`: `{"direction": "output", "width": 1, ...}`
- `IO_ANNOTATION_SCHEMA` on `rx`: `{"direction": "input", "width": 1, ...}`

**On \`\`uart.signature\`\` (peripheral):**

- `DRIVER_MODEL_SCHEMA`:
  ```json
  {
    "component": {"name": "UARTPeripheral", "file": "/path/to/_uart.py"},
    "regs_struct": "uart_regs_t",
    "c_files": ["drivers/uart.c"],
    "h_files": ["drivers/uart.h"],
    "regs_bus": "bus",
    "_base_path": "/path/to/chipflow_digital_ip/io"
  }
  ```
- Same simulation and I/O annotations on nested `pins` member

### Step 4: Silicon Platform Consumption

```python
# During silicon elaboration
silicon_platform = SiliconPlatform(config)

# Creates Sky130Port for "uart"
port = Sky130Port("uart", port_desc_from_annotations)

# port.tx.o, port.tx.oe created as signals
# port.rx.i created as signal
# Configuration based on IOModel (drive modes, trip points)
```

### Step 5: Software Platform Consumption

```python
# During software build
software_platform = SoftwarePlatform(config)
generators = software_platform.build(m, top)

# Extracts DriverModel from uart.signature annotations
# Adds peripheral to SoftwareGenerator:
#   name="uart", addr=0x02000000, driver_model={...}

# Generates soc.h:
#   #include "drivers/uart.h"
#   #define UART ((volatile uart_regs_t *const)0x02000000)
```

### Step 6: User Software Uses Generated API

```c
// user_code.c
#include "soc.h"

void main() {
    uart_init(UART, 217);  // Uses generated UART pointer
    uart_puts(UART, "Hello from ChipFlow!\n");
}
```

## Adding New Pin Signatures

To add a new pin signature type:

1. **Define the signature class:**
   ```python
   @simulatable_interface()
   class MyNewSignature(wiring.Signature):
       def __init__(self, param1, param2, **kwargs: Unpack[IOModelOptions]):
           self._param1 = param1
           self._param2 = param2
           super().__init__({
               "signal1": Out(OutputIOSignature(width1, **kwargs)),
               "signal2": Out(InputIOSignature(width2, **kwargs)),
           })

       def __chipflow_parameters__(self):
           return [('param1', self._param1), ('param2', self._param2)]
   ```
2. **Add to exports in** `chipflow/platform/__init__.py`
3. **Add to re-export in** `chipflow/platforms/__init__.py` (for backward compatibility)
4. **Create simulation model** (if needed) matching the UID
5. **Update documentation** in `docs/using-pin-signatures.rst`

## Adding Custom Platform Backends

To add a new platform that consumes annotations:

1. **Import annotation infrastructure:**
   ```python
   from chipflow.platform.io.annotate import submodule_metadata
   from chipflow.platform.io.signatures import DRIVER_MODEL_SCHEMA, SIM_ANNOTATION_SCHEMA
   from pydantic import TypeAdapter
   ```
2. **Walk the design and extract annotations:**
   ```python
   frag = Fragment.get(m, None)
   for component, name, meta in submodule_metadata(frag, "top"):
       annotations = meta['annotations']

       # Check for your schema
       if MY_SCHEMA_ID in annotations:
           my_data = TypeAdapter(MyModel).validate_python(annotations[MY_SCHEMA_ID])
           # Process my_data...
   ```
3. **Use the extracted data** for your platform-specific operations

## JSON Schema Integration

All annotations generate JSON schemas that are:

- Embedded in RTLIL `(* chipflow.annotation.{schema_id} *)` attributes
- Validated using JSON Schema Draft 2020-12
- Accessible to external tools via RTLIL parsing

**Schema URI Convention:**

```python
from chipflow.platform.io.iosignature import _chipflow_schema_uri

# Generates: "https://chipflow.com/schemas/my-thing/v0"
MY_SCHEMA = str(_chipflow_schema_uri("my-thing", 0))
```

**Pydantic Integration:**

Pydantic’s `TypeAdapter` provides:

- Automatic JSON schema generation from `TypedDict`
- Runtime validation when deserializing
- Type hints for IDE support
- Serialization to JSON-compatible Python dicts

## Key Files

- `chipflow/platform/io/annotate.py` - Core annotation infrastructure
- `chipflow/platform/io/iosignature.py` - I/O signature base classes
- `chipflow/platform/io/signatures.py` - Concrete signatures and decorators
- `chipflow/platform/silicon.py` - Silicon platform consumption
- `chipflow/platform/software.py` - Software platform consumption
- `chipflow/software/soft_gen.py` - Code generation

## See Also

- using-pin-signatures - User-facing guide for using pin signatures


# crc.html.md

# Cyclic redundancy checks

The [`amaranth.lib.crc`](#module-amaranth.lib.crc) module provides facilities for computing cyclic redundancy checks (CRCs)
in software and in hardware.

## Introduction

The essentials of a CRC computation are specified with an [`Algorithm`](#amaranth.lib.crc.Algorithm) object, which defines
CRC width, polynomial, initial value, input/output reflection, and output XOR. Many commonly used
CRC algorithms are available in the [`catalog`](crc/catalog.md#module-amaranth.lib.crc.catalog) module, while most other
CRC designs can be accommodated by manually constructing an [`Algorithm`](#amaranth.lib.crc.Algorithm).

An [`Algorithm`](#amaranth.lib.crc.Algorithm) is specialized for a particular data width to obtain [`Parameters`](#amaranth.lib.crc.Parameters),
which fully define a CRC computation. [`Parameters.compute()`](#amaranth.lib.crc.Parameters.compute) computes a CRC in software, while
[`Parameters.create()`](#amaranth.lib.crc.Parameters.create) creates a [`Processor`](#amaranth.lib.crc.Processor) that computes a CRC in hardware.

## Examples

<!-- from amaranth import *

m = Module() -->
```python
from amaranth.lib.crc import Algorithm
from amaranth.lib.crc.catalog import CRC16_CCITT, CRC16_USB


# Compute a CRC in hardware using the predefined CRC16-CCITT algorithm and a data word
# width of 8 bits (in other words, computing it over bytes).
m.submodules.crc16_ccitt = crc16_ccitt = CRC16_CCITT().create()

# Compute a CRC in hardware using the predefined CRC16-USB algorithm and a data word
# width of 32 bits.
m.submodules.crc16_usb = crc16_usb = CRC16_USB(32).create()

# Compute a CRC in software using a custom CRC algorithm and explicitly specified data word
# width.
algo = Algorithm(crc_width=16, polynomial=0x1021, initial_crc=0xffff,
    reflect_input=False, reflect_output=False, xor_output=0x0000)
assert algo(data_width=8).compute(b"123456789") == 0x29b1
```

## Algorithms and parameters

### *class* amaranth.lib.crc.Algorithm(\*, crc_width, polynomial, initial_crc, reflect_input, reflect_output, xor_output)

Essential parameters for cyclic redundancy check computation.

The parameter set is based on the Williams model from [“A Painless Guide to CRC Error Detection
Algorithms”](http://www.ross.net/crc/download/crc_v3.txt).

For a reference of standard CRC parameter sets, refer to:

* [reveng](https://reveng.sourceforge.io/crc-catalogue/all.htm)’s catalogue, which uses an identical parameterisation;
* [crcmod](https://crcmod.sourceforge.net/crcmod.predefined.html)’s list of predefined functions, but remove the leading ‘1’ from the polynominal,
  XOR the “Init-value” with “XOR-out” to obtain `initial_crc`, and where “Reversed” is
  `True`, set both `reflect_input` and `reflect_output` to `True`;
* [CRC Zoo](https://users.ece.cmu.edu/~koopman/crc/), which contains only polynomials; use the “explicit +1” form of polynomial but
  remove the leading ‘1’.

Many commonly used CRC algorithms are available in the [`catalog`](crc/catalog.md#module-amaranth.lib.crc.catalog)
module, which includes all entries in the [reveng catalogue](https://reveng.sourceforge.io/crc-catalogue/all.htm).

The essential parameters on their own cannot be used to perform CRC computation, and must be
combined with a specific data word width. This can be done using `algo(data_width)`, which
returns a [`Parameters`](#amaranth.lib.crc.Parameters) object.

* **Parameters:**
  * **crc_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Bit width of CRC word. Also known as “width” in the Williams model.
  * **polynomial** ([`int`](https://docs.python.org/3/library/functions.html#int)) – CRC polynomial to use, `crc_width` bits long, without the implicit `x ** crc_width`
    term. Polynomial is always specified with the highest order terms in the most significant
    bit positions; use `reflect_input` and `reflect_output` to perform a least
    significant bit first computation.
  * **initial_crc** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Initial value of CRC register at reset. Most significant bit always corresponds to
    the highest order term in the CRC register.
  * **reflect_input** ([`bool`](https://docs.python.org/3/library/functions.html#bool)) – If `True`, the input data words are bit-reflected, so that they are processed least
    significant bit first.
  * **reflect_output** ([`bool`](https://docs.python.org/3/library/functions.html#bool)) – If `True`, the output CRC is bit-reflected, so that the least-significant bit of
    the output is the highest-order bit of the CRC register. Note that this reflection is
    performed over the entire CRC register; for transmission you may want to treat the output
    as a little-endian multi-word value, so for example the reflected 16-bit output `0x4E4C`
    would be transmitted as the two octets `0x4C, 0x4E`, each transmitted least significant
    bit first.
  * **xor_output** ([`int`](https://docs.python.org/3/library/functions.html#int)) – The output CRC will be the CRC register XOR’d with this value, applied after any output
    bit-reflection.

#### \_\_call_\_(data_width=8)

Combine these essential parameters with a data word width to form complete parameters.

* **Returns:**
  `Parameters(self, data_width)`
* **Return type:**
  [`Parameters`](#amaranth.lib.crc.Parameters)

### *class* amaranth.lib.crc.Parameters(algorithm, data_width=8)

Complete parameters for cyclic redundancy check computation.

Contains the essential [`Algorithm`](#amaranth.lib.crc.Algorithm) parameters, plus the data word width.

A [`Parameters`](#amaranth.lib.crc.Parameters) object can be used to directly compute CRCs using
the [`compute()`](#amaranth.lib.crc.Parameters.compute) method, or to construct a hardware module using
the [`create()`](#amaranth.lib.crc.Parameters.create) method.

* **Parameters:**
  * **algorithm** ([`Algorithm`](#amaranth.lib.crc.Algorithm)) – CRC algorithm to use. Specifies the CRC width, polynomial, initial value, whether to
    reflect the input or output words, and any output XOR.
  * **data_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Bit width of data words.

#### residue()

Obtain the residual value left in the CRC register after processing a valid trailing CRC.

#### compute(data)

Compute the CRC of all data words in `data`.

* **Parameters:**
  **data** (iterable of [`int`](https://docs.python.org/3/library/functions.html#int)) – Data words, each of which is `data_width` bits wide.

#### create()

Create a hardware CRC generator with these parameters.

* **Returns:**
  `Processor(self)`
* **Return type:**
  [`Processor`](#amaranth.lib.crc.Processor)

## CRC computation

### *class* amaranth.lib.crc.Processor

Hardware cyclic redundancy check generator.

This module generates CRCs from an input data stream, which can be used to validate an existing
CRC or generate a new CRC. It is configured by the [`Parameters`](#amaranth.lib.crc.Parameters) class, which can handle
most types of CRCs.

The CRC value is updated on any clock cycle where `valid` is asserted, with the updated
value available on the `crc` output on the subsequent clock cycle. The latency is therefore
one clock cycle, and the throughput is one data word per clock cycle.

The CRC is reset to its initial value whenever `start` is asserted. `start` and
`valid` may be asserted on the same clock cycle, in which case a new CRC computation is
started with the current value of data.

When `data_width` is 1, a classic bit-serial CRC is implemented for the given polynomial
in a Galois-type shift register. For larger values of `data_width`, a similar architecture
computes every new bit of the CRC in parallel.

The `match_detected` output may be used to validate data with a trailing CRC (also known as
a codeword in coding theory). If the most recently processed data word(s) form the valid CRC of
all the previous data words since `start` was asserted, the CRC register will always take on
a fixed value known as the [`residue`](#amaranth.lib.crc.Parameters.residue). The `match_detected` output
indicates whether the CRC register currently contains this residue.

* **Parameters:**
  **parameters** ([`Parameters`](#amaranth.lib.crc.Parameters)) – Parameters used for computation.
* **Attributes:**
  * **start** (*Signal(), in*) – Assert to indicate the start of a CRC computation, re-initialising the CRC register to
    the initial value. May be asserted simultaneously with `valid` or by itself.
  * **data** (*Signal(data_width), in*) – Data word to add to CRC when `valid` is asserted.
  * **valid** (*Signal(), in*) – Assert when `data` is valid to add the data word to the CRC.
  * **crc** (*Signal(crc_width), out*) – Registered CRC output value, updated one clock cycle after `valid` becomes asserted.
  * **match_detected** (*Signal(), out*) – Asserted if the current CRC value indicates a valid codeword has been received.

## Predefined algorithms

The following predefined CRC algorithms are available:

* [Algorithm catalog](crc/catalog.md)
  * [`CRC3_GSM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC3_GSM)
  * [`CRC3_ROHC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC3_ROHC)
  * [`CRC4_G_704`](crc/catalog.md#amaranth.lib.crc.catalog.CRC4_G_704)
  * [`CRC4_ITU`](crc/catalog.md#amaranth.lib.crc.catalog.CRC4_ITU)
  * [`CRC4_INTERLAKEN`](crc/catalog.md#amaranth.lib.crc.catalog.CRC4_INTERLAKEN)
  * [`CRC5_EPC_C1G2`](crc/catalog.md#amaranth.lib.crc.catalog.CRC5_EPC_C1G2)
  * [`CRC5_EPC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC5_EPC)
  * [`CRC5_G_704`](crc/catalog.md#amaranth.lib.crc.catalog.CRC5_G_704)
  * [`CRC5_ITU`](crc/catalog.md#amaranth.lib.crc.catalog.CRC5_ITU)
  * [`CRC5_USB`](crc/catalog.md#amaranth.lib.crc.catalog.CRC5_USB)
  * [`CRC6_CDMA2000_A`](crc/catalog.md#amaranth.lib.crc.catalog.CRC6_CDMA2000_A)
  * [`CRC6_CDMA2000_B`](crc/catalog.md#amaranth.lib.crc.catalog.CRC6_CDMA2000_B)
  * [`CRC6_DARC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC6_DARC)
  * [`CRC6_G_704`](crc/catalog.md#amaranth.lib.crc.catalog.CRC6_G_704)
  * [`CRC6_ITU`](crc/catalog.md#amaranth.lib.crc.catalog.CRC6_ITU)
  * [`CRC6_GSM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC6_GSM)
  * [`CRC7_MMC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC7_MMC)
  * [`CRC7_ROHC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC7_ROHC)
  * [`CRC7_UMTS`](crc/catalog.md#amaranth.lib.crc.catalog.CRC7_UMTS)
  * [`CRC8_AUTOSAR`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_AUTOSAR)
  * [`CRC8_BLUETOOTH`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_BLUETOOTH)
  * [`CRC8_CDMA2000`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_CDMA2000)
  * [`CRC8_DARC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_DARC)
  * [`CRC8_DVB_S2`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_DVB_S2)
  * [`CRC8_GSM_A`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_GSM_A)
  * [`CRC8_GSM_B`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_GSM_B)
  * [`CRC8_HITAG`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_HITAG)
  * [`CRC8_I_432_1`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_I_432_1)
  * [`CRC8_ITU`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_ITU)
  * [`CRC8_I_CODE`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_I_CODE)
  * [`CRC8_LTE`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_LTE)
  * [`CRC8_MAXIM_DOW`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_MAXIM_DOW)
  * [`CRC8_MAXIM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_MAXIM)
  * [`CRC8_MIFARE_MAD`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_MIFARE_MAD)
  * [`CRC8_NRSC_5`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_NRSC_5)
  * [`CRC8_OPENSAFETY`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_OPENSAFETY)
  * [`CRC8_ROHC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_ROHC)
  * [`CRC8_SAE_J1850`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_SAE_J1850)
  * [`CRC8_SMBUS`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_SMBUS)
  * [`CRC8_TECH_3250`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_TECH_3250)
  * [`CRC8_AES`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_AES)
  * [`CRC8_ETU`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_ETU)
  * [`CRC8_WCDMA`](crc/catalog.md#amaranth.lib.crc.catalog.CRC8_WCDMA)
  * [`CRC10_ATM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC10_ATM)
  * [`CRC10_I_610`](crc/catalog.md#amaranth.lib.crc.catalog.CRC10_I_610)
  * [`CRC10_CDMA2000`](crc/catalog.md#amaranth.lib.crc.catalog.CRC10_CDMA2000)
  * [`CRC10_GSM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC10_GSM)
  * [`CRC11_FLEXRAY`](crc/catalog.md#amaranth.lib.crc.catalog.CRC11_FLEXRAY)
  * [`CRC11_UMTS`](crc/catalog.md#amaranth.lib.crc.catalog.CRC11_UMTS)
  * [`CRC12_CDMA2000`](crc/catalog.md#amaranth.lib.crc.catalog.CRC12_CDMA2000)
  * [`CRC12_DECT`](crc/catalog.md#amaranth.lib.crc.catalog.CRC12_DECT)
  * [`CRC12_GSM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC12_GSM)
  * [`CRC12_UMTS`](crc/catalog.md#amaranth.lib.crc.catalog.CRC12_UMTS)
  * [`CRC12_3GPP`](crc/catalog.md#amaranth.lib.crc.catalog.CRC12_3GPP)
  * [`CRC13_BBC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC13_BBC)
  * [`CRC14_DARC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC14_DARC)
  * [`CRC14_GSM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC14_GSM)
  * [`CRC15_CAN`](crc/catalog.md#amaranth.lib.crc.catalog.CRC15_CAN)
  * [`CRC15_MPT1327`](crc/catalog.md#amaranth.lib.crc.catalog.CRC15_MPT1327)
  * [`CRC16_ARC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_ARC)
  * [`CRC16_IBM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_IBM)
  * [`CRC16_CDMA2000`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_CDMA2000)
  * [`CRC16_CMS`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_CMS)
  * [`CRC16_DDS_110`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_DDS_110)
  * [`CRC16_DECT_R`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_DECT_R)
  * [`CRC16_DECT_X`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_DECT_X)
  * [`CRC16_DNP`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_DNP)
  * [`CRC16_EN_13757`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_EN_13757)
  * [`CRC16_GENIBUS`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_GENIBUS)
  * [`CRC16_DARC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_DARC)
  * [`CRC16_EPC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_EPC)
  * [`CRC16_EPC_C1G2`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_EPC_C1G2)
  * [`CRC16_I_CODE`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_I_CODE)
  * [`CRC16_GSM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_GSM)
  * [`CRC16_IBM_3740`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_IBM_3740)
  * [`CRC16_AUTOSAR`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_AUTOSAR)
  * [`CRC16_CCITT_FALSE`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_CCITT_FALSE)
  * [`CRC16_IBM_SDLC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_IBM_SDLC)
  * [`CRC16_ISO_HDLC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_ISO_HDLC)
  * [`CRC16_ISO_IEC_14443_3_B`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_ISO_IEC_14443_3_B)
  * [`CRC16_X25`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_X25)
  * [`CRC16_ISO_IEC_14443_3_A`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_ISO_IEC_14443_3_A)
  * [`CRC16_KERMIT`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_KERMIT)
  * [`CRC16_BLUETOOTH`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_BLUETOOTH)
  * [`CRC16_CCITT`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_CCITT)
  * [`CRC16_CCITT_TRUE`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_CCITT_TRUE)
  * [`CRC16_V_41_LSB`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_V_41_LSB)
  * [`CRC16_LJ1200`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_LJ1200)
  * [`CRC16_M17`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_M17)
  * [`CRC16_MAXIM_DOW`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_MAXIM_DOW)
  * [`CRC16_MAXIM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_MAXIM)
  * [`CRC16_MCRF4XX`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_MCRF4XX)
  * [`CRC16_MODBUS`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_MODBUS)
  * [`CRC16_NRSC_5`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_NRSC_5)
  * [`CRC16_OPENSAFETY_A`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_OPENSAFETY_A)
  * [`CRC16_OPENSAFETY_B`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_OPENSAFETY_B)
  * [`CRC16_PROFIBUS`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_PROFIBUS)
  * [`CRC16_IEC_61158_2`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_IEC_61158_2)
  * [`CRC16_RIELLO`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_RIELLO)
  * [`CRC16_SPI_FUJITSU`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_SPI_FUJITSU)
  * [`CRC16_AUG_CCITT`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_AUG_CCITT)
  * [`CRC16_T10_DIF`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_T10_DIF)
  * [`CRC16_TELEDISK`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_TELEDISK)
  * [`CRC16_TMS37157`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_TMS37157)
  * [`CRC16_UMTS`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_UMTS)
  * [`CRC16_BUYPASS`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_BUYPASS)
  * [`CRC16_VERIFONE`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_VERIFONE)
  * [`CRC16_USB`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_USB)
  * [`CRC16_XMODEM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_XMODEM)
  * [`CRC16_ACORN`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_ACORN)
  * [`CRC16_LTE`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_LTE)
  * [`CRC16_V_41_MSB`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_V_41_MSB)
  * [`CRC16_ZMODEM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC16_ZMODEM)
  * [`CRC17_CAN_FD`](crc/catalog.md#amaranth.lib.crc.catalog.CRC17_CAN_FD)
  * [`CRC21_CAN_FD`](crc/catalog.md#amaranth.lib.crc.catalog.CRC21_CAN_FD)
  * [`CRC24_BLE`](crc/catalog.md#amaranth.lib.crc.catalog.CRC24_BLE)
  * [`CRC24_FLEXRAY_A`](crc/catalog.md#amaranth.lib.crc.catalog.CRC24_FLEXRAY_A)
  * [`CRC24_FLEXRAY_B`](crc/catalog.md#amaranth.lib.crc.catalog.CRC24_FLEXRAY_B)
  * [`CRC24_INTERLAKEN`](crc/catalog.md#amaranth.lib.crc.catalog.CRC24_INTERLAKEN)
  * [`CRC24_LTE_A`](crc/catalog.md#amaranth.lib.crc.catalog.CRC24_LTE_A)
  * [`CRC24_LTE_B`](crc/catalog.md#amaranth.lib.crc.catalog.CRC24_LTE_B)
  * [`CRC24_OPENPGP`](crc/catalog.md#amaranth.lib.crc.catalog.CRC24_OPENPGP)
  * [`CRC24_OS_9`](crc/catalog.md#amaranth.lib.crc.catalog.CRC24_OS_9)
  * [`CRC30_CDMA`](crc/catalog.md#amaranth.lib.crc.catalog.CRC30_CDMA)
  * [`CRC31_PHILIPS`](crc/catalog.md#amaranth.lib.crc.catalog.CRC31_PHILIPS)
  * [`CRC32_AIXM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_AIXM)
  * [`CRC32_AUTOSAR`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_AUTOSAR)
  * [`CRC32_BASE91_D`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_BASE91_D)
  * [`CRC32_BZIP2`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_BZIP2)
  * [`CRC32_AAL5`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_AAL5)
  * [`CRC32_DECT_B`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_DECT_B)
  * [`CRC32_CD_ROM_EDC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_CD_ROM_EDC)
  * [`CRC32_CKSUM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_CKSUM)
  * [`CRC32_POSIX`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_POSIX)
  * [`CRC32_ISCSI`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_ISCSI)
  * [`CRC32_BASE91_C`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_BASE91_C)
  * [`CRC32_CASTAGNOLI`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_CASTAGNOLI)
  * [`CRC32_INTERLAKEN`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_INTERLAKEN)
  * [`CRC32_ISO_HDLC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_ISO_HDLC)
  * [`CRC32_ADCCP`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_ADCCP)
  * [`CRC32_V_42`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_V_42)
  * [`CRC32_XZ`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_XZ)
  * [`CRC32_PKZIP`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_PKZIP)
  * [`CRC32_ETHERNET`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_ETHERNET)
  * [`CRC32_JAMCRC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_JAMCRC)
  * [`CRC32_MEF`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_MEF)
  * [`CRC32_MPEG_2`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_MPEG_2)
  * [`CRC32_XFER`](crc/catalog.md#amaranth.lib.crc.catalog.CRC32_XFER)
  * [`CRC40_GSM`](crc/catalog.md#amaranth.lib.crc.catalog.CRC40_GSM)
  * [`CRC64_ECMA_182`](crc/catalog.md#amaranth.lib.crc.catalog.CRC64_ECMA_182)
  * [`CRC64_GO_ISO`](crc/catalog.md#amaranth.lib.crc.catalog.CRC64_GO_ISO)
  * [`CRC64_MS`](crc/catalog.md#amaranth.lib.crc.catalog.CRC64_MS)
  * [`CRC64_REDIS`](crc/catalog.md#amaranth.lib.crc.catalog.CRC64_REDIS)
  * [`CRC64_WE`](crc/catalog.md#amaranth.lib.crc.catalog.CRC64_WE)
  * [`CRC64_XZ`](crc/catalog.md#amaranth.lib.crc.catalog.CRC64_XZ)
  * [`CRC64_ECMA`](crc/catalog.md#amaranth.lib.crc.catalog.CRC64_ECMA)
  * [`CRC82_DARC`](crc/catalog.md#amaranth.lib.crc.catalog.CRC82_DARC)


# csr.html.md

# CSR

* [CSR bus](csr/bus.md)
  * [Introduction](csr/bus.md#introduction)
  * [Examples](csr/bus.md#examples)
  * [Register interfaces](csr/bus.md#register-interfaces)
  * [Bus interfaces](csr/bus.md#bus-interfaces)
  * [Bus primitives](csr/bus.md#bus-primitives)
* [CSR registers](csr/reg.md)
  * [Introduction](csr/reg.md#introduction)
  * [Examples](csr/reg.md#examples)
  * [Fields](csr/reg.md#fields)
  * [Field actions](csr/reg.md#field-actions)
  * [Registers](csr/reg.md#registers)
* [CSR fields](csr/action.md)
  * [Basic fields](csr/action.md#basic-fields)
  * [Flag fields](csr/action.md#flag-fields)
  * [Reserved fields](csr/action.md#reserved-fields)


# data.html.md

# Data structures

The [`amaranth.lib.data`](#module-amaranth.lib.data) module provides a way to describe the bitwise layout of values and a proxy class for accessing fields of values using the attribute access and indexing syntax.

## Introduction

### Overview

This module provides four related facilities:

1. Low-level bitwise layout description via [`Field`](#amaranth.lib.data.Field) and [`Layout`](#amaranth.lib.data.Layout). These classes are rarely used directly, but are the foundation on which all other functionality is built. They are also useful for introspection.
2. High-level bitwise layout description via [`StructLayout`](#amaranth.lib.data.StructLayout), [`UnionLayout`](#amaranth.lib.data.UnionLayout), [`ArrayLayout`](#amaranth.lib.data.ArrayLayout), and [`FlexibleLayout`](#amaranth.lib.data.FlexibleLayout). These classes are the ones most often used directly, in particular [`StructLayout`](#amaranth.lib.data.StructLayout) and [`ArrayLayout`](#amaranth.lib.data.ArrayLayout).
3. Data views via [`View`](#amaranth.lib.data.View) or its user-defined subclasses. This class is used to apply a layout description to a plain `Value`, enabling structured access to its bits.
4. Data classes [`Struct`](#amaranth.lib.data.Struct) and [`Union`](#amaranth.lib.data.Union). These classes are data views with a layout that is defined using Python [variable annotations](https://docs.python.org/3/glossary.html#term-variable-annotation) (also known as type annotations).

To use this module, add the following imports to the beginning of the file:

```python
from amaranth.lib import data
```

### Motivation

The fundamental Amaranth type is a `Value`: a sequence of bits that can also be used as a number. Manipulating values directly is sufficient for simple applications, but in more complex ones, values are often more than just a sequence of bits; they have well-defined internal structure.

<!-- from amaranth import *
m = Module() -->

For example, consider a module that processes pixels, converting them from RGB to grayscale. The color pixel format is RGB565:

This module could be implemented (using a fast but *very* approximate method) as follows:

```python
i_color = Signal(16)
o_gray  = Signal(8)

m.d.comb += o_gray.eq((i_color[0:5] + i_color[5:11] + i_color[11:16]) << 1)
```

While this implementation works, it is repetitive, error-prone, hard to read, and laborous to change; all because the color components are referenced using bit offsets. To improve it, the structure can be described with a [`Layout`](#amaranth.lib.data.Layout) so that the components can be referenced by name:

```python
from amaranth.lib import data, enum

rgb565_layout = data.StructLayout({
    "red":   5,
    "green": 6,
    "blue":  5
})

i_color = Signal(rgb565_layout)
o_gray  = Signal(8)

m.d.comb += o_gray.eq((i_color.red + i_color.green + i_color.blue) << 1)
```

The [`View`](#amaranth.lib.data.View) is [value-like](../guide.md#lang-valuelike) and can be used anywhere a plain value can be used. For example, it can be assigned to in the usual way:

```python
m.d.comb += i_color.eq(0) # everything is black
```

### Composing layouts

Layouts are composable: a [`Layout`](#amaranth.lib.data.Layout) is a [shape](../guide.md#lang-shapes) and can be used as a part of another layout. In this case, an attribute access through a view returns a view as well.

For example, consider a module that processes RGB pixels in groups of up to four at a time, provided by another module, and accumulates their average intensity:

```python
input_layout = data.StructLayout({
    "pixels": data.ArrayLayout(rgb565_layout, 4),
    "valid":  4
})

i_stream = Signal(input_layout)
r_accum  = Signal(32)

m.d.sync += r_accum.eq(
    r_accum + sum((i_stream.pixels[n].red +
                   i_stream.pixels[n].green +
                   i_stream.pixels[n].blue)
                  * i_stream.valid[n]
                  for n in range(len(i_stream.valid))))
```

Note how the width of `i_stream` is never defined explicitly; it is instead inferred from the shapes of its fields.

In the previous section, the precise bitwise layout was important, since RGB565 is an interchange format. In this section however the exact bit positions do not matter, since the layout is only used internally to communicate between two modules in the same design. It is sufficient that both of them use the same layout.

### Defining layouts

Data layouts can be defined in a few different ways depending on the use case.

In case the data format is defined using a family of layouts instead of a single specific one, a function can be used:

```python
def rgb_layout(r_bits, g_bits, b_bits):
    return data.StructLayout({
        "red":   unsigned(r_bits),
        "green": unsigned(g_bits),
        "blue":  unsigned(b_bits)
    })

rgb565_layout = rgb_layout(5, 6, 5)
rgb24_layout  = rgb_layout(8, 8, 8)
```

In case the data has related operations or transformations, [`View`](#amaranth.lib.data.View) can be subclassed to define methods implementing them:

```python
class RGBLayout(data.StructLayout):
    def __init__(self, r_bits, g_bits, b_bits):
        super().__init__({
            "red":   unsigned(r_bits),
            "green": unsigned(g_bits),
            "blue":  unsigned(b_bits)
        })

    def __call__(self, value):
        return RGBView(self, value)

class RGBView(data.View):
    def brightness(self):
        return (self.red + self.green + self.blue)[-8:]
```

Here, the `RGBLayout` class itself is [shape-like](../guide.md#lang-shapelike) and can be used anywhere a shape is accepted. When a `Signal` is constructed with this layout, the returned value is wrapped in an `RGBView`:

```pycon
>>> pixel = Signal(RGBLayout(5, 6, 5))
>>> len(pixel.as_value())
16
>>> pixel.red
(slice (sig pixel) 0:5)
```

In case the data format is static, [`Struct`](#amaranth.lib.data.Struct) (or [`Union`](#amaranth.lib.data.Union)) can be subclassed instead of [`View`](#amaranth.lib.data.View), to reduce the amount of boilerplate needed:

```python
class IEEE754Single(data.Struct):
    fraction: 23
    exponent:  8 = 0x7f
    sign:      1

    def is_subnormal(self):
        return self.exponent == 0
```

### Discriminated unions

This module provides a [`UnionLayout`](#amaranth.lib.data.UnionLayout), which is rarely needed by itself, but is very useful in combination with a *discriminant*: a enumeration indicating which field of the union contains valid data.

For example, consider a module that can direct another module to perform one of a few operations, each of which requires its own parameters. The two modules could communicate through a channel with a layout like this:

```python
class Command(data.Struct):
    class Kind(enum.Enum):
        SET_ADDR  = 0
        SEND_DATA = 1

    valid  : 1
    kind   : Kind
    params : data.UnionLayout({
        "set_addr": data.StructLayout({
            "addr": unsigned(32)
        }),
        "send_data": data.StructLayout({
            "byte": unsigned(8)
        })
    })
```

Here, the shape of the `Command` is inferred, being large enough to accommodate the biggest of all defined parameter structures, and it is not necessary to manage it manually.

One module could submit a command with:

```python
cmd = Signal(Command)

m.d.comb += [
    cmd.valid.eq(1),
    cmd.kind.eq(Command.Kind.SET_ADDR),
    cmd.params.set_addr.addr.eq(0x00001234)
]
```

The other would react to commands as follows:

```python
addr = Signal(32)

with m.If(cmd.valid):
    with m.Switch(cmd.kind):
        with m.Case(Command.Kind.SET_ADDR):
            m.d.sync += addr.eq(cmd.params.set_addr.addr)
        with m.Case(Command.Kind.SEND_DATA):
           ...
```

## Modeling structured data

### *class* amaranth.lib.data.Field(shape, offset)

Description of a data field.

The [`Field`](#amaranth.lib.data.Field) class specifies the signedness and bit positions of a field in
an Amaranth value.

[`Field`](#amaranth.lib.data.Field) objects are immutable.

* **Attributes:**
  * **shape** ([`ShapeLike`](../reference.md#amaranth.hdl.ShapeLike)) – Shape of the field. When initialized or assigned, the object is stored as-is.
  * **offset** ([`int`](https://docs.python.org/3/library/functions.html#int), >=0) – Index of the least significant bit of the field.

#### *property* width

Width of the field.

This property should be used over `self.shape.width` because `self.shape` can be
an arbitrary [shape-like](../guide.md#lang-shapelike) object, which may not have
a `width` property.

* **Returns:**
  `Shape.cast(self.shape).width`
* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

#### \_\_eq_\_(other)

Compare fields.

Two fields are equal if they have the same shape and offset.

### *class* amaranth.lib.data.Layout

Description of a data layout.

The [shape-like](../guide.md#lang-shapelike) [`Layout`](#amaranth.lib.data.Layout) interface associates keys
(string names or integer indexes) with fields, giving identifiers to spans of bits in
an Amaranth value.

It is an abstract base class; [`StructLayout`](#amaranth.lib.data.StructLayout), [`UnionLayout`](#amaranth.lib.data.UnionLayout),
[`ArrayLayout`](#amaranth.lib.data.ArrayLayout), and [`FlexibleLayout`](#amaranth.lib.data.FlexibleLayout) implement concrete layout rules.
New layout rules can be defined by inheriting from this class.

Like all other shape-castable objects, all layouts are immutable. New classes deriving from
[`Layout`](#amaranth.lib.data.Layout) must preserve this invariant.

#### *static* cast(obj)

Cast a [shape-like](../guide.md#lang-shapelike) object to a layout.

This method performs a subset of the operations done by [`Shape.cast()`](../reference.md#amaranth.hdl.Shape.cast); it will
recursively call `.as_shape()`, but only until a layout is returned.

* **Raises:**
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `obj` cannot be converted to a [`Layout`](#amaranth.lib.data.Layout) instance.
  * [**RecursionError**](https://docs.python.org/3/library/exceptions.html#RecursionError) – If `obj.as_shape()` returns `obj`.

#### *abstract* \_\_iter_\_()

Iterate fields in the layout.

* **Yields:**
  * [`str`](https://docs.python.org/3/library/stdtypes.html#str) or [`int`](https://docs.python.org/3/library/functions.html#int) – Key (either name or index) for accessing the field.
  * [`Field`](#amaranth.lib.data.Field) – Description of the field.

#### *abstract* \_\_getitem_\_(key)

Retrieve a field from the layout.

* **Returns:**
  The field associated with `key`.
* **Return type:**
  [`Field`](#amaranth.lib.data.Field)
* **Raises:**
  [**KeyError**](https://docs.python.org/3/library/exceptions.html#KeyError) – If there is no field associated with `key`.

#### *abstract property* size

Size of the layout.

* **Returns:**
  The amount of bits required to store every field in the layout.
* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

#### as_shape()

Shape of the layout.

* **Returns:**
  `unsigned(self.size)`
* **Return type:**
  [`Shape`](../reference.md#amaranth.hdl.Shape)

#### \_\_eq_\_(other)

Compare layouts.

Two layouts are equal if they have the same size and the same fields under the same names.
The order of the fields is not considered.

#### \_\_call_\_(target)

Create a view into a target.

When a [`Layout`](#amaranth.lib.data.Layout) is used as the shape of a [`Field`](#amaranth.lib.data.Field) and accessed through
a [`View`](#amaranth.lib.data.View), this method is used to wrap the slice of the underlying value into
another view with this layout.

* **Returns:**
  `View(self, target)`
* **Return type:**
  [`View`](#amaranth.lib.data.View)

#### const(init)

Convert a constant initializer to a constant.

Converts `init`, which may be a sequence or a mapping of field values, to a constant.

* **Returns:**
  A constant that has the same value as a view with this layout that was initialized with
  an all-zero value and had every field assigned to the corresponding value in the order
  in which they appear in `init`.
* **Return type:**
  [`Const`](#amaranth.lib.data.Const)

#### from_bits(raw)

Convert a bit pattern to a constant.

Converts `raw`, which is an [`int`](https://docs.python.org/3/library/functions.html#int), to a constant.

* **Returns:**
  `Const(self, raw)`
* **Return type:**
  [`Const`](#amaranth.lib.data.Const)

## Common data layouts

### *class* amaranth.lib.data.StructLayout(members)

Description of a structure layout.

The fields of a structure layout follow one another without any gaps, and the size of
a structure layout is the sum of the sizes of its members.

For example, the following layout of a 16-bit value:

can be described with:

```python
data.StructLayout({
    "first":  3,
    "second": 7,
    "third":  6
})
```

#### NOTE
Structures that have padding can be described with a [`FlexibleLayout`](#amaranth.lib.data.FlexibleLayout). Alternately,
padding can be added to the layout as fields called `_1`, `_2`, and so on. These fields
won’t be accessible as attributes or by using indexing.

* **Attributes:**
  **members** (mapping of [`str`](https://docs.python.org/3/library/stdtypes.html#str) to [`ShapeLike`](../reference.md#amaranth.hdl.ShapeLike)) – Dictionary of structure members.

#### *property* size

Size of the structure layout.

* **Returns:**
  Index of the most significant bit of the *last* field plus one; or zero if there are
  no fields.
* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

### *class* amaranth.lib.data.UnionLayout(members)

Description of a union layout.

The fields of a union layout all start from bit 0, and the size of a union layout is the size
of the largest of its members.

For example, the following layout of a 7-bit value:

can be described with:

```python
data.UnionLayout({
    "first":  3,
    "second": 7,
    "third":  6
})
```

* **Attributes:**
  **members** (mapping of [`str`](https://docs.python.org/3/library/stdtypes.html#str) to [`ShapeLike`](../reference.md#amaranth.hdl.ShapeLike)) – Dictionary of union members.

#### *property* size

Size of the union layout.

* **Returns:**
  Index of the most significant bit of the *largest* field plus one; or zero if there are
  no fields.
* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

### *class* amaranth.lib.data.ArrayLayout(elem_shape, length)

Description of an array layout.

The fields of an array layout follow one another without any gaps, and the size of an array
layout is the size of its element multiplied by its length.

For example, the following layout of a 16-bit value:

can be described with:

```python
data.ArrayLayout(unsigned(4), 4)
```

#### NOTE
Arrays that have padding can be described with a [`FlexibleLayout`](#amaranth.lib.data.FlexibleLayout).

#### NOTE
This class, [`amaranth.lib.data.ArrayLayout`](#amaranth.lib.data.ArrayLayout), is distinct from and serves a different
function than `amaranth.hdl.Array`.

* **Attributes:**
  * **elem_shape** ([`ShapeLike`](../reference.md#amaranth.hdl.ShapeLike)) – Shape of an individual element.
  * **length** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Amount of elements.

#### *property* size

Size of the array layout.

* **Returns:**
  Size of an individual element multiplied by their amount.
* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

### *class* amaranth.lib.data.FlexibleLayout(size, fields)

Description of a flexible layout.

A flexible layout is similar to a structure layout; while fields in [`StructLayout`](#amaranth.lib.data.StructLayout) are
defined contiguously, the fields in a flexible layout can overlap and have gaps between them.

Because the size and field boundaries in a flexible layout can be defined arbitrarily, it
may also be more convenient to use a flexible layout when the layout information is derived
from an external data file rather than defined in Python code.

For example, the following layout of a 16-bit value:

can be described with:

```python
data.FlexibleLayout(16, {
    "first":  data.Field(unsigned(3), 1),
    "second": data.Field(unsigned(7), 0),
    "third":  data.Field(unsigned(6), 10),
    0:        data.Field(unsigned(1), 14)
})
```

Both strings and integers can be used as names of flexible layout fields, so flexible layouts
can be used to describe structures with arbitrary padding and arrays with arbitrary stride.

If another data structure is used as the source of truth for creating flexible layouts,
consider instead inheriting from the base [`Layout`](#amaranth.lib.data.Layout) class, which may be more convenient.

* **Attributes:**
  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Size of the layout.
  * **fields** (mapping of [`str`](https://docs.python.org/3/library/stdtypes.html#str) or [`int`](https://docs.python.org/3/library/functions.html#int) to [`Field`](#amaranth.lib.data.Field)) – Fields defined in the layout.

## Data views

### *class* amaranth.lib.data.View(layout, target)

A value viewed through the lens of a layout.

The [value-like](../guide.md#lang-valuelike) class [`View`](#amaranth.lib.data.View) provides access to the fields
of an underlying Amaranth value via the names or indexes defined in the provided layout.

### Creating a view

A view must be created using an explicitly provided layout and target. To create a new
`Signal` that is wrapped in a [`View`](#amaranth.lib.data.View) with a given `layout`, use
`Signal(layout, ...)`, which for a [`Layout`](#amaranth.lib.data.Layout) is equivalent to
`View(layout, Signal(...))`.

### Accessing a view

Slicing a view or accessing its attributes returns a part of the underlying value
corresponding to the field with that index or name, which is itself either a value or
a value-castable object. If the shape of the field is a [`Layout`](#amaranth.lib.data.Layout), it will be
a [`View`](#amaranth.lib.data.View); if it is a class deriving from [`Struct`](#amaranth.lib.data.Struct) or [`Union`](#amaranth.lib.data.Union), it
will be an instance of that data class; if it is another [shape-like](../guide.md#lang-shapelike)
object implementing [`__call__()`](../reference.md#amaranth.hdl.ShapeCastable.__call__), it will be the result of calling that
method.

Slicing a view whose layout is an [`ArrayLayout`](#amaranth.lib.data.ArrayLayout) can be done with an index that is
an Amaranth value rather than a constant integer. The returned element is chosen dynamically
in that case.

A view can only be compared for equality with another view or constant with the same layout,
returning a single-bit [`Value`](../reference.md#amaranth.hdl.Value). No other operators are supported. A view can be
lowered to a [`Value`](../reference.md#amaranth.hdl.Value) using [`as_value()`](#amaranth.lib.data.View.as_value).

### Custom view classes

The [`View`](#amaranth.lib.data.View) class can be inherited from to define additional properties or methods on
a view. The only three names that are reserved on instances of [`View`](#amaranth.lib.data.View) and [`Const`](#amaranth.lib.data.Const)
are [`as_value()`](#amaranth.lib.data.View.as_value), [`Const.as_bits()`](#amaranth.lib.data.Const.as_bits), and [`eq()`](#amaranth.lib.data.View.eq), leaving the rest to the developer.
The [`Struct`](#amaranth.lib.data.Struct) and [`Union`](#amaranth.lib.data.Union) classes provided in this module are subclasses of
[`View`](#amaranth.lib.data.View) that also provide a concise way to define a layout.

#### shape()

Get layout of this view.

* **Returns:**
  The `layout` provided when constructing the view.
* **Return type:**
  [`Layout`](#amaranth.lib.data.Layout)

#### as_value()

Get underlying value.

* **Returns:**
  The `target` provided when constructing the view, or the `Signal` that
  was created.
* **Return type:**
  [`Value`](../reference.md#amaranth.hdl.Value)

#### eq(other)

Assign to the underlying value.

* **Returns:**
  `self.as_value().eq(other)`
* **Return type:**
  `Assign`

#### \_\_getitem_\_(key)

Slice the underlying value.

A field corresponding to `key` is looked up in the layout. If the field’s shape is
a shape-castable object that has a [`__call__()`](../reference.md#amaranth.hdl.ShapeCastable.__call__) method, it is called and
the result is returned. Otherwise, [`as_shape()`](../reference.md#amaranth.hdl.ShapeCastable.as_shape) is called repeatedly on
the shape until either an object with a [`__call__()`](../reference.md#amaranth.hdl.ShapeCastable.__call__) method is reached,
or a [`Shape`](../reference.md#amaranth.hdl.Shape) is returned. In the latter case, returns an unspecified Amaranth
expression with the right shape.

* **Parameters:**
  **key** ([`str`](https://docs.python.org/3/library/stdtypes.html#str) or [`int`](https://docs.python.org/3/library/functions.html#int) or [`ValueCastable`](../reference.md#amaranth.hdl.ValueCastable)) – Name or index of a field.
* **Returns:**
  A slice of the underlying value defined by the field.
* **Return type:**
  [`Value`](../reference.md#amaranth.hdl.Value) or [`ValueCastable`](../reference.md#amaranth.hdl.ValueCastable), [assignable](../guide.md#lang-assignable)
* **Raises:**
  * [**KeyError**](https://docs.python.org/3/library/exceptions.html#KeyError) – If the layout does not define a field corresponding to `key`.
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `key` is a value-castable object, but the layout of the view is not
        an [`ArrayLayout`](#amaranth.lib.data.ArrayLayout).
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If [`ShapeCastable.__call__()`](../reference.md#amaranth.hdl.ShapeCastable.__call__) does not return a value or a value-castable object.

#### \_\_getattr_\_(name)

Access a field of the underlying value.

Returns `self[name]`.

* **Raises:**
  [**AttributeError**](https://docs.python.org/3/library/exceptions.html#AttributeError) – If the layout does not define a field called `name`, or if `name` starts with
      an underscore.

### *class* amaranth.lib.data.Const(layout, target)

A constant value viewed through the lens of a layout.

The [`Const`](#amaranth.lib.data.Const) class is similar to the [`View`](#amaranth.lib.data.View) class, except that its target is
a specific bit pattern and operations on it return constants.

### Creating a constant

A constant can be created from a [`dict`](https://docs.python.org/3/library/stdtypes.html#dict) or [`list`](https://docs.python.org/3/library/stdtypes.html#list) of field values using
[`Layout.const()`](#amaranth.lib.data.Layout.const), or from a bit pattern using [`Layout.from_bits()`](#amaranth.lib.data.Layout.from_bits).

### Accessing a constant

Slicing a constant or accessing its attributes returns a part of the underlying value
corresponding to the field with that index or name. If the shape of the field is
a [`Layout`](#amaranth.lib.data.Layout), the returned value is a [`Const`](#amaranth.lib.data.Const); if it is a different
[shape-like](../guide.md#lang-shapelike) object implementing [`from_bits()`](../reference.md#amaranth.hdl.ShapeCastable.from_bits),
it will be the result of calling that method; otherwise, it is an [`int`](https://docs.python.org/3/library/functions.html#int).

Slicing a constant whose layout is an [`ArrayLayout`](#amaranth.lib.data.ArrayLayout) can be done with an index that is
an Amaranth value rather than a constant integer. The returned element is chosen dynamically
in that case, and the resulting value will be a [`View`](#amaranth.lib.data.View) instead of a [`Const`](#amaranth.lib.data.Const).

A [`Const`](#amaranth.lib.data.Const) can only be compared for equality with another constant or view that has
the same layout. When compared with another constant, the result will be a [`bool`](https://docs.python.org/3/library/functions.html#bool).
When compared with a view, the result will be a single-bit [`Value`](../reference.md#amaranth.hdl.Value). No other operators
are supported. A constant can be lowered to a [`Value`](../reference.md#amaranth.hdl.Value) using [`as_value()`](#amaranth.lib.data.Const.as_value), or to
its underlying bit pattern using [`as_bits()`](#amaranth.lib.data.Const.as_bits).

#### shape()

Get layout of this constant.

* **Returns:**
  The `layout` provided when constructing the constant.
* **Return type:**
  [`Layout`](#amaranth.lib.data.Layout)

#### as_bits()

Get underlying bit pattern.

* **Returns:**
  The `target` provided when constructing the constant.
* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

#### as_value()

Convert to a value.

* **Returns:**
  The bit pattern of this constant, as a [`Value`](../reference.md#amaranth.hdl.Value).
* **Return type:**
  [`Const`](#amaranth.lib.data.Const)

#### \_\_getitem_\_(key)

Slice the underlying value.

A field corresponding to `key` is looked up in the layout. If the field’s shape is
a shape-castable object that has a [`from_bits()`](../reference.md#amaranth.hdl.ShapeCastable.from_bits) method, returns
the result of calling that method. Otherwise, returns an [`int`](https://docs.python.org/3/library/functions.html#int).

* **Parameters:**
  **key** ([`str`](https://docs.python.org/3/library/stdtypes.html#str) or [`int`](https://docs.python.org/3/library/functions.html#int) or [`ValueCastable`](../reference.md#amaranth.hdl.ValueCastable)) – Name or index of a field.
* **Returns:**
  A slice of the underlying value defined by the field.
* **Return type:**
  unspecified type or [`int`](https://docs.python.org/3/library/functions.html#int)
* **Raises:**
  * [**KeyError**](https://docs.python.org/3/library/exceptions.html#KeyError) – If the layout does not define a field corresponding to `key`.
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `key` is a value-castable object, but the layout of the constant is not
        an [`ArrayLayout`](#amaranth.lib.data.ArrayLayout).
  * [**Exception**](https://docs.python.org/3/library/exceptions.html#Exception) – If the bit pattern of the field is not valid according to
        [`ShapeCastable.from_bits()`](../reference.md#amaranth.hdl.ShapeCastable.from_bits). Usually this will be a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError).

#### \_\_getattr_\_(name)

Access a field of the underlying value.

Returns `self[name]`.

* **Raises:**
  * [**AttributeError**](https://docs.python.org/3/library/exceptions.html#AttributeError) – If the layout does not define a field called `name`, or if `name` starts with
        an underscore.
  * [**Exception**](https://docs.python.org/3/library/exceptions.html#Exception) – If the bit pattern of the field is not valid according to
        [`ShapeCastable.from_bits()`](../reference.md#amaranth.hdl.ShapeCastable.from_bits). Usually this will be a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError).

## Data classes

### *class* amaranth.lib.data.Struct(target)

Structures defined with annotations.

The [`Struct`](#amaranth.lib.data.Struct) base class is a subclass of [`View`](#amaranth.lib.data.View) that provides a concise way
to describe the structure layout and initial values for the fields using Python
[variable annotations](https://docs.python.org/3/glossary.html#term-variable-annotation).

Any annotations containing [shape-like](../guide.md#lang-shapelike) objects are used,
in the order in which they appear in the source code, to construct a [`StructLayout`](#amaranth.lib.data.StructLayout).
The values assigned to such annotations are used to populate the initial value of the signal
created by the view. Any other annotations are kept as-is.

<!-- from amaranth import *
from amaranth.lib.data import * -->

As an example, a structure for [IEEE 754 single-precision floating-point format](https://en.wikipedia.org/wiki/Single-precision_floating-point_format) can be defined as:

```python
class IEEE754Single(Struct):
    fraction: 23
    exponent:  8 = 0x7f
    sign:      1

    def is_subnormal(self):
        return self.exponent == 0
```

The `IEEE754Single` class itself can be used where a [shape](../guide.md#lang-shapes) is expected:

```pycon
>>> IEEE754Single.as_shape()
StructLayout({'fraction': 23, 'exponent': 8, 'sign': 1})
>>> Signal(IEEE754Single).as_value().shape().width
32
```

Instances of this class can be used where [values](../guide.md#lang-values) are expected:

```pycon
>>> flt = Signal(IEEE754Single)
>>> Signal(32).eq(flt)
(eq (sig $signal) (sig flt))
```

Accessing shape-castable properties returns slices of the underlying value:

```pycon
>>> flt.fraction
(slice (sig flt) 0:23)
>>> flt.is_subnormal()
(== (slice (sig flt) 23:31) (const 1'd0))
```

The initial values for individual fields can be overridden during instantiation:

```pycon
>>> hex(Signal(IEEE754Single).as_value().init)
'0x3f800000'
>>> hex(Signal(IEEE754Single, init={'sign': 1}).as_value().init)
'0xbf800000'
>>> hex(Signal(IEEE754Single, init={'exponent': 0}).as_value().init)
'0x0'
```

Classes inheriting from [`Struct`](#amaranth.lib.data.Struct) can be used as base classes. The only restrictions
are that:

* Classes that do not define a layout cannot be instantiated or converted to a shape;
* A layout can be defined exactly once in the inheritance hierarchy.

Behavior can be shared through inheritance:

```python
class HasChecksum(Struct):
    def checksum(self):
        bits = Value.cast(self)
        return sum(bits[n:n+8] for n in range(0, len(bits), 8))

class BareHeader(HasChecksum):
    address: 16
    length:   8

class HeaderWithParam(HasChecksum):
    address: 16
    length:   8
    param:    8
```

```pycon
>>> HasChecksum.as_shape()
Traceback (most recent call last):
  ...
TypeError: Aggregate class 'HasChecksum' does not have a defined shape
>>> bare = Signal(BareHeader); bare.checksum()
(+ (+ (+ (const 1'd0) (slice (sig bare) 0:8)) (slice (sig bare) 8:16)) (slice (sig bare) 16:24))
>>> param = Signal(HeaderWithParam); param.checksum()
(+ (+ (+ (+ (const 1'd0) (slice (sig param) 0:8)) (slice (sig param) 8:16)) (slice (sig param) 16:24)) (slice (sig param) 24:32))
```

### *class* amaranth.lib.data.Union(target)

Unions defined with annotations.

The [`Union`](#amaranth.lib.data.Union) base class is a subclass of [`View`](#amaranth.lib.data.View) that provides a concise way
to describe the union layout using Python [variable annotations](https://docs.python.org/3/glossary.html#term-variable-annotation). It is very similar to the [`Struct`](#amaranth.lib.data.Struct) class, except that its layout
is a [`UnionLayout`](#amaranth.lib.data.UnionLayout).

A [`Union`](#amaranth.lib.data.Union) can have only one field with a specified initial value. If an initial value is
explicitly provided during instantiation, it overrides the initial value specified with
an annotation:

```python
class VarInt(Union):
    int8:  8
    int16: 16 = 0x100
```

```pycon
>>> Signal(VarInt).as_value().init
256
>>> Signal(VarInt, init={'int8': 10}).as_value().init
10
```


# enum.html.md

# Enumerations

The [`amaranth.lib.enum`](#module-amaranth.lib.enum) module is a drop-in replacement for the standard [`enum`](https://docs.python.org/3/library/enum.html#module-enum) module that provides extended [`Enum`](#amaranth.lib.enum.Enum), [`IntEnum`](#amaranth.lib.enum.IntEnum), [`Flag`](#amaranth.lib.enum.Flag), and [`IntFlag`](#amaranth.lib.enum.IntFlag) classes with the ability to specify a shape explicitly.

A shape can be specified for an enumeration with the `shape=` keyword argument:

<!-- from amaranth import * -->
```python
from amaranth.lib import enum

class Funct(enum.Enum, shape=4):
    ADD = 0
    SUB = 1
    MUL = 2
```

```pycon
>>> Shape.cast(Funct)
unsigned(4)
>>> Value.cast(Funct.ADD)
(const 4'd0)
```

Any [constant-castable](../guide.md#lang-constcasting) expression can be used as the value of a member:

```python
class Op(enum.Enum, shape=1):
    REG = 0
    IMM = 1

class Instr(enum.Enum, shape=5):
    ADD  = Cat(Funct.ADD, Op.REG)
    ADDI = Cat(Funct.ADD, Op.IMM)
    SUB  = Cat(Funct.SUB, Op.REG)
    SUBI = Cat(Funct.SUB, Op.IMM)
    ...
```

```pycon
>>> Instr.SUBI
<Instr.SUBI: 17>
```

The `shape=` argument is optional. If not specified, classes from this module behave exactly the same as classes from the standard [`enum`](https://docs.python.org/3/library/enum.html#module-enum) module, and likewise, this module re-exports everything exported by the standard [`enum`](https://docs.python.org/3/library/enum.html#module-enum) module.

```python
import amaranth.lib.enum

class NormalEnum(amaranth.lib.enum.Enum):
    SPAM = 0
    HAM  = 1
```

In this way, this module is a drop-in replacement for the standard [`enum`](https://docs.python.org/3/library/enum.html#module-enum) module, and in an Amaranth project, all `import enum` statements may be replaced with `from amaranth.lib import enum`.

Signals with [`Enum`](#amaranth.lib.enum.Enum) or [`Flag`](#amaranth.lib.enum.Flag) based shape are automatically wrapped in the [`EnumView`](#amaranth.lib.enum.EnumView) or [`FlagView`](#amaranth.lib.enum.FlagView) value-like wrappers, which ensure type safety. Any [value-like](../guide.md#lang-valuelike) can also be explicitly wrapped in a view class by casting it to the enum type:

```pycon
>>> a = Signal(Funct)
>>> b = Signal(Op)
>>> type(a)
<class 'amaranth.lib.enum.EnumView'>
>>> a == b
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: an EnumView can only be compared to value or other EnumView of the same enum type
>>> c = Signal(4)
>>> type(Funct(c))
<class 'amaranth.lib.enum.EnumView'>
```

Like the standard Python [`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum) and [`enum.IntFlag`](https://docs.python.org/3/library/enum.html#enum.IntFlag) classes, the Amaranth [`IntEnum`](#amaranth.lib.enum.IntEnum) and [`IntFlag`](#amaranth.lib.enum.IntFlag) classes are loosely typed and will not be subject to wrapping in view classes:

```python
class TransparentEnum(enum.IntEnum, shape=unsigned(4)):
    FOO = 0
    BAR = 1
```

```pycon
>>> a = Signal(TransparentEnum)
>>> type(a) is Signal
True
```

It is also possible to define a custom view class for a given enum:

```python
class InstrView(enum.EnumView):
    def has_immediate(self):
        return (self == Instr.ADDI) | (self == Instr.SUBI)

class Instr(enum.Enum, shape=5, view_class=InstrView):
    ADD  = Cat(Funct.ADD, Op.REG)
    ADDI = Cat(Funct.ADD, Op.IMM)
    SUB  = Cat(Funct.SUB, Op.REG)
    SUBI = Cat(Funct.SUB, Op.IMM)
```

```pycon
>>> a = Signal(Instr)
>>> type(a)
<class 'InstrView'>
>>> a.has_immediate()
(| (== (sig a) (const 5'd16)) (== (sig a) (const 5'd17)))
```

## Metaclass

### *class* amaranth.lib.enum.EnumType

Subclass of the standard [`enum.EnumType`](https://docs.python.org/3/library/enum.html#enum.EnumType) that implements the `ShapeCastable`
protocol.

This metaclass provides the [`as_shape()`](#amaranth.lib.enum.EnumType.as_shape) method, making its instances
[shape-like](../guide.md#lang-shapelike), and accepts a `shape=` keyword argument
to specify a shape explicitly. Other than this, it acts the same as the standard
[`enum.EnumType`](https://docs.python.org/3/library/enum.html#enum.EnumType) class; if the `shape=` argument is not specified and
[`as_shape()`](#amaranth.lib.enum.EnumType.as_shape) is never called, it places no restrictions on the enumeration class
or the values of its members.

When a [value-like](../guide.md#lang-valuelike) is cast to an enum type that is an instance
of this metaclass, it can be automatically wrapped in a view class. A custom view class
can be specified by passing the `view_class=` keyword argument when creating the enum class.

#### as_shape()

Cast this enumeration to a shape.

* **Returns:**
  Explicitly provided shape. If not provided, returns the result of shape-casting
  this class [as a standard Python enumeration](../guide.md#lang-shapeenum).
* **Return type:**
  `Shape`
* **Raises:**
  [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If the enumeration has neither an explicitly provided shape nor any members.

#### \_\_call_\_(value, \*args, \*\*kwargs)

Cast the value to this enum type.

When given an integer constant, it returns the corresponding enum value, like a standard
Python enumeration.

When given a [value-like](../guide.md#lang-valuelike), it is cast to a value, then wrapped
in the `view_class` specified for this enum type ([`EnumView`](#amaranth.lib.enum.EnumView) for [`Enum`](#amaranth.lib.enum.Enum),
[`FlagView`](#amaranth.lib.enum.FlagView) for [`Flag`](#amaranth.lib.enum.Flag), or a custom user-defined class). If the type has no
`view_class` (like [`IntEnum`](#amaranth.lib.enum.IntEnum) or [`IntFlag`](#amaranth.lib.enum.IntFlag)), a plain
`Value` is returned.

* **Returns:**
  * *instance of itself* – For integer values, or instances of itself.
  * [`EnumView`](#amaranth.lib.enum.EnumView) or its subclass – For value-castables, as defined by the `view_class` keyword argument.
  * `Value` – For value-castables, when a view class is not specified for this enum.

## Base classes

### *class* amaranth.lib.enum.Enum

Subclass of the standard [`enum.Enum`](https://docs.python.org/3/library/enum.html#enum.Enum) that has [`EnumType`](#amaranth.lib.enum.EnumType) as
its metaclass and [`EnumView`](#amaranth.lib.enum.EnumView) as its view class.

### *class* amaranth.lib.enum.IntEnum

Subclass of the standard [`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum) that has [`EnumType`](#amaranth.lib.enum.EnumType) as
its metaclass.

### *class* amaranth.lib.enum.Flag

Subclass of the standard [`enum.Flag`](https://docs.python.org/3/library/enum.html#enum.Flag) that has [`EnumType`](#amaranth.lib.enum.EnumType) as
its metaclass and [`FlagView`](#amaranth.lib.enum.FlagView) as its view class.

### *class* amaranth.lib.enum.IntFlag

Subclass of the standard [`enum.IntFlag`](https://docs.python.org/3/library/enum.html#enum.IntFlag) that has [`EnumType`](#amaranth.lib.enum.EnumType) as
its metaclass.

## View classes

### *class* amaranth.lib.enum.EnumView

The view class used for [`Enum`](#amaranth.lib.enum.Enum).

Wraps a `Value` and only allows type-safe operations. The only operators allowed are
equality comparisons (`==` and `!=`) with another [`EnumView`](#amaranth.lib.enum.EnumView) of the same enum type.

#### \_\_init_\_(enum, target)

Constructs a view with the given enum type and target
(a [value-like](../guide.md#lang-valuelike)).

#### shape()

Returns the underlying enum type.

#### as_value()

Returns the underlying value.

#### eq(other)

Assign to the underlying value.

* **Returns:**
  `self.as_value().eq(other)`
* **Return type:**
  `Assign`

#### \_\_eq_\_(other)

Compares the underlying value for equality.

The other operand has to be either another [`EnumView`](#amaranth.lib.enum.EnumView) with the same enum type, or
a plain value of the underlying enum.

* **Returns:**
  The result of the equality comparison, as a single-bit value.
* **Return type:**
  `Value`

### *class* amaranth.lib.enum.FlagView

The view class used for [`Flag`](#amaranth.lib.enum.Flag).

In addition to the operations allowed by [`EnumView`](#amaranth.lib.enum.EnumView), it allows bitwise operations among
values of the same enum type.

#### \_\_invert_\_()

Inverts all flags in this value and returns another [`FlagView`](#amaranth.lib.enum.FlagView).

Note that this is not equivalent to applying bitwise negation to the underlying value:
just like the Python [`enum.Flag`](https://docs.python.org/3/library/enum.html#enum.Flag) class, only bits corresponding to flags actually
defined in the enumeration are included in the result.

* **Return type:**
  [`FlagView`](#amaranth.lib.enum.FlagView)

#### \_\_and_\_(other)

Performs a bitwise AND and returns another [`FlagView`](#amaranth.lib.enum.FlagView).

The other operand has to be either another [`FlagView`](#amaranth.lib.enum.FlagView) of the same enum type, or
a plain value of the underlying enum type.

* **Return type:**
  [`FlagView`](#amaranth.lib.enum.FlagView)

#### \_\_or_\_(other)

Performs a bitwise OR and returns another [`FlagView`](#amaranth.lib.enum.FlagView).

The other operand has to be either another [`FlagView`](#amaranth.lib.enum.FlagView) of the same enum type, or
a plain value of the underlying enum type.

* **Return type:**
  [`FlagView`](#amaranth.lib.enum.FlagView)

#### \_\_xor_\_(other)

Performs a bitwise XOR and returns another [`FlagView`](#amaranth.lib.enum.FlagView).

The other operand has to be either another [`FlagView`](#amaranth.lib.enum.FlagView) of the same enum type, or
a plain value of the underlying enum type.

* **Return type:**
  [`FlagView`](#amaranth.lib.enum.FlagView)

#### \_\_rand_\_(other)

Performs a bitwise AND and returns another [`FlagView`](#amaranth.lib.enum.FlagView).

The other operand has to be either another [`FlagView`](#amaranth.lib.enum.FlagView) of the same enum type, or
a plain value of the underlying enum type.

* **Return type:**
  [`FlagView`](#amaranth.lib.enum.FlagView)

#### \_\_ror_\_(other)

Performs a bitwise OR and returns another [`FlagView`](#amaranth.lib.enum.FlagView).

The other operand has to be either another [`FlagView`](#amaranth.lib.enum.FlagView) of the same enum type, or
a plain value of the underlying enum type.

* **Return type:**
  [`FlagView`](#amaranth.lib.enum.FlagView)

#### \_\_rxor_\_(other)

Performs a bitwise XOR and returns another [`FlagView`](#amaranth.lib.enum.FlagView).

The other operand has to be either another [`FlagView`](#amaranth.lib.enum.FlagView) of the same enum type, or
a plain value of the underlying enum type.

* **Return type:**
  [`FlagView`](#amaranth.lib.enum.FlagView)


# fifo.html.md

# First-in first-out queues

The `amaranth.lib.fifo` module provides building blocks for first-in, first-out queues.

### *class* amaranth.lib.fifo.FIFOInterface(\*, width, depth)

Data written to the input interface (`w_data`, `w_rdy`, `w_en`) is buffered and can be
read at the output interface (`r_data`, `r_rdy`, `r_en`). The data entry written first
to the input also appears first on the output.

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Bit width of data entries.
  * **depth** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Depth of the queue. If zero, the FIFO cannot be read from or written to.
* **Attributes:**
  * **w_data** (*Signal(width), in*) – Input data.
  * **w_rdy** (*Signal(1), out*) – Asserted if there is space in the queue, i.e. `w_en` can be asserted to write
    a new entry.
  * **w_en** (*Signal(1), in*) – Write strobe. Latches `w_data` into the queue. Does nothing if `w_rdy` is not asserted.
  * **w_level** (*Signal(range(depth + 1)), out*) – Number of unread entries.
  * **r_data** (*Signal(width), out*) – Output data. The conditions in which `r_data` is valid depends on the type of the queue.
  * **r_rdy** (*Signal(1), out*) – Asserted if there is an entry in the queue, i.e. `r_en` can be asserted to read
    an existing entry.
  * **r_en** (*Signal(1), in*) – Read strobe. Makes the next entry (if any) available on `r_data` at the next cycle.
    Does nothing if `r_rdy` is not asserted.
  * **r_level** (*Signal(range(depth + 1)), out*) – Number of unread entries.

#### NOTE
The [`FIFOInterface`](#amaranth.lib.fifo.FIFOInterface) class can be used directly to substitute a FIFO in tests, or inherited from in a custom FIFO implementation.

### *class* amaranth.lib.fifo.SyncFIFO(\*, width, depth)

Synchronous first in, first out queue.

Read and write interfaces are accessed from the same clock domain. If different clock domains
are needed, use [`AsyncFIFO`](#amaranth.lib.fifo.AsyncFIFO).

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Bit width of data entries.
  * **depth** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Depth of the queue. If zero, the FIFO cannot be read from or written to.
* **Attributes:**
  * **level** (*Signal(range(depth + 1)), out*) – Number of unread entries. This level is the same between read and write for synchronous FIFOs.
  * **w_data** (*Signal(width), in*) – Input data.
  * **w_rdy** (*Signal(1), out*) – Asserted if there is space in the queue, i.e. `w_en` can be asserted to write
    a new entry.
  * **w_en** (*Signal(1), in*) – Write strobe. Latches `w_data` into the queue. Does nothing if `w_rdy` is not asserted.
  * **w_level** (*Signal(range(depth + 1)), out*) – Number of unread entries.
  * **r_data** (*Signal(width), out*) – Output data. Valid if `r_rdy` is asserted.
  * **r_rdy** (*Signal(1), out*) – Asserted if there is an entry in the queue, i.e. `r_en` can be asserted to read
    an existing entry.
  * **r_en** (*Signal(1), in*) – Read strobe. Makes the next entry (if any) available on `r_data` at the next cycle.
    Does nothing if `r_rdy` is not asserted.
  * **r_level** (*Signal(range(depth + 1)), out*) – Number of unread entries.

### *class* amaranth.lib.fifo.SyncFIFOBuffered(\*, width, depth)

Buffered synchronous first in, first out queue.

This queue’s interface is identical to [`SyncFIFO`](#amaranth.lib.fifo.SyncFIFO), but it
does not use asynchronous memory reads, which are incompatible with FPGA block RAMs.

In exchange, the latency between an entry being written to an empty queue and that entry
becoming available on the output is increased by one cycle compared to [`SyncFIFO`](#amaranth.lib.fifo.SyncFIFO).

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Bit width of data entries.
  * **depth** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Depth of the queue. If zero, the FIFO cannot be read from or written to.
* **Attributes:**
  * **level** (*Signal(range(depth + 1)), out*) – Number of unread entries. This level is the same between read and write for synchronous FIFOs.
  * **w_data** (*Signal(width), in*) – Input data.
  * **w_rdy** (*Signal(1), out*) – Asserted if there is space in the queue, i.e. `w_en` can be asserted to write
    a new entry.
  * **w_en** (*Signal(1), in*) – Write strobe. Latches `w_data` into the queue. Does nothing if `w_rdy` is not asserted.
  * **w_level** (*Signal(range(depth + 1)), out*) – Number of unread entries.
  * **r_data** (*Signal(width), out*) – Output data. Valid if `r_rdy` is asserted.
  * **r_rdy** (*Signal(1), out*) – Asserted if there is an entry in the queue, i.e. `r_en` can be asserted to read
    an existing entry.
  * **r_en** (*Signal(1), in*) – Read strobe. Makes the next entry (if any) available on `r_data` at the next cycle.
    Does nothing if `r_rdy` is not asserted.
  * **r_level** (*Signal(range(depth + 1)), out*) – Number of unread entries.

### *class* amaranth.lib.fifo.AsyncFIFO(\*, width, depth, r_domain='read', w_domain='write', exact_depth=False)

Asynchronous first in, first out queue.

Read and write interfaces are accessed from different clock domains, which can be set when
constructing the FIFO.

[`AsyncFIFO`](#amaranth.lib.fifo.AsyncFIFO) can be reset from the write clock domain. When the write domain reset is
asserted, the FIFO becomes empty. When the read domain is reset, data remains in the FIFO - the
read domain logic should correctly handle this case.

[`AsyncFIFO`](#amaranth.lib.fifo.AsyncFIFO) only supports power of 2 depths. Unless `exact_depth` is specified,
the `depth` parameter is rounded up to the next power of 2.

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Bit width of data entries.
  * **depth** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Depth of the queue. If zero, the FIFO cannot be read from or written to.
  * **r_domain** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – Read clock domain.
  * **w_domain** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – Write clock domain.
* **Attributes:**
  * **w_data** (*Signal(width), in*) – Input data.
  * **w_rdy** (*Signal(1), out*) – Asserted if there is space in the queue, i.e. `w_en` can be asserted to write
    a new entry.
  * **w_en** (*Signal(1), in*) – Write strobe. Latches `w_data` into the queue. Does nothing if `w_rdy` is not asserted.
  * **w_level** (*Signal(range(depth + 1)), out*) – Number of unread entries.
  * **r_data** (*Signal(width), out*) – Output data. Valid if `r_rdy` is asserted.
  * **r_rdy** (*Signal(1), out*) – Asserted if there is an entry in the queue, i.e. `r_en` can be asserted to read
    an existing entry.
  * **r_en** (*Signal(1), in*) – Read strobe. Makes the next entry (if any) available on `r_data` at the next cycle.
    Does nothing if `r_rdy` is not asserted.
  * **r_level** (*Signal(range(depth + 1)), out*) – Number of unread entries.
  * **r_rst** (*Signal(1), out*) – Asserted, for at least one read-domain clock cycle, after the FIFO has been reset by
    the write-domain reset.

### *class* amaranth.lib.fifo.AsyncFIFOBuffered(\*, width, depth, r_domain='read', w_domain='write', exact_depth=False)

Buffered asynchronous first in, first out queue.

Read and write interfaces are accessed from different clock domains, which can be set when
constructing the FIFO.

[`AsyncFIFOBuffered`](#amaranth.lib.fifo.AsyncFIFOBuffered) only supports power of 2 plus one depths. Unless `exact_depth`
is specified, the `depth` parameter is rounded up to the next power of 2 plus one.
(The output buffer acts as an additional queue element.)

This queue’s interface is identical to [`AsyncFIFO`](#amaranth.lib.fifo.AsyncFIFO), but it has an additional register
on the output, improving timing in case of block RAM that has large clock-to-output delay.

In exchange, the latency between an entry being written to an empty queue and that entry
becoming available on the output is increased by one cycle compared to [`AsyncFIFO`](#amaranth.lib.fifo.AsyncFIFO).

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Bit width of data entries.
  * **depth** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Depth of the queue. If zero, the FIFO cannot be read from or written to.
  * **r_domain** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – Read clock domain.
  * **w_domain** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – Write clock domain.
* **Attributes:**
  * **w_data** (*Signal(width), in*) – Input data.
  * **w_rdy** (*Signal(1), out*) – Asserted if there is space in the queue, i.e. `w_en` can be asserted to write
    a new entry.
  * **w_en** (*Signal(1), in*) – Write strobe. Latches `w_data` into the queue. Does nothing if `w_rdy` is not asserted.
  * **w_level** (*Signal(range(depth + 1)), out*) – Number of unread entries.
  * **r_data** (*Signal(width), out*) – Output data. Valid if `r_rdy` is asserted.
  * **r_rdy** (*Signal(1), out*) – Asserted if there is an entry in the queue, i.e. `r_en` can be asserted to read
    an existing entry.
  * **r_en** (*Signal(1), in*) – Read strobe. Makes the next entry (if any) available on `r_data` at the next cycle.
    Does nothing if `r_rdy` is not asserted.
  * **r_level** (*Signal(range(depth + 1)), out*) – Number of unread entries.
  * **r_rst** (*Signal(1), out*) – Asserted, for at least one read-domain clock cycle, after the FIFO has been reset by
    the write-domain reset.


# getting-started.html.md

# Getting Started with ChipFlow Examples

This guide will walk you through setting up the ChipFlow examples repository and running your first chip build.

## Prerequisites

Before you begin, ensure you have the following installed:

- **Python 3.11+**: [Python Downloads](https://www.python.org/downloads/)
- **Git**: [Git Downloads](https://git-scm.com/downloads)
- **PDM**: [PDM Installation](https://pdm-project.org/en/latest/#installation)

We also recommend:

- **VS Code**: [VS Code Downloads](https://code.visualstudio.com/download)
- **GitHub Desktop**: [GitHub Desktop Downloads](https://desktop.github.com/download/)

## Clone the Repository

Using Git command line:

```bash
git clone https://github.com/ChipFlow/chipflow-examples.git
cd chipflow-examples
```

Or using GitHub Desktop:

1. Go to the [chipflow-examples repository](https://github.com/ChipFlow/chipflow-examples)
2. Click the green “Code” button
3. Select “Open with GitHub Desktop”
4. Follow the prompts to clone

## Install Dependencies

Once you have the repository cloned, install the dependencies:

```bash
cd chipflow-examples
pdm lock -d
pdm install
```

## Set Up Your API Key

To submit designs to the ChipFlow cloud builder, you need an API key:

1. Go to [https://build.chipflow.com/user/detail](https://build.chipflow.com/user/detail)
2. Click “Create/Refresh API Key”
3. Copy your new API key (you won’t see it again!)

Create a `.env` file in the `chipflow-examples` directory:

```bash
echo "CHIPFLOW_API_KEY=your_api_key_here" > .env
```

Replace `your_api_key_here` with your actual API key.

## Running Your First Build

Let’s try the `minimal` example:

```bash
cd minimal
```

First, lock the pin assignments:

```bash
pdm chipflow pin lock
```

Run the simulation to test the design:

```bash
pdm sim-check
```

You should see the simulation being built and run, with test output like:

```text
-- build_sim_cxxrtl
-- build_sim
pdm chipflow software
-- gather_dependencies
-- build_software_elf
-- build_software
cd build/sim && ./sim_soc
SoC type: CA7F100F
Flash ID: CA7CA7FF
Quad mode
Event logs are identical
```

## Submitting to ChipFlow

Once your simulation passes, submit your design to be built:

```bash
pdm submit
```

This returns a build URL where you can monitor progress:

```text
INFO:chipflow_lib.steps.silicon:Submitting c23dab6-dirty for project chipflow-examples-minimal
INFO:chipflow_lib.steps.silicon:Submitted design: {'build_id': '3f51a69c-b3e3-4fd3-88fd-52826ac5e5dd'}
Design submitted successfully! Build URL: https://build.chipflow.com/build/3f51a69c-b3e3-4fd3-88fd-52826ac5e5dd
```

To stream build logs to your terminal:

```bash
pdm submit --wait
```

## Next Steps

- Explore the [Minimal SoC Example](minimal.md) example to understand the basic structure
- Try the [MCU SoC Example](mcu-soc.md) example for a more complete design
- Read the [Intro to chipflow.toml](../chipflow-lib/chipflow-toml-guide.md) to understand configuration options
- Check the [Simulation Guide](../chipflow-lib/simulation-guide.md) for simulation details


# getting-started.html.md

# Getting Started with ChipFlow

Welcome to ChipFlow! This guide will help you get started with the ChipFlow IC design platform, which simplifies the process of designing, testing, and manufacturing custom silicon.

## What is ChipFlow?

ChipFlow is an integrated circuit design platform that combines modern hardware design tools with cloud-based manufacturing services. It enables you to:

- Design custom silicon using [Python](https://www.python.org/)  and [Amaranth HDL](https://github.com/amaranth-lang/amaranth)
- Simulate and verify your designs
- Prepare and submit your designs for manufacturing
- Manage the entire IC design workflow from a single platform

## Prerequisites

Before you begin:

- Install the latest version of [Python](https://www.python.org/downloads/).
- Ensure you have [Git command line tools](https://git-scm.com/downloads)  installed
- We recommend [Visual Studio Code](https://code.visualstudio.com/download) as a development environment
- [GitHub Desktop](https://desktop.github.com/download/) is a great tool for workingh with Git repos

## Clone chipflow-examples

#### NOTE
If you’re familiar with the [Git](https://git-scm.com/) command line
then go clone ChipFlow/chipflow-examples <https://github.com/ChipFlow/chipflow-examples>,
switch to the release branch <https://github.com/ChipFlow/chipflow-examples/tree/release>,
and jump ahead to [Install the Dependencies]()

If the git world is new to you, start up [GitHub
Desktop](https://github.com/apps/desktop). The first time you launch
it you will be asked to sign in or create an account - we recommend you
take this moment to create a GitHub account if you don’t already have
one!

Navigate to [the chipflow-examples repository release branch](https://github.com/ChipFlow/chipflow-examples/tree/release)
and click the green ‘Code’ button at the top. Select ‘Open with GitHub Desktop’ and
then follow the prompts (N.B. your web browser may have a pop-up to
authorise opening an external app)

![Image showing the link to click](chipflow-lib/_assets/open-github-desktop.png)

Once GitHub Desktop has cloned your repo you can click the button to
open it in VS Code:

![Image showing where to click in GitHub Desktop to open in VSCode](chipflow-lib/_assets/github-desktop-open.png)

## Install the dependencies

#### NOTE
In VS Code, open up a terminal by pressing `Command-p`: (Mac) or `C-p` (Windows/Linux).

We use [PDM](https://pdm-project.org) to manage our dependencies, so
this will need to be installed. Follow the [PDM install
instructions](https://pdm-project.org/en/latest/#installation) for your OS.

Once PDM is installed, make sure you are in the `chipflow-examples`
directory and then run:

```default
pdm lock -d
pdm install
```

## Set up authentication

ChipFlow supports multiple authentication methods. Choose the one that works best for you:

### Method 1: Using the CLI (Recommended)

The easiest way to authenticate is using the `chipflow auth login` command:

```default
pdm run chipflow auth login
```

This will automatically:

1. Check if you have the GitHub CLI (`gh`) installed and authenticated
2. If yes, instantly authenticate using your GitHub token
3. If no, guide you through the device flow where you’ll authorize via your browser

Your API key will be saved locally for future use.

### Method 2: Manual API key (Alternative)

If you prefer to manually manage your API key:

1. Go to [https://build.chipflow.com/](https://build.chipflow.com/) and log in with your GitHub account
2. Click on the ‘User’ menu, then on ‘Create/Refresh API Key’
3. Your new API key will appear at the top

![Image showing a newly generated API Key](chipflow-lib/_assets/api-key.png)

#### WARNING
Copy it now, as you will not see it again!

1. Create a file called `.env` at the top level in the
   `chipflow-examples` directory, containing:

```default
CHIPFLOW_API_KEY=<Paste your key here>
```

To log out and remove saved credentials:

```default
pdm run chipflow auth logout
```

## Running a chip build

First choose a design to test. Here we will use the `minimal` design.

Change into the `minimal` directory in `chipflow-examples` to use
this design. Now we need to ‘lock’ our pins - the ChipFlow tooling will
then automatically allocate inputs and outputs from your design to pins
on the chip.

```default
pdm run chipflow pin lock
```

We can now simulate and test the design by running:

```default
make sim-check
```

You should see the simulation model being built and run - and a small
test firmware running on the simulated System-on-a-Chip (aided by our
local friendly cat!)

```default
pdm run chipflow sim
-- build_sim_cxxrtl
-- build_sim
pdm run chipflow software
-- gather_depencencies
-- build_software_elf
-- build_software
cd build/sim && ./sim_soc
🐱: nyaa~!
SoC type: CA7F100F
Flash ID: CA7CA7FF
Quad mode
pdm run json-compare design/tests/events_reference.json build/sim/events.json
Event logs are identical
```

Now you are ready to try building this design into a chip! To submit
your design to ChipFlow Platform where it will be built into GDS, run:

```default
pdm run chipflow silicon submit
```

This should return something like:

```default
INFO:chipflow.steps.silicon:Submitting c23dab6-dirty for project chipflow-examples-minimal
INFO:chipflow.steps.silicon:Submitted design: {'build_id': '3f51a69c-b3e3-4fd3-88fd-52826ac5e5dd'}
Design submitted successfully! Build URL: https://build.chipflow.com/build/3f51a69c-b3e3-4fd3-88fd-52826ac5e5dd
```

Your design will now start building: pictures and logs of the build are
available at build URL that is returned, once it is complete.

If you would like to get the build logs streamed to your command-line,
you can instead call:

```default
pdm run chipflow silicon submit --wait
```


# gowin.html.md

# Gowin

The [`GowinPlatform`](#amaranth.vendor.GowinPlatform) class provides a base platform to support Gowin toolchains.

The Apicula and Gowin toolchains are supported.

### *class* amaranth.vendor.GowinPlatform(\*, toolchain='Apicula')

### Apicula toolchain

Required tools:
: * `yosys`
  * `nextpnr-gowin`
  * `gowin_pack`

The environment is populated by running the script specified in the environment variable
`AMARANTH_ENV_APICULA`, if present.

Build products:
: * `{{name}}.fs`: binary bitstream.

### Gowin toolchain

Required tools:
: * `gw_sh`

The environment is populated by running the script specified in the environment variable
`AMARANTH_ENV_GOWIN`, if present.

Build products:
: * `{{name}}.fs`: binary bitstream.


# gpio.html.md

# GPIO

The [`amaranth_soc.gpio`](#module-amaranth_soc.gpio) module provides a basic GPIO peripheral.

<!-- from amaranth import *
from amaranth.lib import io, wiring
from amaranth.lib.wiring import In, Out, flipped, connect

from amaranth_soc import csr, gpio -->

## Introduction

[GPIO](https://en.wikipedia.org/wiki/General-purpose_input/output) peripherals are commonly used
to interface a SoC (usually a microcontroller) with a variety of external circuitry. This module contains a GPIO peripheral which can be connected to a [CSR bus](csr/bus.md#csr-bus-introduction).

### Example

This example shows a GPIO peripheral being used to drive four LEDs:

```python
class MySoC(wiring.Component):
    def elaborate(self, platform):
        m = Module()

        m.submodules.led_gpio = led_gpio = gpio.Peripheral(pin_count=4, addr_width=8,
                                                           data_width=8)

        for n in range(4):
            led = io.Buffer("o", platform.request("led", n, dir="-"))
            connect(m, led_gpio.pins[n], led)

        m.submodules.csr_decoder = csr_decoder = csr.Decoder(addr_width=31, data_width=8)
        csr_decoder.add(led_gpio.bus, addr=0x1000, name="led_gpio")

        # ...

        return m
```

## Pin modes

### *class* amaranth_soc.gpio.PinMode

GPIO pin mode.

The 2-bit values of this enumeration can be written to a [`Peripheral.Mode`](#amaranth_soc.gpio.Peripheral.Mode) field to
configure the pins of a [`Peripheral`](#amaranth_soc.gpio.Peripheral).

#### INPUT_ONLY *= 0*

Input-only mode.

The pin output is disabled but remains connected to its [`Peripheral.Output`](#amaranth_soc.gpio.Peripheral.Output) field.
Its `alt_mode` bit is wired to 0.

#### PUSH_PULL *= 1*

Push-pull mode.

The pin output is enabled and connected to its [`Peripheral.Output`](#amaranth_soc.gpio.Peripheral.Output) field. Its
`alt_mode` bit is wired to 0.

#### OPEN_DRAIN *= 2*

Open-drain mode.

The pin output is enabled when the value of its [`Peripheral.Output`](#amaranth_soc.gpio.Peripheral.Output) field is 0, and
is itself wired to 0. Its `alt_mode` bit is wired to 0.

#### ALTERNATE *= 3*

Alternate mode.

The pin output is disabled but remains connected to its [`Peripheral.Output`](#amaranth_soc.gpio.Peripheral.Output) field.
Its `alt_mode` bit is wired to 1.

## Pin interface

### *class* amaranth_soc.gpio.PinSignature

GPIO pin signature.

* **Members:**
  * **i** (`In(1)`) – Input.
  * **o** (`Out(1)`) – Output.
  * **oe** (`Out(1)`) – Output enable.

## Peripheral

#### *class* Peripheral.Mode

Mode register.

This [`Register`](csr/reg.md#amaranth_soc.csr.reg.Register) contains an array of `pin_count` read/write fields.
Each field is 2-bit wide and its possible values are defined by the [`PinMode`](#amaranth_soc.gpio.PinMode)
enumeration.

---

If `pin_count` is 8, then the [`Register`](csr/reg.md#amaranth_soc.csr.reg.Register) has the following fields:

---
* **Parameters:**
  **pin_count** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Number of GPIO pins.

#### *class* Peripheral.Input

Input register.

This [`Register`](csr/reg.md#amaranth_soc.csr.reg.Register) contains an array of `pin_count` read-only fields. Each
field is 1-bit wide and is driven by the input of its associated pin in the `pins` array
of the peripheral.

Values sampled from pin inputs go through `Peripheral.input_stages` synchronization
stages (on a rising edge of `ClockSignal("sync")`) before reaching the register.

---

If `pin_count` is 8, then the [`Register`](csr/reg.md#amaranth_soc.csr.reg.Register) has the following fields:

---
* **Parameters:**
  **pin_count** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Number of GPIO pins.

#### *class* Peripheral.Output

Output register.

This [`Register`](csr/reg.md#amaranth_soc.csr.reg.Register) contains an array of `pin_count` read/write fields. Each
field is 1-bit wide and drives the output of its associated pin in the `pins` array of the
peripheral, depending on its associated [`Mode`](#amaranth_soc.gpio.Peripheral.Mode) field.

---

If `pin_count` is 8, then the [`Register`](csr/reg.md#amaranth_soc.csr.reg.Register) has the following fields:

---
* **Parameters:**
  **pin_count** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Number of GPIO pins.

#### *class* Peripheral.SetClr

Output set/clear register.

This [`Register`](csr/reg.md#amaranth_soc.csr.reg.Register) contains an array of `pin_count` write-only fields. Each
field is 2-bit wide; writing it can modify its associated [`Output`](#amaranth_soc.gpio.Peripheral.Output) field
as a side-effect.

---

If `pin_count` is 8, then the [`Register`](csr/reg.md#amaranth_soc.csr.reg.Register) has the following fields:

- Writing 0b01 to a field sets its associated [`Output`](#amaranth_soc.gpio.Peripheral.Output) field.
- Writing 0b10 to a field clears its associated [`Output`](#amaranth_soc.gpio.Peripheral.Output) field.
- Writing 0b00 or 0b11 to a field has no side-effect.

---
* **Parameters:**
  **pin_count** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Number of GPIO pins.

### *class* amaranth_soc.gpio.Peripheral

GPIO peripheral.

* **Parameters:**
  * **pin_count** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Number of GPIO pins.
  * **addr_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – CSR bus address width.
  * **data_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – CSR bus data width.
  * **input_stages** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Number of synchronization stages between pin inputs and the [`Input`](#amaranth_soc.gpio.Peripheral.Input)
    register. Optional. Defaults to `2`.
* **Members:**
  * **bus** (`In(csr.Signature(addr_width, data_width))`) – CSR bus interface providing access to registers.
  * **pins** (`Out(PinSignature()).array(pin_count)`) – GPIO pin interfaces.
  * **alt_mode** (`Out(pin_count)`) – Indicates which members of the `pins` array are in alternate mode.


# guide.html.md

<!-- # Required to capture warnings in doctests.
import sys; sys.stderr = sys.stdout -->

# Language guide

This guide introduces the Amaranth language in depth. It assumes familiarity with synchronous digital logic and the Python programming language, but does not require prior experience with any hardware description language. See the tutorial <tutorial> for a step-by-step introduction to the language, and the reference <reference> for a detailed description of the Python classes that underlie the language’s syntax.

<!-- TODO: link to a good synchronous logic tutorial and a Python tutorial? -->

<a id="lang-prelude"></a>

## The prelude

Because Amaranth is a regular Python library, it needs to be imported before use. The root `amaranth` module, called *the prelude*, is carefully curated to export a small amount of the most essential names, useful in nearly every design. In source files dedicated to Amaranth code, it is a good practice to use a [glob import](https://docs.python.org/3/tutorial/modules.html#tut-pkg-import-star) for readability:

```default
from amaranth import *
```

However, if a source file uses Amaranth together with other libraries, or if glob imports are frowned upon, it is conventional to use a short alias instead:

```default
import amaranth as am
```

All of the examples below assume that a glob import is used.

<!-- from amaranth import * -->

<a id="lang-shapes"></a>

## Shapes

A [`Shape`](reference.md#amaranth.hdl.Shape) describes the bit width and signedness of an Amaranth value. It can be constructed directly:

```pycon
>>> Shape(width=5, signed=False)
unsigned(5)
>>> Shape(width=12, signed=True)
signed(12)
```

However, in most cases, the signedness of a shape is known upfront, and the convenient aliases [`signed()`](reference.md#amaranth.hdl.signed) and [`unsigned()`](reference.md#amaranth.hdl.unsigned) can be used:

```pycon
>>> unsigned(5) == Shape(width=5, signed=False)
True
>>> signed(12) == Shape(width=12, signed=True)
True
```

### Shapes of values

All values have a `.shape()` method that computes their shape. The width of a value `v`, `v.shape().width`, can also be retrieved with `len(v)`.

```pycon
>>> Const(5).shape()
unsigned(3)
>>> len(Const(5))
3
```

<a id="lang-values"></a>

## Values

The basic building block of the Amaranth language is a *value*, which is a term for a binary number that is computed or stored anywhere in the design. Each value has a *width*—the amount of bits used to represent the value—and a *signedness*—the interpretation of the value by arithmetic operations—collectively called its *shape*. Signed values always use [two’s complement](https://en.wikipedia.org/wiki/Two's_complement) representation.

<a id="lang-constants"></a>

## Constants

The simplest Amaranth value is a *constant*, representing a fixed number, and introduced using `Const(...)` or its short alias `C(...)`:

```pycon
>>> ten = Const(10)
>>> minus_two = C(-2)
```

The code above does not specify any shape for the constants. If the shape is omitted, Amaranth uses unsigned shape for positive numbers and signed shape for negative numbers, with the width inferred from the smallest amount of bits necessary to represent the number. As a special case, in order to get the same inferred shape for `True` and `False`, `0` is considered to be 1-bit unsigned.

```pycon
>>> ten.shape()
unsigned(4)
>>> minus_two.shape()
signed(2)
>>> C(0).shape()
unsigned(1)
```

The shape of the constant can be specified explicitly, in which case the number’s binary representation will be truncated or extended to fit the shape. Although rarely useful, 0-bit constants are permitted.

```pycon
>>> Const(360, unsigned(8)).value
104
>>> Const(129, signed(8)).value
-127
>>> Const(1, unsigned(0)).value
0
```

<a id="lang-shapelike"></a>

## Shape casting

Shapes can be *cast* from other objects, which are called *shape-like*. Casting is a convenient way to specify a shape indirectly, for example, by a range of numbers representable by values with that shape. Shapes are shape-like objects as well.

Casting to a shape can be done explicitly with [`Shape.cast()`](reference.md#amaranth.hdl.Shape.cast), but is usually implicit, since shape-like objects are accepted anywhere shapes are.

<a id="lang-shapeint"></a>

### Shapes from integers

Casting a shape from an integer `i` is a shorthand for constructing a shape with [`unsigned(i)`](reference.md#amaranth.hdl.unsigned):

```pycon
>>> Shape.cast(5)
unsigned(5)
>>> C(0, 3).shape()
unsigned(3)
```

<a id="lang-shaperange"></a>

### Shapes from ranges

Casting a shape from a [`range`](https://docs.python.org/3/library/stdtypes.html#range) `r` produces a shape that:

> * has a width large enough to represent both `min(r)` and `max(r)`, but not larger, and
> * is signed if `r` contains any negative values, unsigned otherwise.

Specifying a shape with a range is convenient for counters, indexes, and all other values whose width is derived from a set of numbers they must be able to fit:

```pycon
>>> Const(0, range(100)).shape()
unsigned(7)
>>> items = [1, 2, 3]
>>> C(1, range(len(items))).shape()
unsigned(2)
```

<a id="lang-exclrange"></a>

#### NOTE
Python ranges are *exclusive* or *half-open*, meaning they do not contain their `.stop` element. Because of this, values with shapes cast from a `range(stop)` where `stop` is a power of 2 are not wide enough to represent `stop` itself:

<!-- >>> import warnings
>>> _warning_filters_backup = warnings.catch_warnings()
>>> _warning_filters_backup.__enter__() # have to do this horrific hack to make it work with `PYTHONWARNINGS=error` :(
>>> warnings.simplefilter("default", amaranth.hdl._ast.SyntaxWarning) -->
```pycon
>>> fencepost = C(256, range(256))
<...>:1: SyntaxWarning: Value 256 equals the non-inclusive end of the constant shape range(0, 256); this is likely an off-by-one error
  fencepost = C(256, range(256))
>>> fencepost.shape()
unsigned(8)
>>> fencepost.value
0
```

<!-- >>> _warning_filters_backup.__exit__() -->

Amaranth detects uses of `Const` and `Signal` that invoke such an off-by-one error, and emits a diagnostic message.

#### NOTE
An empty range always casts to an `unsigned(0)`, even if both of its bounds are negative.
This happens because, being empty, it does not contain any negative values.

```pycon
>>> Shape.cast(range(-1, -1))
unsigned(0)
```

<a id="lang-shapeenum"></a>

### Shapes from enumerations

Casting a shape from an [`enum.Enum`](https://docs.python.org/3/library/enum.html#enum.Enum) subclass requires all of the enumeration members to have [constant-castable](#lang-constcasting) values. The shape has a width large enough to represent the value of every member, and is signed only if there is a member with a negative value.

Specifying a shape with an enumeration is convenient for finite state machines, multiplexers, complex control signals, and all other values whose width is derived from a few distinct choices they must be able to fit:

<!-- import enum -->
```python
class Direction(enum.Enum):
    TOP    = 0
    LEFT   = 1
    BOTTOM = 2
    RIGHT  = 3
```

```pycon
>>> Shape.cast(Direction)
unsigned(2)
```

The [`amaranth.lib.enum`](stdlib/enum.md#module-amaranth.lib.enum) module extends the standard enumerations such that their shape can be specified explicitly when they are defined:

<!-- import amaranth.lib.enum -->
```python
class Funct4(amaranth.lib.enum.Enum, shape=unsigned(4)):
    ADD = 0
    SUB = 1
    MUL = 2
```

```pycon
>>> Shape.cast(Funct4)
unsigned(4)
```

#### NOTE
The enumeration does not have to subclass [`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum) or have [`int`](https://docs.python.org/3/library/functions.html#int) as one of its base classes; it only needs to have integers as values of every member. Using enumerations based on [`enum.Enum`](https://docs.python.org/3/library/enum.html#enum.Enum) rather than [`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum) prevents unwanted implicit conversion of enum members to integers.

<a id="lang-shapecustom"></a>

### Custom shapes

Any Python value that implements the [`ShapeCastable`](reference.md#amaranth.hdl.ShapeCastable) interface can extend the language with a custom shape-like object. For example, the standard library module [`amaranth.lib.data`](stdlib/data.md#module-amaranth.lib.data) uses this facility to add support for aggregate data types to the language.

<a id="lang-valuelike"></a>

## Value casting

Like shapes, values may be *cast* from other objects, which are called *value-like*. Casting to values allows objects that are not provided by Amaranth, such as integers or enumeration members, to be used in Amaranth expressions directly. Custom value-like objects can be defined by implementing the [`ValueCastable`](reference.md#amaranth.hdl.ValueCastable) interface. Values are value-like objects as well.

Casting to a value can be done explicitly with [`Value.cast()`](reference.md#amaranth.hdl.Value.cast), but is usually implicit, since value-like objects are accepted anywhere values are.

### Values from integers

Casting a value from an integer `i` is equivalent to `Const(i)`:

```pycon
>>> Value.cast(5)
(const 3'd5)
```

#### NOTE
If a value subclasses [`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum) or its class otherwise inherits from both [`int`](https://docs.python.org/3/library/functions.html#int) and `Enum`, it is treated as an enumeration.

### Values from enumeration members

Casting a value from an enumeration member `m` is equivalent to `Const(m.value, type(m))`:

```pycon
>>> Value.cast(Direction.LEFT)
(const 2'd1)
```

#### NOTE
If a value subclasses [`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum) or its class otherwise inherits from both [`int`](https://docs.python.org/3/library/functions.html#int) and `Enum`, it is treated as an enumeration.

<a id="lang-constcasting"></a>

## Constant casting

A subset of [values](#lang-values) are *constant-castable*. If a value is constant-castable and all of its operands are also constant-castable, it can be converted to a `Const`, the numeric value of which can then be read by Python code. This provides a way to perform computation on Amaranth values while constructing the design.

Constant-castable objects are accepted anywhere a constant integer is accepted. Casting to a constant can also be done explicitly with `Const.cast()`:

```pycon
>>> Const.cast(Cat(C(10, 4), C(1, 2)))
(const 6'd26)
```

They may be used in enumeration members, provided the enumeration inherits from [`amaranth.lib.enum.Enum`](stdlib/enum.md#amaranth.lib.enum.Enum):

```python
class Funct(amaranth.lib.enum.Enum, shape=4):
    ADD = 0
    ...

class Op(amaranth.lib.enum.Enum, shape=1):
    REG = 0
    IMM = 1

class Instr(amaranth.lib.enum.Enum, shape=5):
    ADD  = Cat(Funct.ADD, Op.REG)
    ADDI = Cat(Funct.ADD, Op.IMM)
    ...
```

They may also be provided as a pattern to the [match operator](#lang-matchop) and the [Case block](#lang-switch).

#### NOTE
At the moment, only the following expressions are constant-castable:

* `Const`
* `Cat()`
* `Slice`

This list will be expanded in the future.

<a id="lang-signals"></a>

## Signals

A *signal* is a value representing a (potentially) varying number. Signals can be [*assigned*](#lang-assigns) in a [combinational](#lang-comb) or [synchronous](#lang-sync) domain, in which case they are generated as wires or registers, respectively. Signals always have a well-defined value; they cannot be uninitialized or undefined.

### Signal shapes

A signal can be created with an explicitly specified shape (any [shape-like](#lang-shapelike) object); if omitted, the shape defaults to [`unsigned(1)`](reference.md#amaranth.hdl.unsigned). Although rarely useful, 0-bit signals are permitted.

```pycon
>>> Signal().shape()
unsigned(1)
>>> Signal(4).shape()
unsigned(4)
>>> Signal(range(-8, 7)).shape()
signed(4)
>>> Signal(Direction).shape()
unsigned(2)
>>> Signal(0).shape()
unsigned(0)
```

<a id="lang-signalname"></a>

### Signal names

Each signal has a *name*, which is used in the waveform viewer, diagnostic messages, Verilog output, and so on. In most cases, the name is omitted and inferred from the name of the variable or attribute the signal is placed into:

<!-- class dummy(object): pass
self = dummy() -->
```pycon
>>> foo = Signal()
>>> foo.name
'foo'
>>> self.bar = Signal()
>>> self.bar.name
'bar'
```

However, the name can also be specified explicitly with the `name=` parameter:

```pycon
>>> foo2 = Signal(name="second_foo")
>>> foo2.name
'second_foo'
```

The names do not need to be unique; if two signals with the same name end up in the same namespace while preparing for simulation or synthesis, one of them will be renamed to remove the ambiguity.

<a id="lang-initial"></a>

### Initial signal values

Each signal has an *initial value*, specified with the `init=` parameter. If the initial value is not specified explicitly, zero is used by default. An initial value can be specified with an integer or an enumeration member.

Signals [assigned](#lang-assigns) in a [combinational](#lang-comb) domain assume their initial value when none of the assignments are [active](#lang-active). Signals assigned in a [synchronous](#lang-sync) domain assume their initial value after *power-on reset* and, unless the signal is [reset-less](#lang-resetless), *explicit reset*. Signals that are used but never assigned are equivalent to constants of their initial value.

```pycon
>>> Signal(4).init
0
>>> Signal(4, init=5).init
5
>>> Signal(Direction, init=Direction.LEFT).init
1
```

<a id="lang-resetless"></a>

### Reset-less signals

Signals assigned in a [synchronous](#lang-sync) domain can be *resettable* or *reset-less*, specified with the `reset_less=` parameter. If the parameter is not specified, signals are resettable by default. Resettable signals assume their [initial value](#lang-initial) on explicit reset, which can be asserted via the [clock domain](#lang-clockdomains) or by [modifying control flow](#lang-controlinserter) with `ResetInserter`. Reset-less signals are not affected by explicit reset.

Signals assigned in a [combinational](#lang-comb) domain are not affected by the `reset_less` parameter.

```pycon
>>> Signal().reset_less
False
>>> Signal(reset_less=True).reset_less
True
```

<a id="lang-operators"></a>

## Operators

To describe computations, Amaranth values can be combined with each other or with [value-like](#lang-valuelike) objects using a rich set of arithmetic, bitwise, logical, bit sequence, and other *operators* to form *expressions*, which are themselves values.

<a id="lang-abstractexpr"></a>

### Performing or describing computations?

Code written in the Python language *performs* computations on concrete objects, like integers, with the goal of calculating a concrete result:

```pycon
>>> a = 5
>>> a + 1
6
```

In contrast, code written in the Amaranth language *describes* computations on abstract objects, like [signals](#lang-signals), with the goal of generating a hardware *circuit* that can be simulated, synthesized, and so on. Amaranth expressions are ordinary Python objects that represent parts of this circuit:

```pycon
>>> a = Signal(8, init=5)
>>> a + 1
(+ (sig a) (const 1'd1))
```

Although the syntax is similar, it is important to remember that Amaranth values exist on a higher level of abstraction than Python values. For example, expressions that include Amaranth values cannot be used in Python control flow structures:

```pycon
>>> if a == 0:
...     print("Zero!")
Traceback (most recent call last):
  ...
TypeError: Attempted to convert Amaranth value to Python boolean
```

Because the value of `a`, and therefore `a == 0`, is not known at the time when the `if` statement is executed, there is no way to decide whether the body of the statement should be executed—in fact, if the design is synthesized, by the time `a` has any concrete value, the Python program has long finished! To solve this problem, Amaranth provides its own [control flow syntax](#lang-control) that, also, manipulates circuits.

<a id="lang-widthext"></a>

### Width extension

Many of the operations described below (for example, addition, equality, bitwise OR, and part select) extend the width of one or both operands to match the width of the expression. When this happens, unsigned values are always zero-extended and signed values are always sign-extended regardless of the operation or signedness of the result.

<a id="lang-arithops"></a>

### Arithmetic operators

Most arithmetic operations on integers provided by Python can be used on Amaranth values, too.

Although Python integers have unlimited precision and Amaranth values are represented with a [finite amount of bits](#lang-values), arithmetics on Amaranth values never overflows because the width of the arithmetic expression is always sufficient to represent all possible results.

```pycon
>>> a = Signal(8)
>>> (a + 1).shape() # needs to represent 1 to 256
unsigned(9)
```

Similarly, although Python integers are always signed and Amaranth values can be either [signed or unsigned](#lang-values), if any of the operands of an Amaranth arithmetic expression is signed, the expression itself is also signed, matching the behavior of Python.

```pycon
>>> a = Signal(unsigned(8))
>>> b = Signal(signed(8))
>>> (a + b).shape() # needs to represent -128 to 382
signed(10)
```

While arithmetic computations never result in an overflow, [assigning](#lang-assigns) their results to signals may truncate the most significant bits.

The following table lists the arithmetic operations provided by Amaranth:

| Operation   | Description    |
|-------------|----------------|
| `a + b`     | addition       |
| `-a`        | negation       |
| `a - b`     | subtraction    |
| `a * b`     | multiplication |
| `a // b`    | floor division |
| `a % b`     | modulo         |
| `abs(a)`    | absolute value |

<a id="lang-cmpops"></a>

### Comparison operators

All comparison operations on integers provided by Python can be used on Amaranth values. However, due to a limitation of Python, chained comparisons (e.g. `a < b < c`) cannot be used.

Similar to arithmetic operations, if any operand of a comparison expression is signed, a signed comparison is performed. The result of a comparison is a 1-bit unsigned value.

The following table lists the comparison operations provided by Amaranth:

| Operation   | Description           |
|-------------|-----------------------|
| `a == b`    | equality              |
| `a != b`    | inequality            |
| `a < b`     | less than             |
| `a <= b`    | less than or equal    |
| `a > b`     | greater than          |
| `a >= b`    | greater than or equal |

<a id="lang-bitops"></a>

### Bitwise, shift, and rotate operators

All bitwise and shift operations on integers provided by Python can be used on Amaranth values as well.

Similar to arithmetic operations, if any operand of a bitwise expression is signed, the expression itself is signed as well. A shift expression is signed if the shifted value is signed. A rotate expression is always unsigned.

Rotate operations with variable rotate amounts cannot be efficiently synthesized for non-power-of-2 widths of the rotated value. Because of that, the rotate operations are only provided for constant rotate amounts, specified as Python [`int`](https://docs.python.org/3/library/functions.html#int)s.

The following table lists the bitwise and shift operations provided by Amaranth:

| Operation           | Description                               | Notes                                        |
|---------------------|-------------------------------------------|----------------------------------------------|
| `~a`                | bitwise NOT; complement                   |                                              |
| `a & b`             | bitwise AND                               |                                              |
| `a | b`             | bitwise OR                                |                                              |
| `a ^ b`             | bitwise XOR                               |                                              |
| `a >> b`            | arithmetic right shift by variable amount | <sup>[1](#opb1)</sup>, <sup>[2](#opb2)</sup> |
| `a << b`            | left shift by variable amount             | <sup>[2](#opb2)</sup>                        |
| `a.rotate_left(i)`  | left rotate by constant amount            | <sup>[3](#opb3)</sup>                        |
| `a.rotate_right(i)` | right rotate by constant amount           | <sup>[3](#opb3)</sup>                        |
| `a.shift_left(i)`   | left shift by constant amount             | <sup>[3](#opb3)</sup>                        |
| `a.shift_right(i)`  | right shift by constant amount            | <sup>[3](#opb3)</sup>                        |
* <a id='opb1'>**[1]**</a> Logical and arithmetic right shift of an unsigned value are equivalent. Logical right shift of a signed value can be expressed by [converting it to unsigned](#lang-convops) first.
* <a id='opb2'>**[2]**</a> Shift amount must be unsigned; integer shifts in Python require the amount to be positive.
* <a id='opb3'>**[3]**</a> Shift and rotate amounts can be negative, in which case the direction is reversed.

<a id="lang-hugeshift"></a>

#### NOTE
Because Amaranth ensures that the width of a variable left shift expression is wide enough to represent any possible result, variable left shift by a wide amount produces exponentially wider intermediate values, stressing the synthesis tools:

```pycon
>>> (1 << C(0, 32)).shape()
unsigned(4294967296)
```

Although Amaranth will detect and reject expressions wide enough to break other tools, it is a good practice to explicitly limit the width of a shift amount in a variable left shift.

<a id="lang-reduceops"></a>

<a id="lang-bool"></a>

### Reduction operators

Bitwise reduction operations on integers are not provided by Python, but are very useful for hardware. They are similar to bitwise operations applied “sideways”; for example, if bitwise AND is a binary operator that applies AND to each pair of bits between its two operands, then reduction AND is an unary operator that applies AND to all of the bits in its sole operand.

The result of a reduction is a 1-bit unsigned value.

The following table lists the reduction operations provided by Amaranth:

| Operation   | Description                                  | Notes                                       |
|-------------|----------------------------------------------|---------------------------------------------|
| `a.all()`   | reduction AND; are all bits set?             | <sup>[4](#opr1)</sup>                       |
| `a.any()`   | reduction OR; is any bit set?                | <sup>[4](#opr1)</sup> <sup>[6](#opr3)</sup> |
| `a.xor()`   | reduction XOR; is an odd number of bits set? |                                             |
| `a.bool()`  | conversion to boolean; is non-zero?          | <sup>[5](#opr2)</sup> <sup>[6](#opr3)</sup> |
* <a id='opr1'>**[4]**</a> Conceptually the same as applying the Python [`all()`](https://docs.python.org/3/library/functions.html#all) or [`any()`](https://docs.python.org/3/library/functions.html#any) function to the value viewed as a collection of bits.
* <a id='opr2'>**[5]**</a> Conceptually the same as applying the Python [`bool`](https://docs.python.org/3/library/functions.html#bool) function to the value viewed as an integer.
* <a id='opr3'>**[6]**</a> While the [`Value.any()`](reference.md#amaranth.hdl.Value.any) and [`Value.bool()`](reference.md#amaranth.hdl.Value.bool)  operators return the same value, the use of `a.any()` implies that `a` is semantically a bit sequence, and the use of `a.bool()` implies that `a` is semantically a number.

<a id="lang-logicops"></a>

### Logical operators

Unlike the arithmetic or bitwise operators, it is not possible to change the behavior of the Python logical operators `not`, `and`, and `or`. Due to that, logical expressions in Amaranth are written using bitwise operations on boolean (1-bit unsigned) values, with explicit boolean conversions added where necessary.

The following table lists the Python logical expressions and their Amaranth equivalents:

| Python expression   | Amaranth expression (any operands)   |
|---------------------|--------------------------------------|
| `not a`             | `~(a).bool()`                        |
| `a and b`           | `(a).bool() & (b).bool()`            |
| `a or b`            | `(a).bool() | (b).bool()`            |

When the operands are known to be boolean values, such as comparisons, reductions, or boolean signals, the `.bool()` conversion may be omitted for clarity:

| Python expression   | Amaranth expression (boolean operands)   |
|---------------------|------------------------------------------|
| `not p`             | `~(p)`                                   |
| `p and q`           | `(p) & (q)`                              |
| `p or q`            | `(p) | (q)`                              |

<a id="lang-logicprecedence"></a>

#### WARNING
Because of Python [operator precedence](https://docs.python.org/3/reference/expressions.html#operator-summary), logical operators bind less tightly than comparison operators whereas bitwise operators bind more tightly than comparison operators. As a result, all logical expressions in Amaranth **must** have parenthesized operands.

Omitting parentheses around operands in an Amaranth a logical expression is likely to introduce a subtle bug:

```pycon
>>> en = Signal()
>>> addr = Signal(8)
>>> en & (addr == 0) # correct
(& (sig en) (== (sig addr) (const 1'd0)))
>>> en & addr == 0 # WRONG! addr is truncated to 1 bit
(== (& (sig en) (sig addr)) (const 1'd0))
```

<!-- TODO: can we detect this footgun automatically? #380 -->

<a id="lang-negatebool"></a>

#### WARNING
When applied to Amaranth boolean values, the `~` operator computes negation, and when applied to Python boolean values, the `not` operator also computes negation. However, the `~` operator applied to Python boolean values produces an unexpected result:

<!-- >>> import warnings
>>> _warning_filters_backup = warnings.catch_warnings()
>>> _warning_filters_backup.__enter__() # have to do this horrific hack to make it work with `PYTHONWARNINGS=error` :(
>>> warnings.simplefilter("ignore", DeprecationWarning) -->
```pycon
>>> ~False
-1
>>> ~True
-2
```

Because of this, Python booleans used in Amaranth logical expressions **must** be negated with the `not` operator, not the `~` operator. Negating a Python boolean with the `~` operator in an Amaranth logical expression is likely to introduce a subtle bug:

```pycon
>>> stb = Signal()
>>> use_stb = True
>>> (not use_stb) | stb # correct
(| (const 1'd0) (sig stb))
>>> ~use_stb | stb # WRONG! MSB of 2-bit wide OR expression is always 1
(| (const 2'sd-2) (sig stb))
```

<!-- >>> _warning_filters_backup.__exit__() -->

Amaranth automatically detects some cases of misuse of `~` and emits a detailed diagnostic message.

<!-- TODO: this isn't quite reliable, #380 -->

<a id="lang-seqops"></a>

### Bit sequence operators

Apart from acting as numbers, Amaranth values can also be treated as bit [sequences](https://docs.python.org/3/library/stdtypes.html#typesseq), supporting slicing, concatenation, replication, and other sequence operations. Since some of the operators Python defines for sequences clash with the operators it defines for numbers, Amaranth gives these operators a different name. Except for the names, Amaranth values follow Python sequence semantics, with the least significant bit at index 0.

Because every Amaranth value has a single fixed width, bit slicing and replication operations require the subscripts and count to be constant, specified as Python [`int`](https://docs.python.org/3/library/functions.html#int)s. It is often useful to slice a value with a constant width and variable offset, but this cannot be expressed with the Python slice notation. To solve this problem, Amaranth provides additional *part select* operations with the necessary semantics.

The result of any bit sequence operation is an unsigned value.

The following table lists the bit sequence operations provided by Amaranth:

| Operation             | Description                                      | Notes                 |
|-----------------------|--------------------------------------------------|-----------------------|
| `len(a)`              | bit length; value width                          | <sup>[7](#ops1)</sup> |
| `a[i:j:k]`            | bit slicing by constant subscripts               | <sup>[8](#ops2)</sup> |
| `iter(a)`             | bit iteration                                    |                       |
| `a.bit_select(b, w)`  | overlapping part select with variable offset     |                       |
| `a.word_select(b, w)` | non-overlapping part select with variable offset |                       |
| `Cat(a, b)`           | concatenation                                    | <sup>[9](#ops3)</sup> |
| `a.replicate(n)`      | replication                                      |                       |
* <a id='ops1'>**[7]**</a> Words “length” and “width” have the same meaning when talking about Amaranth values. Conventionally, “width” is used.
* <a id='ops2'>**[8]**</a> All variations of the Python slice notation are supported, including “extended slicing”. E.g. all of `a[0]`, `a[1:9]`, `a[2:]`, `a[:-2]`, `a[::-1]`, `a[0:8:2]` select bits in the same way as other Python sequence types select their elements.
* <a id='ops3'>**[9]**</a> In the concatenated value, `a` occupies the least significant bits, and `b` the most significant bits. Any number of arguments (zero, one, two, or more) are supported.

For the operators introduced by Amaranth, the following table explains them in terms of Python code operating on tuples of bits rather than Amaranth values:

| Amaranth operation    | Equivalent Python code   |
|-----------------------|--------------------------|
| `Cat(a, b)`           | `a + b`                  |
| `a.replicate(n)`      | `a * n`                  |
| `a.bit_select(b, w)`  | `a[b:b+w]`               |
| `a.word_select(b, w)` | `a[b*w:b*w+w]`           |

#### WARNING
In Python, the digits of a number are written right-to-left (0th exponent at the right), and the elements of a sequence are written left-to-right (0th element at the left). This mismatch can cause confusion when numeric operations (like shifts) are mixed with bit sequence operations (like concatenations). For example, `Cat(C(0b1001), C(0b1010))` has the same value as `C(0b1010_1001)`, `val[4:]` is equivalent to `val >> 4`, and `val[-1]` refers to the most significant bit.

Such confusion can often be avoided by not using numeric and bit sequence operations in the same expression. For example, although it may seem natural to describe a shift register with a numeric shift and a sequence slice operations, using sequence operations alone would make it easier to understand.

#### NOTE
Could Amaranth have used a different indexing or iteration order for values? Yes, but it would be necessary to either place the most significant bit at index 0, or deliberately break the Python sequence type interface. Both of these options would cause more issues than using different iteration orders for numeric and sequence operations.

<a id="lang-matchop"></a>

### Match operator

The `val.matches(*patterns)` operator examines a value against a set of patterns. It evaluates to `Const(1)` if the value *matches* any of the patterns, and to `Const(0)` otherwise. What it means for a value to match a pattern depends on the type of the pattern.

If the pattern is a [`str`](https://docs.python.org/3/library/stdtypes.html#str), it is treated as a bit mask with “don’t care” bits. After removing whitespace, each character of the pattern is compared to the corresponding bit of the value, where the leftmost character of the pattern (with the lowest index) corresponds to the most significant bit of the value. If the pattern character is `'0'` or `'1'`, the comparison succeeds if the bit equals `0` or `1` correspondingly. If the pattern character is `'-'`, the comparison always succeeds. Aside from spaces and tabs, which are ignored, no other characters are accepted.

Otherwise, the pattern is [cast to a constant](#lang-constcasting) and compared to `val` using the [equality operator](#lang-cmpops).

For example, given a 8-bit value `val`, `val.matches(1, '---- -01-')` is equivalent to `(val == 1) | ((val & 0b0000_0110) == 0b0000_0010)`. Bit patterns in this operator are treated similarly to [bit sequence operators](#lang-bitops).

The [Case](#lang-switch) control flow block accepts the same patterns, with the same meaning, as the match operator.

<a id="lang-convops"></a>

### Conversion operators

The `.as_signed()` and `.as_unsigned()` conversion operators reinterpret the bits of a value with the requested signedness. This is useful when the same value is sometimes treated as signed and sometimes as unsigned, or when a signed value is constructed using slices or concatenations.

For example, `(pc + imm[:7].as_signed()).as_unsigned()` sign-extends the 7 least significant bits of `imm` to the width of `pc`, performs the addition, and produces an unsigned result.

<a id="lang-muxop"></a>

### Choice operator

The `Mux(sel, val1, val0)` choice expression (similar to the [conditional expression](https://docs.python.org/3/reference/expressions.html#if-expr) in Python) is equal to the operand `val1` if `sel` is non-zero, and to the other operand `val0` otherwise. If any of `val1` or `val0` are signed, the expression itself is signed as well.

<a id="lang-array"></a>

## Arrays

An *array* is a mutable collection that can be indexed not only with an [`int`](https://docs.python.org/3/library/functions.html#int) or with a [value-like](#lang-valuelike) object. When indexed with an [`int`](https://docs.python.org/3/library/functions.html#int), it behaves like a [`list`](https://docs.python.org/3/library/stdtypes.html#list). When indexed with a value-like object, it returns a proxy object containing the elements of the array that has three useful properties:

* The result of accessing an attribute of the proxy object or indexing it is another proxy object that contains the elements transformed in the same way.
* When the proxy object is [cast to a value](#lang-valuelike), all of its elements are also cast to a value, and an element is selected using the index originally used with the array.
* The proxy object can be used both in an expression and [as the target of an assignment](#lang-assigns).

Crucially, this means that any Python object can be added to an array; the only requirement is that the final result of any computation involving it is a value-like object. For example:

```python
pixels = Array([
    {"r": 180, "g": 92, "b": 230},
    {"r": 74, "g": 130, "b": 128},
    {"r": 115, "g": 58, "b": 31},
])
```

```pycon
>>> index = Signal(range(len(pixels)))
>>> pixels[index]["r"]
(proxy (array [180, 74, 115]) (sig index))
```

#### NOTE
An array becomes immutable after it is indexed for the first time. The elements of the array do not themselves become immutable, but it is not recommended to mutate them as the behavior can become unpredictable.

#### NOTE
Arrays, `amaranth.hdl.Array`, are distinct from and serve a different function than [`amaranth.lib.data.ArrayLayout`](stdlib/data.md#amaranth.lib.data.ArrayLayout).

<a id="lang-data"></a>

## Data structures

Amaranth provides aggregate data structures in the standard library module [`amaranth.lib.data`](stdlib/data.md#module-amaranth.lib.data).

<a id="lang-modules"></a>

## Modules

A *module* is a unit of the Amaranth design hierarchy: the smallest collection of logic that can be independently simulated, synthesized, or otherwise processed. Modules associate signals with [control domains](#lang-domains), provide [control flow syntax](#lang-control), manage [clock domains](#lang-clockdomains), and aggregate [submodules](#lang-submodules).

Every Amaranth design starts with a fresh module:

```pycon
>>> m = Module()
```

<a id="lang-domains"></a>

## Control domains

A *control domain* is a named group of [signals](#lang-signals) that change their value in identical conditions.

All designs have a single predefined *combinational domain*, containing all signals that change immediately when any value used to compute them changes. The name `comb` is reserved for the combinational domain, and refers to the same domain in all modules.

A design can also have any amount of user-defined *synchronous domains*, also called [clock domains](#lang-clockdomains), containing signals that change when a specific edge occurs on the domain’s clock signal or, for domains with asynchronous reset, on the domain’s reset signal. Most modules only use a single synchronous domain, conventionally called `sync`, but the name `sync` does not have to be used, and lacks any special meaning beyond being the default.

The behavior of assignments differs for signals in [combinational](#lang-comb) and [synchronous](#lang-sync) domains. Collectively, signals in synchronous domains contain the state of a design, whereas signals in the combinational domain cannot form feedback loops or hold state.

<a id="lang-assigns"></a>

### Assigning to signals

*Assignments* are used to change the values of signals. An assignment statement can be introduced with the `.eq(...)` syntax:

```pycon
>>> s = Signal()
>>> s.eq(1)
(eq (sig s) (const 1'd1))
```

Similar to [how Amaranth operators work](#lang-abstractexpr), an Amaranth assignment is an ordinary Python object used to describe a part of a circuit. An assignment does not have any effect on the signal it changes until it is added to a control domain in a module. Once added, it introduces logic into the circuit generated from that module.

<a id="lang-assignable"></a>

### Assignable values

An assignment can affect a value that is more complex than just a signal. It is possible to assign to any combination of [signals](#lang-signals), [bit slices](#lang-seqops), [concatenations](#lang-seqops), [part selects](#lang-seqops), and [array proxy objects](#lang-array) as long as it includes no other values:

```pycon
>>> a = Signal(8)
>>> b = Signal(4)
>>> Cat(a, b).eq(0)
(eq (cat (sig a) (sig b)) (const 1'd0))
>>> a[:4].eq(b)
(eq (slice (sig a) 0:4) (sig b))
>>> Cat(a, a).bit_select(b, 2).eq(0b11)
(eq (part (cat (sig a) (sig a)) (sig b) 2 1) (const 2'd3))
```

<a id="lang-assigndomains"></a>

### Assignment domains

The `m.d.<domain> += ...` syntax is used to add assignments to a specific control domain in a module. It can add just a single assignment, or an entire sequence of them:

```python
a = Signal()
b = Signal()
c = Signal()
m.d.comb += a.eq(1)
m.d.sync += [
    b.eq(c),
    c.eq(b),
]
```

If the name of a domain is not known upfront, the `m.d["<domain>"] += ...` syntax can be used instead:

```python
def add_toggle(num):
    t = Signal()
    m.d[f"sync_{num}"] += t.eq(~t)
add_toggle(2)
```

<a id="lang-signalgranularity"></a>

Every signal bit included in the target of an assignment becomes a part of the domain, or equivalently, *driven* by that domain. A signal bit can be either undriven or driven by exactly one domain; it is an error to add two assignments to the same signal bit to two different domains:

```pycon
>>> d = Signal()
>>> m.d.comb += d.eq(1)
>>> m.d.sync += d.eq(0)
Traceback (most recent call last):
  ...
amaranth.hdl.dsl.SyntaxError: Driver-driver conflict: trying to drive (sig d) bit 0 from d.sync, but it is already driven from d.comb
```

However, two different bits of a signal can be driven from two different domains without an issue:

```python
e = Signal(2)
m.d.comb += e[0].eq(1)
m.d.sync += e[1].eq(0)
```

In addition to assignments, [assertions](#lang-assert) and [debug prints](#lang-print) can be added using the same syntax.

<a id="lang-assignorder"></a>

### Assignment order

Unlike with two different domains, adding multiple assignments to the same signal to the same domain is well-defined.

Assignments to different signal bits apply independently. For example, the following two snippets are equivalent:

```python
a = Signal(8)
m.d.comb += [
    a[0:4].eq(C(1, 4)),
    a[4:8].eq(C(2, 4)),
]
```

```python
a = Signal(8)
m.d.comb += a.eq(Cat(C(1, 4), C(2, 4)))
```

If multiple assignments change the value of the same signal bits, the assignment that is added last determines the final value. For example, the following two snippets are equivalent:

```python
b = Signal(9)
m.d.comb += [
    b[0:9].eq(Cat(C(1, 3), C(2, 3), C(3, 3))),
    b[0:6].eq(Cat(C(4, 3), C(5, 3))),
    b[3:6].eq(C(6, 3)),
]
```

```python
b = Signal(9)
m.d.comb += b.eq(Cat(C(4, 3), C(6, 3), C(3, 3)))
```

Multiple assignments to the same signal bits are more useful when combined with control structures, which can make some of the assignments [active or inactive](#lang-active). If all assignments to some signal bits are [inactive](#lang-active), their final values are determined by the signal’s domain, [combinational](#lang-comb) or [synchronous](#lang-sync).

<a id="lang-control"></a>

## Control flow

Although it is possible to write any decision tree as a combination of [assignments](#lang-assigns) and [choice expressions](#lang-muxop), Amaranth provides *control flow syntax* tailored for this task: [If/Elif/Else](#lang-if), [Switch/Case](#lang-switch), and [FSM/State](#lang-fsm). The control flow syntax uses `with` blocks (it is implemented using [context managers](https://docs.python.org/3/reference/datamodel.html#context-managers)), for example:

```python
timer = Signal(8)
with m.If(timer == 0):
    m.d.sync += timer.eq(10)
with m.Else():
    m.d.sync += timer.eq(timer - 1)
```

While some Amaranth control structures are superficially similar to imperative control flow statements (such as Python’s `if`), their function—together with [expressions](#lang-abstractexpr) and [assignments](#lang-assigns)—is to describe circuits. The code above is equivalent to:

```python
timer = Signal(8)
m.d.sync += timer.eq(Mux(timer == 0, 10, timer - 1))
```

Because all branches of a decision tree affect the generated circuit, all of the Python code inside Amaranth control structures is always evaluated in the order in which it appears in the program. This can be observed through Python code with side effects, such as `print()`:

```python
timer = Signal(8)
with m.If(timer == 0):
    print("inside `If`")
    m.d.sync += timer.eq(10)
with m.Else():
    print("inside `Else`")
    m.d.sync += timer.eq(timer - 1)
```

```none
inside `If`
inside `Else`
```

<a id="lang-active"></a>

### Active and inactive assignments

An assignment added inside an Amaranth control structure, i.e. `with m.<...>:` block, is *active* if the condition of the control structure is satisfied, and *inactive* otherwise. For any given set of conditions, the final value of every signal assigned in a module is the same as if the inactive assignments were removed and the active assignments were performed unconditionally, taking into account the [assignment order](#lang-assignorder).

For example, there are two possible cases in the circuit generated from the following code:

```python
timer = Signal(8)
m.d.sync += timer.eq(timer - 1)
with m.If(timer == 0):
    m.d.sync += timer.eq(10)
```

When `timer == 0` is true, the code reduces to:

```default
m.d.sync += timer.eq(timer - 1)
m.d.sync += timer.eq(10)
```

Due to the [assignment order](#lang-assignorder), it further reduces to:

```default
m.d.sync += timer.eq(10)
```

When `timer == 0` is false, the code reduces to:

```default
m.d.sync += timer.eq(timer - 1)
```

Combining these cases together, the code above is equivalent to:

```python
timer = Signal(8)
m.d.sync += timer.eq(Mux(timer == 0, 10, timer - 1))
```

<a id="lang-if"></a>

### `If`/`Elif`/`Else` control blocks

Conditional control flow is described using a `with m.If(cond1):` block, which may be followed by one or more `with m.Elif(cond2):` blocks, and optionally a final `with m.Else():` block. This structure parallels Python’s own [if/elif/else](https://docs.python.org/3/reference/compound_stmts.html#if) control flow syntax. For example:

<!-- x_coord = Signal(8)
is_fporch = Signal()
is_active = Signal()
is_bporch = Signal() -->
```python
with m.If(x_coord < 4):
    m.d.comb += is_bporch.eq(1)
    m.d.sync += x_coord.eq(x_coord + 1)
with m.Elif((x_coord >= 4) & (x_coord < 364)):
    m.d.comb += is_active.eq(1)
    m.d.sync += x_coord.eq(x_coord + 1)
with m.Elif((x_coord >= 364) & (x_coord < 374)):
    m.d.comb += is_fporch.eq(1)
    m.d.sync += x_coord.eq(x_coord + 1)
with m.Else():
    m.d.sync += x_coord.eq(0)
```

Within a single `If`/`Elif`/`Else` sequence of blocks, the statements within at most one block will be active at any time. This will be the first block in the order of definition whose condition, [converted to boolean](#lang-bool), is true.

If an `Else` block is present, then the statements within exactly one block will be active at any time, and the sequence as a whole is called a *full condition*.

<a id="lang-switch"></a>

### `Switch`/`Case` control blocks

Case comparison, where a single value is examined against several different *patterns*, is described using a `with m.Switch(value):` block. This block can contain any amount of `with m.Case(*patterns)` and `with m.Default():` blocks. This structure parallels Python’s own [match/case](https://docs.python.org/3/reference/compound_stmts.html#match) control flow syntax. For example:

<!-- TODO: rename `Switch` to `Match`, to mirror `Value.matches()`? -->
<!-- is_even = Signal()
is_odd  = Signal()
too_big = Signal() -->
```python
value = Signal(4)

with m.Switch(value):
    with m.Case(0, 2, 4):
        m.d.comb += is_even.eq(1)
    with m.Case(1, 3, 5):
        m.d.comb += is_odd.eq(1)
    with m.Default():
        m.d.comb += too_big.eq(1)
```

Within a single `Switch` block, the statements within at most one block will be active at any time. This will be the first `Case` block in the order of definition whose pattern [matches](#lang-matchop) the value, or the first `Default` block, whichever is earlier.

If a `Default` block is present, or the patterns in the `Case` blocks cover every possible `Switch` value, then the statements within exactly one block will be active at any time, and the sequence as a whole is called a *full condition*.

<a id="lang-fsm"></a>

### `FSM`/`State` control blocks

Simple [finite state machines](https://en.wikipedia.org/wiki/Finite-state_machine) are described using a `with m.FSM():` block. This block can contain one or more `with m.State("Name")` blocks. In addition to these blocks, the `m.next = "Name"` syntax chooses which state the FSM enters on the next clock cycle. For example, this FSM performs a bus read transaction once after reset:

```python
bus_addr = Signal(16)
r_data   = Signal(8)
r_en     = Signal()
latched  = Signal.like(r_data)

with m.FSM():
    with m.State("Set Address"):
        m.d.sync += addr.eq(0x1234)
        m.next = "Strobe Read Enable"

    with m.State("Strobe Read Enable"):
        m.d.comb += r_en.eq(1)
        m.next = "Sample Data"

    with m.State("Sample Data"):
        m.d.sync += latched.eq(r_data)
        with m.If(r_data == 0):
            m.next = "Set Address" # try again
```

<!-- TODO: FSM() should require keyword arguments, for good measure -->

The initial (and reset) state of the FSM can be provided when defining it using the `with m.FSM(init="Name"):` argument. If not provided, it is the first state in the order of definition. For example, this definition is equivalent to the one at the beginning of this section:

```python
with m.FSM(init="Set Address"):
    ...
```

The FSM belongs to a [clock domain](#lang-domains), which is specified using the `with m.FSM(domain="dom")` argument. If not specified, it is the `sync` domain. For example, this definition is equivalent to the one at the beginning of this section:

```python
with m.FSM(domain="sync"):
    ...
```

To determine (from code that is outside the FSM definition) whether it is currently in a particular state, the FSM can be captured; its `.ongoing("Name")` method returns a value that is true whenever the FSM is in the corresponding state. For example:

```python
with m.FSM() as fsm:
    ...

with m.If(fsm.ongoing("Set Address")):
    ...
```

Note that in Python, assignments made using `with x() as y:` syntax persist past the end of the block.

<!-- TODO: `ongoing` currently creates a state if it doesn't exist, which seems clearly wrong but maybe some depend on it? add a diagnostic here -->
<!-- TODO: `m.next` does the same, which is worse because adding a diagnostic is harder -->

#### WARNING
If you make a typo in the state name provided to `m.next = ...` or `fsm.ongoing(...)`, an empty and unreachable state with that name will be created with no diagnostic message.

This hazard will be eliminated in the future.

#### WARNING
If a non-string object is provided as a state name to `with m.State(...):`, it is cast to a string first, which may lead to surprising behavior. `with m.State(...):` **does not** treat an enumeration value specially; if one is provided, it is cast to a string, and its numeric value will have no correspondence to the numeric value of the generated state signal.

This hazard will be eliminated in the future.

<!-- TODO: we should probably have `fsm.next = "Name"` or `fsm.next("Name")` instead -->

#### NOTE
If you are nesting two state machines within each other, the `m.next = ...` syntax always refers to the innermost one. To change the state of the outer state machine from within the inner one, use an intermediate signal.

<a id="lang-comb"></a>

## Combinational evaluation

Signals in the combinational [control domain](#lang-domains) change whenever any value used to compute them changes. The final value of a combinational signal is equal to its [initial value](#lang-initial) updated by the [active assignments](#lang-active) in the [assignment order](#lang-assignorder). Combinational signals cannot hold any state.

Consider the following code:

<!-- en = Signal()
b = Signal(8) -->
```python
a = Signal(8, init=1)
with m.If(en):
    m.d.comb += a.eq(b + 1)
```

Whenever the signals `en` or `b` change, the signal `a` changes as well. If `en` is false, the final value of `a` is its initial value, `1`. If `en` is true, the final value of `a` is equal to `b + 1`.

A combinational signal that is computed directly or indirectly based on its own value is a part of a *combinational feedback loop*, sometimes shortened to just *feedback loop*. Combinational feedback loops can be stable (e.g. implement a constant driver or a transparent latch), or unstable (e.g. implement a ring oscillator). Amaranth prohibits using assignments to describe any kind of a combinational feedback loop, including transparent latches.

#### NOTE
In the exceedingly rare case when a combinational feedback loop is desirable, it is possible to implement it by directly instantiating technology primitives (e.g. device-specific LUTs or latches). This is also the only way to introduce a combinational feedback loop with well-defined behavior in simulation and synthesis, regardless of the HDL being used.

<a id="lang-sync"></a>

## Synchronous evaluation

Signals in synchronous [control domains](#lang-domains) change whenever the *active edge* (a 0-to-1 or 1-to-0 transition, configured when [creating the domain](#lang-clockdomains)) occurs on the clock of the synchronous domain. In addition, the signals in [clock domains](#lang-clockdomains) with an asynchronous reset change when such a reset is asserted. The final value of a synchronous signal is equal to its [initial value](#lang-initial) if the reset (of any type) is asserted, or to its current value updated by the [active assignments](#lang-active) in the [assignment order](#lang-assignorder) otherwise. Synchronous signals always hold state.

Consider the following code:

<!-- up = Signal()
down = Signal() -->
```python
timer = Signal(8)

with m.If(up):
    m.d.sync += timer.eq(timer + 1)
with m.Elif(down):
    m.d.sync += timer.eq(timer - 1)
```

Whenever there is a transition on the clock of the `sync` domain, the `timer` signal is incremented by one if `up` is true, decremented by one if `down` is true, and retains its value otherwise.

<a id="lang-assert"></a>

## Assertions

Some properties are so important that if they are violated, the computations described by the design become meaningless. These properties should be guarded with an `Assert` statement that immediately terminates the simulation if its condition is false. Assertions should generally be added to a [synchronous domain](#lang-sync), and may have an optional message printed when it is violated:

```python
ip = Signal(16)
m.d.sync += Assert(ip < 128, "instruction pointer past the end of program code!")
```

Assertions may be nested within a [control block](#lang-control):

<!-- booting = Signal() -->
```python
with m.If(~booting):
    m.d.sync += Assert(ip < 128)
```

#### WARNING
While is is also possible to add assertions to the [combinational domain](#lang-comb), simulations of combinational circuits may have *glitches*: instantaneous, transient changes in the values of expressions that are being computed which do not affect the result of the computation (and are not visible in most waveform viewers for that reason). Depending on the tools used for simulation, a glitch in the condition of an assertion or of a [control block](#lang-control) that contains it may cause the simulation to be terminated, even if the glitch would have been instantaneously resolved afterwards.

If the condition of an assertion is assigned in a synchronous domain, then it is safe to add that assertion in the combinational domain. For example, neither of the assertions in the example below will be violated due to glitches, regardless of which domain the `ip` and `booting` signals are driven by:

```python
ip_sync = Signal.like(ip)
m.d.sync += ip_sync.eq(ip)

m.d.comb += Assert(ip_sync < 128)
with m.If(booting):
    m.d.comb += Assert(ip_sync < 128)
```

Assertions should be added in a [synchronous domain](#lang-sync) when possible. In cases where it is not, such as if the condition is a signal that is assigned in a synchronous domain elsewhere, care should be taken while adding the assertion to the combinational domain.

<a id="lang-print"></a>

## Debug printing

The value of any expression, or of several of them, can be printed to the terminal during simulation using the `Print` statement. When added to the [combinational domain](#lang-comb), the value of an expression is printed whenever it changes:

```python
state = Signal()
m.d.comb += Print(state)
```

When added to a [synchronous domain](#lang-sync), the value of an expression is printed whenever the active edge occurs on the clock of that domain:

```python
m.d.sync += Print("on tick: ", state)
```

The `Print` statement, regardless of the domain, may be nested within a [control block](#lang-control):

```python
old_state = Signal.like(state)
m.d.sync += old_state.eq(state)
with m.If(state != old_state):
    m.d.sync += Print("was: ", old_state, "now: ", state)
```

The arguments to the `Print` statement have the same meaning as the arguments to the Python [`print()`](https://docs.python.org/3/library/functions.html#print) function, with the exception that only `sep` and `end` keyword arguments are supported. In addition, the `Format` helper can be used to apply formatting to the values, similar to the Python [`str.format()`](https://docs.python.org/3/library/stdtypes.html#str.format) method:

```python
addr = Signal(32)
m.d.sync += Print(Format("address: {:08x}", addr))
```

In both `Print` and `Format`, arguments that are not Amaranth [values](#lang-values) are formatted using the usual Python rules. The optional second `message` argument to `Assert` (described [above](#lang-assert)) also accepts a string or the `Format` helper:

```python
m.d.sync += Assert((addr & 0b111) == 0, message=Format("unaligned address {:08x}!", addr))
```

<a id="lang-clockdomains"></a>

## Clock domains

A new synchronous [control domain](#lang-domains), which is more often called a *clock domain*, can be defined in a design by creating a `ClockDomain` object and adding it to the `m.domains` collection:

```python
m.domains.video = cd_video = ClockDomain(local=True)
```

If the name of the domain is not known upfront, another, less concise, syntax can be used instead:

```python
def add_video_domain(n):
    cd = ClockDomain(f"video_{n}", local=True)
    m.domains += cd
    return cd

add_video_domain(2)
```

#### NOTE
Whenever the created `ClockDomain` object is immediately assigned using the `domain_name = ClockDomain(...)` or `m.domains.domain_name = ClockDomain(...)` syntax, the name of the domain may be omitted from the `ClockDomain()` invocation. In other cases, it must be provided as the first argument.

A clock domain always has a clock signal, which can be accessed through the `cd.clk` attribute. By default, the *active edge* of the clock domain is positive; this means that the signals in the domain change when the clock signal transitions from 0 to 1. A clock domain can be configured to have a negative active edge so that signals in it change when the clock signal transitions from 1 to 0:

```python
m.domains.jtag = ClockDomain(clk_edge="neg", local=True)
```

A clock domain also has a reset signal, which can be accessed through the `cd.rst` attribute. The reset signal is always active-high: the signals in the clock domain are reset if the value of the reset signal is 1. The [initial value](#lang-initial) of this signal is 0, so if the reset signal is never assigned, the signals in the clock domain are never explicitly reset (they are still [reset at power-on](#lang-initial)). Nevertheless, if its existence is undesirable, the clock domain can be configured to omit it:

```python
m.domains.startup = ClockDomain(reset_less=True, local=True)
```

Signals in a reset-less clock domain can still be explicitly reset using the `ResetInserter` [control flow modifier](#lang-controlinserter).

If a clock domain is defined in a module, all of its [submodules](#lang-submodules) can refer to that domain under the same name.

#### WARNING
Always provide the `local=True` keyword argument when defining a clock domain. The behavior of clock domains defined without this keyword argument is subject to change in near future, and is intentionally left undocumented.

#### WARNING
Clock domains use synchronous reset unless otherwise specified. Clock domains with asynchronous reset are implemented, but their behavior is subject to change in near future, and is intentionally left undocumented.

<a id="lang-latesignals"></a>

### Late binding of clock and reset signals

Clock domains are *late bound*, which means that their signals and properties can be referred to using the domain’s name before the `ClockDomain` object with that name is created and added to the design. This happens whenever [an assignment is added](#lang-assigns) to a domain. In some cases, it is necessary to refer to the domain’s clock or reset signal using only the domain’s name. The `ClockSignal` and `ResetSignal` values make this possible:

<!-- m = Module()
bus_clk = Signal()
bus_rstn = Signal() -->
```python
m.d.comb += [
    ClockSignal().eq(bus_clk),
    ResetSignal().eq(~bus_rstn),
]
```

In this example, once the design is processed, the clock signal of the clock domain `sync` found in this module or one of its containing modules will be equal to `bus_clk`. The reset signal of the same clock domain will be equal to the negated `bus_rstn`. With the `sync` domain created in the same module, these statements become equivalent to:

<!-- TODO: explain the difference (or lack thereof, eventually) between m.d, m.domain, and m.domains -->
```python
m.domains.sync = cd_sync = ClockDomain(local=True)
m.d.comb += [
    cd_sync.clk.eq(bus_clk),
    cd_sync.rst.eq(~bus_rstn),
]
```

The `ClockSignal` and `ResetSignal` values may also be assigned to other signals and used in expressions. They take a single argument, which is the name of the domain; if not specified, it defaults to `"sync"`.

#### WARNING
Be especially careful when using `ClockSignal` or `cd.clk` in expressions. Assigning to and from a clock signal is usually safe; any other operations may have unpredictable results. Consult the documentation for your synthesis toolchain and platform to understand which operations with a clock signal are permitted.

FPGAs usually have dedicated clocking facilities that can be used to disable, divide, or multiplex clock signals. When targeting an FPGA, these facilities should be used if at all possible, and expressions like `ClockSignal() & en` or `Mux(sel, ClockSignal("a"), ClockSignal("b"))` should be avoided.

<a id="lang-elaboration"></a>

## Elaboration

Amaranth designs are built from a hierarchy of smaller subdivisions, which are called *elaboratables*. The process of creating a data structure representing the behavior of a complete design by composing such subdivisions together is called *elaboration*.

An elaboratable is any Python object that inherits from the `Elaboratable` base class and implements the `elaborate()`  method:

```python
class Counter(Elaboratable):
    def elaborate(self, platform):
        m = Module()

        ...

        return m
```

The `elaborate()` method must either return an instance of `Module` or `Instance` to describe the behavior of the elaboratable, or delegate it by returning another elaboratable object.

#### NOTE
Instances of `Module` also implement the `elaborate()` method, which returns a special object that represents a fragment of a netlist. Such an object cannot be constructed without using `Module`.

The `platform` argument received by the `elaborate()` method can be `None`, an instance of [a built-in platform](platform.md#platform), or a custom object. It is used for [dependency injection](https://en.wikipedia.org/wiki/Dependency_injection) and to contain the state of a design while it is being elaborated.

#### WARNING
The `elaborate()` method should not modify the `self` object it receives other than for debugging and experimentation. Elaborating the same design twice with two identical platform objects should produce two identical netlists. If the design needs to be modified after construction, this should happen before elaboration.

It is not possible to ensure that a design which modifies itself during elaboration is correctly converted to a netlist because the relative order in which the `elaborate()` methods are called within a single design is not guaranteed.

The Amaranth standard library provides *components*: elaboratable objects that also include a description of their interface. Unless otherwise necessary, an elaboratable should inherit from [`amaranth.lib.wiring.Component`](stdlib/wiring.md#amaranth.lib.wiring.Component) rather than plain `Elaboratable`. See the [introduction to interfaces and components](stdlib/wiring.md#wiring-introduction) for details.

<a id="lang-submodules"></a>

### Submodules

An elaboratable can be included within another elaboratable, which is called its *containing elaboratable*, by adding it as a submodule:

```python
m.submodules.counter = counter = Counter()
```

If the name of a submodule is not known upfront, a different syntax should be used:

```python
for n in range(3):
    m.submodules[f"counter_{n}"] = Counter()
```

A submodule can also be added without specifying a name:

```python
counter = Counter()
m.submodules += counter
```

A non-Amaranth design unit can be added as a submodule using an [instance](#lang-instance).

<a id="lang-controlinserter"></a>

### Modifying control flow

Control flow within an elaboratable can be altered without introducing a new clock domain by using *control flow modifiers* that affect [synchronous evaluation](#lang-sync) of signals in a specified domain (or domains). They never affect [combinational evaluation](#lang-comb). There are two control flow modifiers:

* `ResetInserter` introduces a synchronous reset input (or inputs), updating all of the signals in the specified domains to their [initial value](#lang-initial) whenever the active edge occurs on the clock of the domain *if* the synchronous reset input is asserted.
* `EnableInserter` introduces a synchronous enable input (or inputs), preventing any of the signals in the specified domains from changing value whenever the active edge occurs on the clock of the domain *unless* the synchronous enable input is asserted.

Control flow modifiers use the syntax `Modifier(controls)(elaboratable)`, where `controls` is a mapping from [clock domain](#lang-clockdomains) names to 1-wide [values](#lang-values) and `elaboratable` is any [elaboratable](#lang-elaboration) object. When only the `sync` domain is involved, instead of writing `Modifier({"sync": input})(elaboratable)`, the equivalent but shorter `Modifier(input)(elaboratable)` syntax can be used.

The result of applying a control flow modifier to an elaboratable is, itself, an elaboratable object. A common way to use a control flow modifier is to apply it to another elaboratable while adding it as a submodule:

<!-- m = Module() -->
```python
rst = Signal()
m.submodules.counter = counter = ResetInserter(rst)(Counter())
```

A control flow modifier affects all logic within a given elaboratable and clock domain, which includes the submodules of that elaboratable.

#### NOTE
Applying a control flow modifier to an elaboratable does not mutate it; a new proxy object is returned that forwards attribute accesses and method calls to the original elaboratable. Whenever this proxy object is elaborated, it manipulates the circuit defined by the original elaboratable to include the requested control inputs.

#### NOTE
It is possible to apply several control flow modifiers to the same elaboratable, even if the same domain is used. For `ResetInserter`, the signals in a domain are held at their initial value whenever any of the reset inputs for that domain are asserted (logical OR), and for `EnableInserter`, the signals in a domain are allowed to update whenever all of the enable signals for that domain are asserted (logical AND).

Consider the following code:

<!-- z = Signal()
n = Signal(8)
en = Signal()
rst = Signal() -->
```python
m = Module()
m.d.sync += n.eq(n + 1)
m.d.comb += z.eq(n == 0)

m = ResetInserter({"sync": rst})(m)
m = EnableInserter({"sync": en})(m)
```

The application of control flow modifiers in it causes the behavior of the final `m` to be identical to that of this module:

```python
m = Module()
with m.If(en):
    m.d.sync += n.eq(n + 1)
with m.If(rst):
    m.d.sync += n.eq(n.init)
m.d.comb += z.eq(n == 0)
```

<!-- TODO: link to a clock gating primitive if/when we ever get one, from a tip about EnableInserter similar to the tip about ResetInserter above -->

<a id="lang-domainrenamer"></a>

### Renaming domains

A reusable [elaboratable](#lang-elaboration) usually specifies the use of one or more [clock domains](#lang-clockdomains) while leaving the details of clocking and initialization to a later phase in the design process. `DomainRenamer` can be used to alter a reusable elaboratable for integration in a specific design. Most elaboratables use a single clock domain named `sync`, and `DomainRenamer` makes it easy to place such elaboratables in any clock domain of a design.

Clock domains can be renamed using the syntax `DomainRenamer(domains)(elaboratable)`, where `domains` is a mapping from clock domain names to clock domain names and `elaboratable` is any [elaboratable](#lang-elaboration) object. The keys of `domains` correspond to existing clock domain names specified by `elaboratable`, and the values of `domains` correspond to the clock domain names from the containing elaboratable that will be used instead. When only the `sync` domain is being renamed, instead of writing `DomainRenamer({"sync": name})(elaboratable)`, the equivalent but shorter `DomainRenamer(name)(elaboratable)` syntax can be used.

The result of renaming clock domains in an elaboratable is, itself, an elaboratable object. A common way to rename domains is to apply `DomainRenamer` to another elaboratable while adding it as a submodule:

<!-- m = Module() -->
```python
m.submodules.counter = counter = DomainRenamer("video")(counter)
```

Renaming a clock domain affects all logic within a given elaboratable and clock domain, which includes the submodules of that elaboratable. It does not affect any logic outside of that elaboratable.

#### NOTE
Renaming domains in an elaboratable does not mutate it; a new proxy object is returned that forwards attribute accesses and method calls to the original elaboratable. Whenever this proxy object is elaborated, it manipulates the circuit defined by the original elaboratable to use the requested clock domain.

#### NOTE
It is possible to rename domains in an elaboratable and also apply [control flow modifiers](#lang-controlinserter).

Consider the following code:

<!-- count = Signal(8)
zero = Signal() -->
```python
m = Module()
m.d.sync += count.eq(count + 1)
m.d.comb += zero.eq(count == 0)

m = DomainRenamer({"sync": "video"})(m)
```

The renaming of the `sync` clock domain in it causes the behavior of the final `m` to be identical to that of this module:

```python
m = Module()
m.d.video += count.eq(count + 1)
m.d.comb += zero.eq(count == 0)
```

#### WARNING
A combinational signal can change synchronously to a clock domain, as in the example above, in which case it may only be sampled from the same clock domain unless explicitly synchronized. Renaming a clock domain must be assumed to potentially affect any output of an elaboratable.

<a id="lang-memory"></a>

## Memories

Amaranth provides support for memories in the standard library module [`amaranth.lib.memory`](stdlib/memory.md#module-amaranth.lib.memory).

<a id="lang-iovalues"></a>

## I/O values

To interoperate with external circuitry, Amaranth provides *core I/O values*, which represent bundles of wires carrying uninterpreted signals. Unlike regular [values](#lang-values), which represent binary numbers and can be [assigned](#lang-assigns) to create a unidirectional connection or used in computations, core I/O values represent electrical signals that may be digital or analog and have no [shape](#lang-shapes), cannot be assigned, used in computations, or simulated.

Core I/O values are only used to define connections between non-Amaranth building blocks that traverse an Amaranth design, including [instances](#lang-instance) and [I/O buffer instances](#lang-iobufferinstance).

<a id="lang-ioports"></a>

### I/O ports

A *core I/O port* is a core I/O value representing a connection to a port of the topmost module in the [design hierarchy](#lang-submodules). It can be created with an explicitly specified width.

```python
from amaranth.hdl import IOPort
```

```pycon
>>> port = IOPort(4)
>>> port.width
4
```

Core I/O ports can be named in the same way as [signals](#lang-signalname):

```pycon
>>> clk_port = IOPort(1, name="clk")
>>> clk_port.name
'clk'
```

If two core I/O ports with the same name exist in a design, one of them will be renamed to remove the ambiguity. Because the name of a core I/O port is significant, they should be named unambiguously.

<a id="lang-ioops"></a>

### I/O operators

Core I/O values support only a limited set of [sequence](https://docs.python.org/3/library/stdtypes.html#typesseq) operators, all of which return another core I/O value. The following table lists the operators provided by Amaranth for core I/O values:

| Operation   | Description                    | Notes                                           |
|-------------|--------------------------------|-------------------------------------------------|
| `len(a)`    | length; width                  | <sup>[10](#iops1)</sup>                         |
| `a[i:j:k]`  | slicing by constant subscripts | <sup>[11](#iops2)</sup>                         |
| `iter(a)`   | iteration                      |                                                 |
| `Cat(a, b)` | concatenation                  | <sup>[12](#iops3)</sup> <sup>[13](#iops4)</sup> |
* <a id='iops1'>**[10]**</a> Words “length” and “width” have the same meaning when talking about Amaranth I/O values. Conventionally, “width” is used.
* <a id='iops2'>**[11]**</a> All variations of the Python slice notation are supported, including “extended slicing”. E.g. all of `a[0]`, `a[1:9]`, `a[2:]`, `a[:-2]`, `a[::-1]`, `a[0:8:2]` select wires in the same way as other Python sequence types select their elements.
* <a id='iops3'>**[12]**</a> In the concatenated value, `a` occupies the lower indices and `b` the higher indices. Any number of arguments (zero, one, two, or more) are supported.
* <a id='iops4'>**[13]**</a> Concatenation of zero arguments, `Cat()`, returns a 0-bit regular value, however any such value is accepted (and ignored) anywhere an I/O value is expected.

<a id="lang-instance"></a>

## Instances

<!-- attributes are not documented because they can be easily used to break soundness and we don't document them for signals either; they are rarely necessary for interoperability -->

A submodule written in a non-Amaranth language is called an *instance*. An instance can be written in any language supported by the synthesis toolchain; usually, that is (System)Verilog, VHDL, or a language that is translated to one of those two. Adding an instance as a submodule corresponds to “module instantiation” in (System)Verilog and “component instantiation” in VHDL, and is done by specifying the following:

* The *type* of an instance is the name of a (System)Verilog module, VHDL entity or component, or another HDL design unit that is being instantiated.
* The *name* of an instance is the name of the submodule within the containing elaboratable.
* The *attributes* of an instance correspond to attributes of a (System)Verilog module instance, or a custom attribute of a VHDL entity or component instance. Attributes applied to instances are interpreted by the synthesis toolchain rather than the HDL.
* The *parameters* of an instance correspond to parameters of a (System)Verilog module instance, or a generic constant of a VHDL entity or component instance. Not all HDLs allow their design units to be parameterized during instantiation.
* The *inputs*, *outputs*, and *inouts* of an instance correspond to input ports, output ports, and bidirectional ports of the external design unit.

An instance can be added as a submodule using the `m.submodules.name = Instance("type", ...)` syntax, where `"type"` is the type of the instance as a string (which is passed to the synthesis toolchain uninterpreted), and `...` is a list of parameters, inputs, and outputs. Depending on whether the name of an attribute, parameter, input, or output can be written as a part of a Python identifier or not, one of two possible syntaxes is used to specify them:

* An attribute is specified using the `a_ANAME=attr` or `("a", "ANAME", attr)` syntaxes. The `attr` must be an [`int`](https://docs.python.org/3/library/functions.html#int), a [`str`](https://docs.python.org/3/library/stdtypes.html#str), or a `Const`.
* A parameter is specified using the `p_PNAME=param` or `("p", "PNAME", param)` syntaxes. The `param` must be an [`int`](https://docs.python.org/3/library/functions.html#int), a [`str`](https://docs.python.org/3/library/stdtypes.html#str), or a `Const`.
* An input is specified using the `i_INAME=in_val` or `("i", "INAME", in_val)` syntaxes. The `in_val` must be a [core I/O value](#lang-iovalues) or a [value-like](#lang-valuelike) object.
* An output is specified using the `o_ONAME=out_val` or `("o", "ONAME", out_val)` syntaxes. The `out_val` must be a [core I/O value](#lang-iovalues) or a [value-like](#lang-valuelike) object that casts to a [signal](#lang-signals), a concatenation of signals, or a slice of a signal.
* An inout is specified using the `io_IONAME=inout_val` or `("io", "IONAME", inout_val)` syntaxes. The `inout_val` must be a [core I/O value](#lang-iovalues).

The two following examples use both syntaxes to add the same instance of type `external` as a submodule named `processor`:

<!-- i_data = Signal(8)
o_data = Signal(8)
io_pin = IOPort(1)
m = Module() -->
```python
m.submodules.processor = Instance("external",
    p_width=8,
    i_clk=ClockSignal(),
    i_rst=ResetSignal(),
    i_en=1,
    i_mode=Const(3, unsigned(4)),
    i_data_in=i_data,
    o_data_out=o_data,
    io_pin=io_pin,
)
```

<!-- m = Module() -->
```python
m.submodules.processor = Instance("external",
    ("p", "width", 8),
    ("i", "clk", ClockSignal()),
    ("i", "rst", ResetSignal()),
    ("i", "en", 1),
    ("i", "mode", Const(3, unsigned(4))),
    ("i", "data_in", i_data),
    ("o", "data_out", o_data),
    ("io", "pin", io_pin),
)
```

Like a regular submodule, an instance can also be added without specifying a name:

```python
m.submodules += Instance("external",
    # ...
)
```

Although an `Instance` is not an elaboratable, as a special case, it can be returned from the `elaborate()` method. This is conveinent for implementing an elaboratable that adorns an instance with an Amaranth interface:

```python
from amaranth import vendor


class FlipFlop(Elaboratable):
    def __init__(self):
        self.d = Signal()
        self.q = Signal()

    def elaborate(self, platform):
        # Decide on the instance to use based on the platform we are elaborating for.
        if isinstance(platform, vendor.LatticeICE40Platform):
            return Instance("SB_DFF",
                i_C=ClockSignal(),
                i_D=self.d,
                o_Q=self.q
            )
        else:
            raise NotImplementedError
```

<a id="lang-iobufferinstance"></a>

## I/O buffer instances

#### NOTE
I/O buffer instances are a low-level primitive which is documented to ensure that the standard library does not rely on private interfaces in the core language. Most designers should use the [`amaranth.lib.io`](stdlib/io.md#module-amaranth.lib.io) module instead.

An *I/O buffer instance* is a submodule that allows connecting [core I/O values](#lang-iovalues) and regular [values](#lang-values) without the use of an external, toolchain- and technology-dependent [instance](#lang-instance). It can be created in four configurations: input, output, tristatable output, and bidirectional (input/output).

```python
from amaranth.hdl import IOBufferInstance

m = Module()
```

In the input configuration, the buffer instance combinationally drives a signal `i` by the port:

```python
port = IOPort(4)
port_i = Signal(4)
m.submodules += IOBufferInstance(port, i=port_i)
```

In the output configuration, the buffer instance combinationally drives the port by a value `o`:

```python
port = IOPort(4)
port_o = Signal(4)
m.submodules += IOBufferInstance(port, o=port_o)
```

In the tristatable output configuration, the buffer instance combinationally drives the port by a value `o` if `oe` is asserted, and does not drive (leaves in a high-impedance state, or tristates) the port otherwise:

```python
port = IOPort(4)
port_o = Signal(4)
port_oe = Signal()
m.submodules += IOBufferInstance(port, o=port_o, oe=port_oe)
```

In the bidirectional (input/output) configuration, the buffer instance combinationally drives a signal `i` by the port, combinationally drives the port by a value `o` if `oe` is asserted, and does not drive (leaves in a high-impedance state, or tristates) the port otherwise:

```python
port = IOPort(4)
port_i = Signal(4)
port_o = Signal(4)
port_oe = Signal()
m.submodules += IOBufferInstance(port, i=port_i, o=port_o, oe=port_oe)
```

The width of the `i` and `o` values (when present) must be the same as the width of the port, and the width of the `oe` value must be 1.


# install.html.md

# Installation

<a id="install-playground"></a>

## In-browser playground

You can try Amaranth out without installing anything by visiting the [Amaranth Playground](https://amaranth-lang.org/play/). The playground webpage contains a [fully functional Python interpreter](https://pyodide.org/en/stable/) and an Amaranth toolchain that can simulate a design, display waveforms, and generate Verilog code. It works on all modern browsers that support [WebAssembly](https://webassembly.org/), including Firefox, Chrome, and Edge.

<a id="install-sysreqs"></a>

## System requirements

<!-- This version requirement needs to be synchronized with the one in pyproject.toml! -->

Amaranth HDL requires Python 3.8; it works on [CPython](https://www.python.org/) 3.8 (or newer), and works faster on [PyPy3.8](https://www.pypy.org/) 7.3.7 (or newer). Installation requires [pip](https://pip.pypa.io/en/stable/) 23.0 (or newer).

For most workflows, Amaranth requires [Yosys](https://yosyshq.net/yosys/) 0.40 (or newer). A [compatible version of Yosys](https://pypi.org/project/amaranth-yosys/) is distributed via [PyPI](https://pypi.org/) for most popular platforms, so it is usually not necessary to install Yosys separately.

Simulating Amaranth code requires no additional software. However, a waveform viewer like [Surfer](https://surfer-project.org/) or [GTKWave](https://gtkwave.sourceforge.net/) is invaluable for debugging. As an alternative, the [Amaranth Playground](https://amaranth-lang.org/play/) can be used to display waveforms for simple designs.

Synthesizing, placing and routing an Amaranth design for an FPGA requires the FPGA family specific toolchain. The open source iCE40, ECP5, MachXO2/3, Nexus, and Gowin toolchains are distributed via [PyPI](https://pypi.org/) for most popular platforms by the [YoWASP](https://yowasp.org/) project.

<!-- TODO: Link to FPGA family docs here -->

<a id="install-deps"></a>

## Installing prerequisites

Windows

[Install Python](https://docs.python.org/3/using/windows.html#using-on-windows), either from Windows Store or using the full installer. If using the full installer, make sure to install a 64-bit version of Python.

Before continuing, make sure you have the latest version of [pip](https://pip.pypa.io/en/stable/) installed by running:

```doscon
> pip install --upgrade pip
```

macOS

Install [Homebrew](https://brew.sh). Then, install Python by running:

```console
$ brew install python
```

Before continuing, make sure you have the latest version of [pip](https://pip.pypa.io/en/stable/) installed by running:

```console
$ pip install --upgrade pip
```

Debian

Install Python by running:

```console
$ sudo apt-get install python3-pip
```

On architectures other than x86_64 and AArch64, install Yosys by running:

```console
$ sudo apt-get install yosys
```

If Yosys 0.40 (or newer) is not available, [build Yosys from source](https://github.com/YosysHQ/yosys/#building-from-source).

Before continuing, make sure you have the latest version of [pip](https://pip.pypa.io/en/stable/) installed by running:

```console
$ pip3 install --user --upgrade pip
```

Arch Linux

Install Python and pip by running:

```console
$ sudo pacman -S python python-pip
```

Other Linux

Install Python from the package repository of your distribution.

On architectures other than x86_64 and AArch64, install Yosys from the package repository of your distribution.

If Yosys 0.40 (or newer) is not available, [build Yosys from source](https://github.com/YosysHQ/yosys/#building-from-source).

Before continuing, make sure you have the latest version of [pip](https://pip.pypa.io/en/stable/) installed by running:

```console
$ pip3 install --user --upgrade pip
```

<a id="install"></a>

## Installing Amaranth

The latest release of Amaranth should work well for most applications. A development snapshot—any commit from the `main` branch of Amaranth—should be similarly reliable, but is likely to include experimental API changes that will be in flux until the next release. With that in mind, development snapshots can be used to try out new functionality or to avoid bugs fixed since the last release.

<a id="install-release"></a>

### Latest release

Windows

To install the latest release of Amaranth, run:

```doscon
> pip install --upgrade amaranth[builtin-yosys]
```

macOS

To install the latest release of Amaranth, run:

```console
$ pip install --user --upgrade 'amaranth[builtin-yosys]'
```

Linux

If you **did not** install Yosys manually in the [previous step](#install-deps), to install the latest release of Amaranth, run:

```console
$ pip3 install --user --upgrade 'amaranth[builtin-yosys]'
```

If you **did** install Yosys manually in the previous step, run:

```console
$ pip3 install --user --upgrade amaranth
```

Arch Linux

To install the latest release of Amaranth, run:

```console
$ sudo pacman -S python-amaranth
```

<a id="install-snapshot"></a>

### Development snapshot

Windows

To install the latest development snapshot of Amaranth, run:

```doscon
> pip install "amaranth[builtin-yosys] @ git+https://github.com/amaranth-lang/amaranth.git"
```

macOS

To install the latest development snapshot of Amaranth, run:

```console
$ pip install --user 'amaranth[builtin-yosys] @ git+https://github.com/amaranth-lang/amaranth.git'
```

Linux

If you **did not** install Yosys manually in the [previous step](#install-deps), to install the latest release of Amaranth, run:

```console
$ pip3 install --user 'amaranth[builtin-yosys] @ git+https://github.com/amaranth-lang/amaranth.git'
```

If you **did** install Yosys manually in the previous step, run:

```console
$ pip3 install --user 'amaranth @ git+https://github.com/amaranth-lang/amaranth.git'
```

<a id="install-develop"></a>

### Editable development snapshot

Windows

To install an editable development snapshot of Amaranth for the first time, run:

```doscon
> git clone https://github.com/amaranth-lang/amaranth
> cd amaranth
> pip install --editable .[builtin-yosys]
```

Any changes made to the `amaranth` directory will immediately affect any code that uses Amaranth. To update the snapshot, run:

```doscon
> cd amaranth
> git pull --ff-only origin main
> pip install --editable .[builtin-yosys]
```

Run the `pip install --editable .[builtin-yosys]` command any time package dependencies may have been added or changed (notably after updating the snapshot with `git`). Otherwise, code using Amaranth may crash because of a dependency version mismatch.

macOS

To install an editable development snapshot of Amaranth for the first time, run:

```console
$ git clone https://github.com/amaranth-lang/amaranth
$ cd amaranth
$ pip install --user --editable '.[builtin-yosys]'
```

Any changes made to the `amaranth` directory will immediately affect any code that uses Amaranth. To update the snapshot, run:

```console
$ cd amaranth
$ git pull --ff-only origin main
$ pip install --user --editable '.[builtin-yosys]'
```

Run the `pip install --editable .[builtin-yosys]` command any time package dependencies may have been added or changed (notably after updating the snapshot with `git`). Otherwise, code using Amaranth may crash because of a dependency version mismatch.

Linux

If you **did** install Yosys manually in the [previous step](#install-deps), omit `[builtin-yosys]` from the following commands.

To install an editable development snapshot of Amaranth for the first time, run:

```console
$ git clone https://github.com/amaranth-lang/amaranth
$ cd amaranth
$ pip3 install --user --editable '.[builtin-yosys]'
```

Any changes made to the `amaranth` directory will immediately affect any code that uses Amaranth. To update the snapshot, run:

```console
$ cd amaranth
$ git pull --ff-only origin main
$ pip3 install --user --editable '.[builtin-yosys]'
```

Run the `pip3 install --editable .[builtin-yosys]` command any time package dependencies may have been added or changed (notably after updating the snapshot with `git`). Otherwise, code using Amaranth may crash because of a dependency version mismatch.

## Installing board definitions


# intro.html.md

<!-- TODO: this introduction is written for people well familiar with HDLs; we likely need
another one for people who will use Amaranth as their first HDL -->

# Introduction

The Amaranth project provides an open-source toolchain for developing hardware based on synchronous digital logic using the Python programming language. It aims to be easy to learn and use, reduce or eliminate common coding mistakes, and simplify the design of complex hardware with reusable components.

The Amaranth toolchain consists of the [Amaranth language](#intro-lang), the [standard library](#intro-stdlib), the [simulator](#intro-sim), and the [build system](#intro-build), covering all steps of a typical FPGA development workflow. At the same time, it does not restrict the designer’s choice of tools: existing industry-standard (System)Verilog or VHDL code can be integrated into an Amaranth-based design flow, or, conversely, Amaranth code can be integrated into an existing Verilog-based design flow.

<!-- TODO: add links to connect_rpc docs once they exist -->

<a id="intro-lang"></a>

## The Amaranth language

The Amaranth hardware description language <guide> is a Python library for register transfer level modeling of synchronous logic. Ordinary Python code is used to construct a netlist of a digital circuit, which can be simulated, directly synthesized via [Yosys](https://yosyshq.net/yosys/), or converted to human-readable Verilog code for use with industry-standard toolchains.

By relying on the flexibility, rich functionality and widespread adoption of the Python language, the Amaranth language is focused on a single task: modeling digital logic well. It has first-class support for building blocks like clock domains and finite state machines, and uses simple rules for arithmetic operations that closely match the Python semantics. Python classes, functions, loops and conditionals can be used to build organized and flexible designs; Python libraries can be seamlessly used with Amaranth during design or verification; and Python development tools can process Amaranth code.

A core design principle of the Amaranth language is to be not only easy to use, but also hard to accidentally misuse. Some HDLs provide functionality that has unexpected and undesirable behavior in synthesis, often with expensive consequences, and require a significant effort in learning a “safe” coding style and adopting third-party linting tools. Amaranth lacks non-synthesizable constructs and avoids error-prone inference in favor of explicit instantiation. It has many diagnostics (and regularly adds new ones) highlighting potential design issues. Most importantly, all usability issues are considered [reportable bugs](https://github.com/amaranth-lang/amaranth/issues).

<a id="intro-stdlib"></a>

## The Amaranth standard library

The Amaranth language comes with a standard library—a collection of essential digital design components and interfaces. It includes clock domain crossing primitives, synchronous and asynchronous FIFOs, a flexible I/O buffer interface, and more. By providing reliable building blocks out of the box, Amaranth allows the designer to focus on their application and avoids subtle differences in behavior between different designs.

<!-- TODO: link to stdlib here -->

Clock domain crossing often requires special treatment, such as using vendor-defined attributes or instantiating device-specific primitives. The CDC primitives in the Amaranth standard library can be overridden by the platform integration, and every platform integration included with Amaranth follows the vendor recommendations for CDC.

High-speed designs usually require the use of registered (and sometimes, geared) I/O buffers. The Amaranth standard library provides a common interface to be used between I/O buffers and peripheral implementations. The Amaranth build system, if used, can instantiate I/O buffers for every platform integration included with Amaranth.

While many designs will use at least some vendor-specific functionality, the components provided by the Amaranth standard library reduce the amount of code that needs to be changed when migrating between FPGA families, and the common interfaces simplify peripherals, test benches and simulations.

The Amaranth standard library is optional: the Amaranth language can be used without it. Conversely, it is possible to use the Amaranth standard library components in Verilog or VHDL code, with some limitations.

<!-- TODO: link to connect_rpc docs here *again* -->

<a id="intro-sim"></a>

## The Amaranth simulator

The Amaranth project includes an advanced simulator for Amaranth code implemented in Python with no system dependencies; in this simulator, test benches are written as Python generator functions. Of course, it is always possible to convert an Amaranth design to Verilog for use with well-known tool like [Icarus Verilog](https://steveicarus.github.io/iverilog/) or [Verilator](https://www.veripool.org/verilator/).

The Amaranth simulator is event-driven and can simulate designs with multiple clocks or asynchronous resets. Although it is slower than [Icarus Verilog](https://steveicarus.github.io/iverilog/), it compiles the netlist to Python code ahead of time, achieving remarkably high performance for a pure Python implementation—especially when running on [PyPy](https://www.pypy.org/).

Although Amaranth does not support native code simulation or co-simulation at the moment, such support will be added in near future.

<a id="intro-build"></a>

## The Amaranth build system

To achieve an end-to-end FPGA development workflow, the Amaranth project integrates with all major FPGA toolchains and provides definitions for many common development boards.

<!-- TODO: link to vendor docs and board docs here -->

### FPGA toolchain integration

Each FPGA family requires the use of synthesis and place & route tools specific for that device family. The Amaranth build system directly integrates with every major open-source and commercial FPGA toolchain, and can be easily extended to cover others.

Through this integration, Amaranth can specialize the CDC primitives and I/O buffers for a particular device and toolchain; generate I/O and clock constraints from board definition files; synchronize the power-on reset in single-clock designs; include (System)Verilog and VHDL files in the design (if supported by the toolchain); and finally, generate a script running synthesis, placement, routing, and timing analysis. The generated code can be customized to insert additional options, commands, constraints, and so on.

The Amaranth build system produces self-contained, portable build trees that require only the toolchain to be present in the environment. This makes builds easier to reproduce, or to run on a remote machine. The generated build scripts are always provided for both \*nix and Windows.

### Development board definitions

Getting started with a new FPGA development board often requires going through a laborous and error-prone process of deriving toolchain configuration and constraint files from the supplied documentation. The Amaranth project includes a community-maintained repository of definitions for many open-source and commercial FPGA development boards.

These board definitions contain everything that is necessary to start using the board: FPGA family and model, clocks and resets, descriptions of on-board peripherals (including pin direction and attributes such as I/O standard), connector pinouts, and for boards with a built-in debug probe, the steps required to program the board. It takes a single Python invocation to generate, build, and download a test design that shows whether the board, toolchain, and programmer are working correctly.

Amaranth establishes a pin naming convention for many common peripherals (such as 7-segment displays, SPI flashes and SDRAM memories), enabling the reuse of unmodified interface code with many different boards. Further, the polarity of all control signals is unified to be active high, eliminating accidental polarity inversions and making simulation traces easier to follow; active low signals are inverted during I/O buffer instantiation.


# io.html.md

# I/O Peripherals

Communication and general-purpose I/O peripherals.


# io.html.md

# Input/output buffers

The [`amaranth.lib.io`](#module-amaranth.lib.io) module provides a platform-independent way to instantiate platform-specific input/output buffers: combinational, synchronous, and double data rate (DDR).

## Introduction

The Amaranth language provides [core I/O values](../guide.md#lang-iovalues) that designate connections to external devices, and [I/O buffer instances](../guide.md#lang-iobufferinstance) that implement platform-independent combinational I/O buffers. This low-level mechanism is foundational to all I/O in Amaranth and must be used whenever a device-specific platform is unavailable, but is limited in its capabilities. The [`amaranth.lib.io`](#module-amaranth.lib.io) module builds on top of it to provide *library I/O ports* that specialize and annotate I/O values, and *buffer components* that connect ports to logic.

#### NOTE
Unfortunately, the terminology related to I/O has several ambiguities:

* A “port” could refer to an *interface port* (`Signal` objects created by the [`amaranth.lib.wiring`](wiring.md#module-amaranth.lib.wiring) module), a *core I/O port* (`amaranth.hdl.IOPort` object), or a *library I/O port* ([`amaranth.lib.io.PortLike`](#amaranth.lib.io.PortLike) object).
* A “I/O buffer” could refer to an *I/O buffer instance* (`amaranth.hdl.IOBufferInstance`) or a *I/O buffer component* ([`amaranth.lib.io.Buffer`](#amaranth.lib.io.Buffer), [`FFBuffer`](#amaranth.lib.io.FFBuffer), or [`DDRBuffer`](#amaranth.lib.io.DDRBuffer) objects).

Amaranth documentation always uses the least ambiguous form of these terms.

## Examples

<!-- from amaranth import *

class MockPlatform:
    def request(self, name, *, dir):
        from amaranth.hdl import IOPort
        from amaranth.lib import io
        if name == "led":
            return io.SingleEndedPort(IOPort(1, name=name), direction="o")
        if name == "clk24":
            return io.SingleEndedPort(IOPort(1, name=name), direction="i")
        if name == "d":
            return io.SingleEndedPort(IOPort(8, name=name), direction="io")
        if name == "re":
            return io.SingleEndedPort(IOPort(1, name=name), direction="i")
        if name == "we":
            return io.SingleEndedPort(IOPort(1, name=name), direction="i")
        if name == "dclk":
            return io.SingleEndedPort(IOPort(1, name=name), direction="o")
        if name == "dout":
            return io.SingleEndedPort(IOPort(8, name=name), direction="o")
        raise NameError

    def get_io_buffer(self, buffer):
        return Fragment()

    def build(self, top):
        from amaranth.back import rtlil
        return rtlil.convert(Fragment.get(top, self), ports=[]) -->

All of the following examples assume that one of the built-in FPGA platforms is used.

```python
from amaranth.sim import Simulator
from amaranth.lib import io, wiring, stream
from amaranth.lib.wiring import In, Out
```

### LED output

In this example, a library I/O port for a LED is requested from the platform and driven to blink the LED:

```python
class Toplevel(Elaboratable):
    def elaborate(self, platform):
        m = Module()

        delay = Signal(24)
        state = Signal()
        with m.If(delay == 0):
            m.d.sync += delay.eq(~0)
            m.d.sync += state.eq(~state)
        with m.Else():
            m.d.sync += delay.eq(delay - 1)

        m.submodules.led = led = io.Buffer("o", platform.request("led", dir="-"))
        m.d.comb += led.o.eq(state)

        return m
```

<!-- MockPlatform().build(Toplevel()) -->

### Clock input

In this example, a clock domain is created and driven from an external clock source:

```python
class Toplevel(Elaboratable):
    def elaborate(self, platform):
        m = Module()

        m.domains.sync = cd_sync = ClockDomain(local=True)

        m.submodules.clk24 = clk24 = io.Buffer("i", platform.request("clk24", dir="-"))
        m.d.comb += cd_sync.clk.eq(clk24.i)

        ...

        return m
```

<!-- MockPlatform().build(Toplevel()) -->

### Bidirectional bus

This example implements a peripheral for a clocked parallel bus. This peripheral can store and recall one byte of data. The data is stored with a write enable pulse, and recalled with a read enable pulse:

```python
class Toplevel(Elaboratable):
    def elaborate(self, platform):
        m = Module()

        m.submodules.bus_d = bus_d = io.FFBuffer("io", platform.request("d", dir="-"))
        m.submodules.bus_re = bus_re = io.Buffer("i", platform.request("re", dir="-"))
        m.submodules.bus_we = bus_we = io.Buffer("i", platform.request("we", dir="-"))

        data = Signal.like(bus_d.i)
        with m.If(bus_re.i):
            m.d.comb += bus_d.oe.eq(1)
            m.d.comb += bus_d.o.eq(data)
        with m.Elif(bus_we.i):
            m.d.sync += data.eq(bus_d.i)

        return m
```

<!-- MockPlatform().build(Toplevel()) -->

This bus requires a turn-around time of at least 1 cycle to avoid electrical contention.

Note that data appears on the bus one cycle after the read enable input is asserted, and that the write enable input stores the data present on the bus in the *previous* cycle. This is called *pipelining* and is typical for clocked buses; see [`FFBuffer`](#amaranth.lib.io.FFBuffer) for a waveform diagram. Although it increases the maximum clock frequency at which the bus can run, it also makes the bus signaling more complicated.

### Clock forwarding

In this example of a [source-synchronous interface](https://en.wikipedia.org/wiki/Source-synchronous), a clock signal is generated with the same phase as the DDR data signals associated with it:

```python
class SourceSynchronousOutput(wiring.Component):
    dout: In(16)

    def elaborate(self, platform):
        m = Module()

        m.submodules.bus_dclk = bus_dclk = \
            io.DDRBuffer("o", platform.request("dclk", dir="-"))
        m.d.comb += [
            bus_dclk.o[0].eq(1),
            bus_dclk.o[1].eq(0),
        ]

        m.submodules.bus_dout = bus_dout = \
            io.DDRBuffer("o", platform.request("dout", dir="-"))
        m.d.comb += [
            bus_dout.o[0].eq(self.dout[:8]),
            bus_dout.o[1].eq(self.dout[8:]),
        ]

        return m
```

<!-- MockPlatform().build(SourceSynchronousOutput()) -->

This component transmits `dout` on each cycle as two halves: the low 8 bits on the rising edge of the data clock, and the high 8 bits on the falling edge of the data clock. The transmission is *edge-aligned*, meaning that the data edges exactly coincide with the clock edges.

## Simulation

The Amaranth simulator, [`amaranth.sim`](../simulator.md#module-amaranth.sim), cannot simulate [core I/O values](../guide.md#lang-iovalues) or [I/O buffer instances](../guide.md#lang-iobufferinstance) as it only operates on unidirectionally driven two-state wires. This module provides a simulation-only library I/O port, [`SimulationPort`](#amaranth.lib.io.SimulationPort), so that components that use library I/O buffers can be tested.

A component that is designed for testing should accept the library I/O ports it will drive as constructor parameters rather than requesting them from the platform directly. Synthesizable designs will instantiate the component with a [`SingleEndedPort`](#amaranth.lib.io.SingleEndedPort), [`DifferentialPort`](#amaranth.lib.io.DifferentialPort), or a platform-specific library I/O port, while tests will instantiate the component with a [`SimulationPort`](#amaranth.lib.io.SimulationPort). Tests are able to inject inputs into the component using `sim_port.i`, capture the outputs of the component via `sim_port.o`, and ensure that the component is driving the outputs at the appropriate times using `sim_port.oe`.

For example, consider a simple serializer that accepts a stream of multi-bit data words and outputs them bit by bit. It can be tested as follows:

```python
class OutputSerializer(wiring.Component):
    data: In(stream.Signature(8))

    def __init__(self, dclk_port, dout_port):
        self.dclk_port = dclk_port
        self.dout_port = dout_port

        super().__init__()

    def elaborate(self, platform):
        m = Module()

        m.submodules.dclk = dclk = io.Buffer("o", self.dclk_port)
        m.submodules.dout = dout = io.Buffer("o", self.dout_port)

        index = Signal(range(8))
        m.d.comb += dout.o.eq(self.data.payload.bit_select(index, 1))

        with m.If(self.data.valid):
            m.d.sync += dclk.o.eq(~dclk.o)
            with m.If(dclk.o):
                m.d.sync += index.eq(index + 1)
                with m.If(index == 7):
                    m.d.comb += self.data.ready.eq(1)

        return m

def test_output_serializer():
    dclk_port = io.SimulationPort("o", 1)
    dout_port = io.SimulationPort("o", 1)

    dut = OutputSerializer(dclk_port, dout_port)

    async def testbench_write_data(ctx):
        ctx.set(dut.data.payload, 0xA1)
        ctx.set(dut.data.valid, 1)
        await ctx.tick().until(dut.data.ready)
        ctx.set(dut.data.valid, 0)

    async def testbench_sample_output(ctx):
        for bit in [1,0,0,0,0,1,0,1]:
            _, dout_value = await ctx.posedge(dut.dclk_port.o).sample(dut.dout_port.o)
            assert ctx.get(dut.dout_port.oe) == 1, "DUT is not driving the data output"
            assert dout_value == bit, "DUT drives the wrong value on data output"

    sim = Simulator(dut)
    sim.add_clock(1e-6)
    sim.add_testbench(testbench_write_data)
    sim.add_testbench(testbench_sample_output)
    sim.run()
```

<!-- test_output_serializer() -->

## Ports

### *class* amaranth.lib.io.Direction

Represents direction of a library I/O port, or of an I/O buffer component.

#### Input *= 'i'*

Input direction (from outside world to Amaranth design).

#### Output *= 'o'*

Output direction (from Amaranth design to outside world).

#### Bidir *= 'io'*

Bidirectional (can be switched between input and output).

#### \_\_and_\_(other)

Narrow the set of possible directions.

* `self & self` returns `self`.
* `Bidir & other` returns `other`.
* `Input & Output` raises [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError).

### *class* amaranth.lib.io.PortLike

Represents an abstract library I/O port that can be passed to a buffer.

The port types supported by most platforms are [`SingleEndedPort`](#amaranth.lib.io.SingleEndedPort) and
[`DifferentialPort`](#amaranth.lib.io.DifferentialPort). Platforms may define additional port types where appropriate.

#### NOTE
`amaranth.hdl.IOPort` is not an instance of [`amaranth.lib.io.PortLike`](#amaranth.lib.io.PortLike).

#### *abstract property* direction

Direction of the port.

* **Return type:**
  [`Direction`](#amaranth.lib.io.Direction)

#### *abstract* \_\_len_\_()

Computes the width of the port.

* **Returns:**
  The number of wires (for single-ended library I/O ports) or wire pairs (for differential
  library I/O ports) this port consists of.
* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

#### *abstract* \_\_getitem_\_(key)

Slices the port.

* **Returns:**
  A new [`PortLike`](#amaranth.lib.io.PortLike) instance of the same type as `self`, containing a selection
  of wires of this port according to `key`. Its width is the same as the length of
  the slice (if `key` is a [`slice`](https://docs.python.org/3/library/functions.html#slice)); or 1 (if `key` is an [`int`](https://docs.python.org/3/library/functions.html#int)).
* **Return type:**
  [`PortLike`](#amaranth.lib.io.PortLike)

#### *abstract* \_\_invert_\_()

Inverts polarity of the port.

Inverting polarity of a library I/O port has the same effect as adding inverters to
the `i` and `o` members of an I/O buffer component for that port.

* **Returns:**
  A new [`PortLike`](#amaranth.lib.io.PortLike) instance of the same type as `self`, containing the same
  wires as this port, but with polarity inverted.
* **Return type:**
  [`PortLike`](#amaranth.lib.io.PortLike)

#### \_\_add_\_(other)

Concatenates two library I/O ports of the same type.

The direction of the resulting port is:

* The same as the direction of both, if the two ports have the same direction.
* [`Direction.Input`](#amaranth.lib.io.Direction.Input) if a bidirectional port is concatenated with an input port.
* [`Direction.Output`](#amaranth.lib.io.Direction.Output) if a bidirectional port is concatenated with an output port.

* **Returns:**
  A new `type(self)` which contains wires from `self` followed by wires
  from `other`, preserving their polarity inversion.
* **Return type:**
  `type(self)`
* **Raises:**
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If an input port is concatenated with an output port.
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `self` and `other` have different types.

### *class* amaranth.lib.io.SingleEndedPort(io, \*, invert=False, direction=Direction.Bidir)

Represents a single-ended library I/O port.

Implements the [`PortLike`](#amaranth.lib.io.PortLike) interface.

* **Parameters:**
  * **io** (`IOValue`) – Underlying core I/O value.
  * **invert** ([`bool`](https://docs.python.org/3/library/functions.html#bool) or iterable of [`bool`](https://docs.python.org/3/library/functions.html#bool)) – Polarity inversion. If the value is a simple [`bool`](https://docs.python.org/3/library/functions.html#bool), it specifies inversion for
    the entire port. If the value is an iterable of [`bool`](https://docs.python.org/3/library/functions.html#bool), the iterable must have the
    same length as the width of `io`, and the inversion is specified for individual wires.
  * **direction** ([`Direction`](#amaranth.lib.io.Direction) or [`str`](https://docs.python.org/3/library/stdtypes.html#str)) – Set of allowed buffer directions. A string is converted to a [`Direction`](#amaranth.lib.io.Direction) first.
    If equal to [`Input`](#amaranth.lib.io.Direction.Input) or [`Output`](#amaranth.lib.io.Direction.Output), this port can only be
    used with buffers of matching direction. If equal to [`Bidir`](#amaranth.lib.io.Direction.Bidir), this port
    can be used with buffers of any direction.
* **Attributes:**
  * **io** (`IOValue`) – The `io` parameter.
  * **invert** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of [`bool`](https://docs.python.org/3/library/functions.html#bool)) – The `invert` parameter, normalized to specify polarity inversion per-wire.
  * **direction** ([`Direction`](#amaranth.lib.io.Direction)) – The `direction` parameter, normalized to the [`Direction`](#amaranth.lib.io.Direction) enumeration.

### *class* amaranth.lib.io.DifferentialPort(p, n, \*, invert=False, direction=Direction.Bidir)

Represents a differential library I/O port.

Implements the [`PortLike`](#amaranth.lib.io.PortLike) interface.

* **Parameters:**
  * **p** (`IOValue`) – Underlying core I/O value for the true (positive) half of the port.
  * **n** (`IOValue`) – Underlying core I/O value for the complement (negative) half of the port.
    Must have the same width as `p`.
  * **invert** ([`bool`](https://docs.python.org/3/library/functions.html#bool) or iterable of [`bool`](https://docs.python.org/3/library/functions.html#bool)) – Polarity inversion. If the value is a simple [`bool`](https://docs.python.org/3/library/functions.html#bool), it specifies inversion for
    the entire port. If the value is an iterable of [`bool`](https://docs.python.org/3/library/functions.html#bool), the iterable must have the
    same length as the width of `p` and `n`, and the inversion is specified for
    individual wires.
  * **direction** ([`Direction`](#amaranth.lib.io.Direction) or [`str`](https://docs.python.org/3/library/stdtypes.html#str)) – Set of allowed buffer directions. A string is converted to a [`Direction`](#amaranth.lib.io.Direction) first.
    If equal to [`Input`](#amaranth.lib.io.Direction.Input) or [`Output`](#amaranth.lib.io.Direction.Output), this port can only be
    used with buffers of matching direction. If equal to [`Bidir`](#amaranth.lib.io.Direction.Bidir), this port
    can be used with buffers of any direction.
* **Attributes:**
  * **p** (`IOValue`) – The `p` parameter.
  * **n** (`IOValue`) – The `n` parameter.
  * **invert** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of [`bool`](https://docs.python.org/3/library/functions.html#bool)) – The `invert` parameter, normalized to specify polarity inversion per-wire.
  * **direction** ([`Direction`](#amaranth.lib.io.Direction)) – The `direction` parameter, normalized to the [`Direction`](#amaranth.lib.io.Direction) enumeration.

### *class* amaranth.lib.io.SimulationPort(direction, width, \*, invert=False, name=None, src_loc_at=0)

Represents a simulation library I/O port.

Implements the [`PortLike`](#amaranth.lib.io.PortLike) interface.

* **Parameters:**
  * **direction** ([`Direction`](#amaranth.lib.io.Direction) or [`str`](https://docs.python.org/3/library/stdtypes.html#str)) – Set of allowed buffer directions. A string is converted to a [`Direction`](#amaranth.lib.io.Direction) first.
    If equal to [`Input`](#amaranth.lib.io.Direction.Input) or [`Output`](#amaranth.lib.io.Direction.Output), this port can only be
    used with buffers of matching direction. If equal to [`Bidir`](#amaranth.lib.io.Direction.Bidir), this port
    can be used with buffers of any direction.
  * **width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Width of the port. The width of each of the attributes `i`, `o`, `oe` (whenever
    present) equals `width`.
  * **invert** ([`bool`](https://docs.python.org/3/library/functions.html#bool) or iterable of [`bool`](https://docs.python.org/3/library/functions.html#bool)) – Polarity inversion. If the value is a simple [`bool`](https://docs.python.org/3/library/functions.html#bool), it specifies inversion for
    the entire port. If the value is an iterable of [`bool`](https://docs.python.org/3/library/functions.html#bool), the iterable must have the
    same length as the width of `p` and `n`, and the inversion is specified for
    individual wires.
  * **name** ([`str`](https://docs.python.org/3/library/stdtypes.html#str) or `None`) – Name of the port. This name is only used to derive the names of the input, output, and
    output enable signals.
  * **src_loc_at** ([`int`](https://docs.python.org/3/library/functions.html#int)) – [Source location](../reference.md#lang-srcloc). Used to infer `name` if not specified.
* **Attributes:**
  * **i** (`Signal`) – Input signal. Present if `direction in (Input, Bidir)`.
  * **o** (`Signal`) – Ouptut signal. Present if `direction in (Output, Bidir)`.
  * **oe** (`Signal`) – Output enable signal. Present if `direction in (Output, Bidir)`.
  * **invert** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of [`bool`](https://docs.python.org/3/library/functions.html#bool)) – The `invert` parameter, normalized to specify polarity inversion per-wire.
  * **direction** ([`Direction`](#amaranth.lib.io.Direction)) – The `direction` parameter, normalized to the [`Direction`](#amaranth.lib.io.Direction) enumeration.

## Buffers

### *class* amaranth.lib.io.Buffer(direction, port)

A combinational I/O buffer component.

This buffer can be used on any platform; if the platform does not specialize its implementation,
an [I/O buffer instance](../guide.md#lang-iobufferinstance) is used.

The following diagram defines the timing relationship between the underlying core I/O value
(for differential ports, the core I/O value of the true half) and the `i`, `o`, and
`oe` members:

* **Parameters:**
  * **direction** ([`Direction`](#amaranth.lib.io.Direction)) – Direction of the buffer.
  * **port** ([`PortLike`](#amaranth.lib.io.PortLike)) – Port driven by the buffer.
* **Raises:**
  [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – Unless `port.direction in (direction, Bidir)`.
* **Attributes:**
  **signature** ([`Buffer.Signature`](#amaranth.lib.io.Buffer.Signature)) – `Signature(direction, len(port)).flip()`.

#### *class* Signature(direction, width)

Signature of a combinational I/O buffer.

* **Parameters:**
  * **direction** ([`Direction`](#amaranth.lib.io.Direction)) – Direction of the buffer.
  * **width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Width of the buffer.
* **Members:**
  * **i** (`In(width)`) – Present if `direction in (Input, Bidir)`.
  * **o** (`Out(width)`) – Present if `direction in (Output, Bidir)`.
  * **oe** (`Out(1, init=0)`) – Present if `direction is Bidir`.
  * **oe** (`Out(1, init=1)`) – Present if `direction is Output`.

### *class* amaranth.lib.io.FFBuffer(direction, port, \*, i_domain=None, o_domain=None)

A registered I/O buffer component.

This buffer can be used on any platform; if the platform does not specialize its implementation,
an [I/O buffer instance](../guide.md#lang-iobufferinstance) is used, combined with reset-less
registers on `i`, `o`, and  `oe` members.

The following diagram defines the timing relationship between the underlying core I/O value
(for differential ports, the core I/O value of the true half) and the `i`, `o`, and
`oe` members:

#### WARNING
On some platforms, this buffer can only be used with rising edge clock domains, and will
raise an exception during conversion of the design to a netlist otherwise.

This limitation will be lifted in the future.

* **Parameters:**
  * **direction** ([`Direction`](#amaranth.lib.io.Direction)) – Direction of the buffer.
  * **port** ([`PortLike`](#amaranth.lib.io.PortLike)) – Port driven by the buffer.
  * **i_domain** ([`str`](https://docs.python.org/3/library/stdtypes.html#str)) – Name of the input register’s clock domain. Used when `direction in (Input, Bidir)`.
    Defaults to `"sync"`.
  * **o_domain** ([`str`](https://docs.python.org/3/library/stdtypes.html#str)) – Name of the output and output enable registers’ clock domain. Used when
    `direction in (Output, Bidir)`. Defaults to `"sync"`.
* **Attributes:**
  **signature** ([`FFBuffer.Signature`](#amaranth.lib.io.FFBuffer.Signature)) – `Signature(direction, len(port)).flip()`.

#### *class* Signature(direction, width)

Signature of a registered I/O buffer.

* **Parameters:**
  * **direction** ([`Direction`](#amaranth.lib.io.Direction)) – Direction of the buffer.
  * **width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Width of the buffer.
* **Members:**
  * **i** (`In(width)`) – Present if `direction in (Input, Bidir)`.
  * **o** (`Out(width)`) – Present if `direction in (Output, Bidir)`.
  * **oe** (`Out(1, init=0)`) – Present if `direction is Bidir`.
  * **oe** (`Out(1, init=1)`) – Present if `direction is Output`.

### *class* amaranth.lib.io.DDRBuffer(direction, port, \*, i_domain=None, o_domain=None)

A double data rate I/O buffer component.

This buffer is only available on platforms that support double data rate I/O.

The following diagram defines the timing relationship between the underlying core I/O value
(for differential ports, the core I/O value of the true half) and the `i`, `o`, and
`oe` members:

<!-- This diagram should have `port` phase shifted, but it hits wavedrom/wavedrom#416.
It is also affected by wavedrom/wavedrom#417. -->

The output data (labelled *a*, *b*) is input from `o` into internal registers at
the beginning of clock cycle 2, and transmitted at points labelled *1*, *2* during the same
clock cycle. The output latency *t1* is defined as the amount of cycles between the time of
capture of `o` and the time of transmission of rising edge data plus one cycle, and is 1
for this diagram.

The received data is captured into internal registers during the clock cycle 4 at points
labelled *5*, *6*, and output to `i` during the next clock cycle (labelled *d*, *e*).
The input latency *t2* is defined as the amount of cycles between the time of reception of
rising edge data and the time of update of `i`, and is 1 for this diagram.

The output enable signal is input from `oe` once per cycle and affects the entire cycle it
applies to. Its latency is defined in the same way as the output latency, and is equal to *t1*.

#### WARNING
Some platforms include additional pipeline registers that may cause latencies *t1* and *t2*
to be higher than one cycle. At the moment there is no way to query these latencies.

This limitation will be lifted in the future.

#### WARNING
On all supported platforms, this buffer can only be used with rising edge clock domains,
and will raise an exception during conversion of the design to a netlist otherwise.

This limitation may be lifted in the future.

#### WARNING
Double data rate I/O buffers are not compatible with [`SimulationPort`](#amaranth.lib.io.SimulationPort).

This limitation may be lifted in the future.

* **Parameters:**
  * **direction** ([`Direction`](#amaranth.lib.io.Direction)) – Direction of the buffer.
  * **port** ([`PortLike`](#amaranth.lib.io.PortLike)) – Port driven by the buffer.
  * **i_domain** ([`str`](https://docs.python.org/3/library/stdtypes.html#str)) – Name of the input register’s clock domain. Used when `direction in (Input, Bidir)`.
    Defaults to `"sync"`.
  * **o_domain** ([`str`](https://docs.python.org/3/library/stdtypes.html#str)) – Name of the output and output enable registers’ clock domain. Used when
    `direction in (Output, Bidir)`. Defaults to `"sync"`.
* **Attributes:**
  **signature** ([`DDRBuffer.Signature`](#amaranth.lib.io.DDRBuffer.Signature)) – `Signature(direction, len(port)).flip()`.

#### *class* Signature(direction, width)

Signature of a double data rate I/O buffer.

* **Parameters:**
  * **direction** ([`Direction`](#amaranth.lib.io.Direction)) – Direction of the buffer.
  * **width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Width of the buffer.
* **Members:**
  * **i** (`In(ArrayLayout(width, 2))`) – Present if `direction in (Input, Bidir)`.
  * **o** (`Out(ArrayLayout(width, 2))`) – Present if `direction in (Output, Bidir)`.
  * **oe** (`Out(1, init=0)`) – Present if `direction is Bidir`.
  * **oe** (`Out(1, init=1)`) – Present if `direction is Output`.


# lattice.html.md

# Lattice

The [`LatticePlatform`](#amaranth.vendor.LatticePlatform) class provides a base platform to support Lattice toolchains (not including iCE40 devices, which are supported by [`SiliconBluePlatform`](siliconblue.md#amaranth.vendor.SiliconBluePlatform)). Currently supported devices include ECP5, MachXO2, MachXO3L, and Nexus.

The Trellis and Diamond toolchains are supported.

### *class* amaranth.vendor.LatticePlatform(\*, toolchain=None)

### Trellis toolchain (ECP5, MachXO2, MachXO3)

Required tools:
: * `yosys`
  * `nextpnr-ecp5` or `nextpnr-machxo2`
  * `ecppack`

The environment is populated by running the script specified in the environment variable
`AMARANTH_ENV_TRELLIS`, if present.

Available overrides:
: * `verbose`: enables logging of informational messages to standard error.
  * `read_verilog_opts`: adds options for `read_verilog` Yosys command.
  * `synth_opts`: adds options for `synth_<family>` Yosys command.
  * `script_after_read`: inserts commands after `read_rtlil` in Yosys script.
  * `script_after_synth`: inserts commands after `synth_<family>` in Yosys script.
  * `yosys_opts`: adds extra options for `yosys`.
  * `nextpnr_opts`: adds extra options for `nextpnr-<family>`.
  * `ecppack_opts`: adds extra options for `ecppack`.
  * `add_preferences`: inserts commands at the end of the LPF file.

Build products:
: * `{{name}}.rpt`: Yosys log.
  * `{{name}}.json`: synthesized RTL.
  * `{{name}}.tim`: nextpnr log.
  * `{{name}}.config`: ASCII bitstream.
  * `{{name}}.bit`: binary bitstream.
  * `{{name}}.svf`: JTAG programming vector.

### Oxide toolchain (Nexus)

Required tools:
: * `yosys`
  * `nextpnr-nexus`
  * `prjoxide`

The environment is populated by running the script specified in the environment variable
`AMARANTH_ENV_OXIDE`, if present.

Available overrides:
: * `verbose`: enables logging of informational messages to standard error.
  * `read_verilog_opts`: adds options for `read_verilog` Yosys command.
  * `synth_opts`: adds options for `synth_nexus` Yosys command.
  * `script_after_read`: inserts commands after `read_rtlil` in Yosys script.
  * `script_after_synth`: inserts commands after `synth_nexus` in Yosys script.
  * `yosys_opts`: adds extra options for `yosys`.
  * `nextpnr_opts`: adds extra options for `nextpnr-nexus`.
  * `prjoxide_opts`: adds extra options for `prjoxide`.
  * `add_preferences`: inserts commands at the end of the PDC file.

Build products:
: * `{{name}}.rpt`: Yosys log.
  * `{{name}}.json`: synthesized RTL.
  * `{{name}}.tim`: nextpnr log.
  * `{{name}}.config`: ASCII bitstream.
  * `{{name}}.bit`: binary bitstream.
  * `{{name}}.xcf`: JTAG programming vector.

### Diamond toolchain (ECP5, MachXO2, MachXO3)

Required tools:
: * `pnmainc`
  * `ddtcmd`

The environment is populated by running the script specified in the environment variable
`AMARANTH_ENV_DIAMOND`, if present. On Linux, diamond_env as provided by Diamond
itself is a good candidate. On Windows, the following script (named `diamond_env.bat`,
for instance) is known to work:

```default
@echo off
set PATH=C:\lscc\diamond\%DIAMOND_VERSION%\bin\nt64;%PATH%
```

Available overrides:
: * `script_project`: inserts commands before `prj_project save` in Tcl script.
  * `script_after_export`: inserts commands after `prj_run Export` in Tcl script.
  * `add_preferences`: inserts commands at the end of the LPF file.
  * `add_constraints`: inserts commands at the end of the XDC file.

Build products:
: * `{{name}}_impl/{{name}}_impl.htm`: consolidated log.
  * `{{name}}.jed`: JEDEC fuse file (MachXO2, MachXO3 only).
  * `{{name}}.bit`: binary bitstream.
  * `{{name}}.svf`: JTAG programming vector (ECP5 only).
  * `{{name}}_flash.svf`: JTAG programming vector for FLASH programming (MachXO2, MachXO3 only).
  * `{{name}}_sram.svf`: JTAG programming vector for SRAM programming (MachXO2, MachXO3 only).

### Radiant toolchain (Nexus)

Required tools:
: * `radiantc`

The environment is populated by running the script specified in the environment variable
`AMARANTH_ENV_RADIANT`, if present. On Linux, radiant_env as provided by Radiant
itself is a good candidate. On Windows, the following script (named `radiant_env.bat`,
for instance) is known to work:

```default
@echo off
set PATH=C:\lscc\radiant\%RADIANT_VERSION%\bin\nt64;%PATH%
```

Available overrides:
: * `script_project`: inserts commands before `prj_save` in Tcl script.
  * `script_after_export`: inserts commands after `prj_run Export` in Tcl script.
  * `add_constraints`: inserts commands at the end of the SDC file.
  * `add_preferences`: inserts commands at the end of the PDC file.

Build products:
: * `{{name}}_impl/{{name}}_impl.htm`: consolidated log.
  * `{{name}}.bit`: binary bitstream.
  * `{{name}}.xcf`: JTAG programming vector. (if using `programmer`)


# mcu-soc.html.md

# MCU SoC Example

The `mcu_soc` example demonstrates a more complete microcontroller-style System-on-Chip with multiple peripherals, targeting the IHP SG13G2 process.

## Overview

This example creates a full-featured MCU with:

- **CV32E40P RISC-V CPU** - A 32-bit RISC-V processor with debug support
- **JTAG Debug Module** - Full debug capabilities via JTAG interface
- **QSPI Flash** - External flash memory for code storage
- **SRAM** - 2KB of on-chip RAM
- **Multiple GPIO Banks** - 2 banks of 8-bit GPIO (16 total)
- **Multiple UARTs** - 2 UART interfaces
- **SPI Controllers** - 3 user SPI interfaces
- **I2C Controllers** - 2 I2C bus interfaces
- **PWM Controllers** - 10 motor PWM outputs

## Project Structure

```text
mcu_soc/
├── chipflow.toml        # Project configuration
├── design/
│   ├── design.py        # Main SoC design
│   ├── ips/             # Custom IP cores (PWM, etc.)
│   ├── openocd/         # OpenOCD debug configuration
│   ├── software/        # Firmware source code
│   ├── steps/           # Custom build steps
│   └── tests/           # Test reference data
└── README.md
```

## Configuration

The `chipflow.toml` targets the IHP SG13G2 process with a PGA144 package:

```toml
[chipflow]
project_name = "chipflow-examples"

[chipflow.top]
soc = "design.design:MySoC"

[chipflow.steps]
board = "design.steps.board:MyBoardStep"

[chipflow.silicon]
process = "ihp_sg13g2"
package = "pga144"

[chipflow.test]
event_reference = "design/tests/events_reference.json"
```

## Peripheral Configuration

The MCU SoC uses parameterized peripheral counts:

```python
self.user_spi_count = 3    # 3 SPI interfaces
self.i2c_count = 2         # 2 I2C interfaces
self.motor_count = 10      # 10 PWM channels
self.uart_count = 2        # 2 UART interfaces
self.gpio_banks = 2        # 2 GPIO banks
self.gpio_width = 8        # 8 bits per bank
```

## Interface Declaration

The design dynamically creates interfaces based on peripheral counts:

```python
interfaces = {
    "flash": Out(QSPIFlashSignature()),
    "cpu_jtag": Out(JTAGSignature())
}

for i in range(self.user_spi_count):
    interfaces[f"user_spi_{i}"] = Out(SPISignature())

for i in range(self.i2c_count):
    interfaces[f"i2c_{i}"] = Out(I2CSignature())

for i in range(self.uart_count):
    interfaces[f"uart_{i}"] = Out(UARTSignature())

for i in range(self.gpio_banks):
    interfaces[f"gpio_{i}"] = Out(GPIOSignature(pin_count=self.gpio_width))
```

## Memory Map

| Region        | Base Address   | Description                                 |
|---------------|----------------|---------------------------------------------|
| SPI Flash     | `0x00000000`   | Code storage                                |
| SRAM          | `0x10000000`   | 2KB on-chip RAM                             |
| Debug         | `0xa0000000`   | Debug module                                |
| SPI Flash CSR | `0xb0000000`   | Flash control registers                     |
| GPIO CSR      | `0xb1000000`   | GPIO registers (offset `0x100000` per bank) |
| UART CSR      | `0xb2000000`   | UART registers (offset `0x100000` per UART) |
| SoC ID CSR    | `0xb4000000`   | SoC identification                          |
| User SPI CSR  | `0xb5000000`   | SPI registers (offset `0x100000` per SPI)   |
| I2C CSR       | `0xb6000000`   | I2C registers (offset `0x100000` per I2C)   |
| Motor PWM CSR | `0xb7000000`   | PWM registers (offset `0x100` per channel)  |

## Debug Support

The MCU SoC includes full JTAG debug support via the CV32E40P debug module:

```python
debug = OBIDebugModule()
wb_arbiter.add(debug.initiator)
wb_decoder.add(debug.target, name="debug", addr=self.debug_base)
m.d.comb += cpu.debug_req.eq(debug.debug_req)

m.d.comb += [
    debug.jtag_tck.eq(self.cpu_jtag.tck.i),
    debug.jtag_tms.eq(self.cpu_jtag.tms.i),
    debug.jtag_tdi.eq(self.cpu_jtag.tdi.i),
    debug.jtag_trst.eq(self.cpu_jtag.trst.i),
    self.cpu_jtag.tdo.o.eq(debug.jtag_tdo),
]
```

OpenOCD configuration files are provided in `design/openocd/` for hardware debugging.

## Custom IP: PWM Controller

The example includes a custom PWM IP for motor control in `design/ips/pwm.py`. This demonstrates how to create custom peripherals with their own IO signatures.

## Running the Example

```bash
cd mcu_soc
pdm chipflow pin lock
pdm sim-check
pdm submit --wait
```

## Key Differences from Minimal

1. **Different CPU**: Uses CV32E40P instead of Minerva, with full debug support
2. **More Peripherals**: Multiple instances of each peripheral type
3. **JTAG Debug**: Full hardware debugging capability
4. **Custom IP**: Includes custom PWM peripheral
5. **Different Target**: IHP SG13G2 process instead of SKY130

## Customization Ideas

- Adjust peripheral counts to match your requirements
- Add additional custom IP cores
- Modify memory sizes for your application
- Change the target process/package for different fabrication options


# memory.html.md

# Memory Peripherals

Memory controllers and storage peripherals.


# memory.html.md

# Memory maps

The [`amaranth_soc.memory`](#module-amaranth_soc.memory) module provides primitives for organizing the address space of a bus interface.

<!-- from amaranth import *

from amaranth_soc import csr
from amaranth_soc.memory import * -->

<a id="memory-introduction"></a>

## Introduction

The purpose of [`MemoryMap`](#amaranth_soc.memory.MemoryMap) is to provide a hierarchical description of the address space of a System-on-Chip, from its bus interconnect to the registers of its peripherals. It is composed of [resources](#memory-resources) (representing registers, memories, etc) and [windows](#memory-windows) (representing bus bridges), and may be [queried](#memory-accessing-windows) afterwards in order to enumerate its contents, or determine the address of a resource.

<a id="memory-resources"></a>

## Resources

A *resource* is a [`Component`](../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Component) previously added to a [`MemoryMap`](#amaranth_soc.memory.MemoryMap). Each resource occupies an unique range of addresses within the memory map, and represents a device that is a target for bus transactions.

### Adding resources

Resources are added with [`MemoryMap.add_resource()`](#amaranth_soc.memory.MemoryMap.add_resource), which returns a `(start, end)` tuple describing their address range:

```python
memory_map = MemoryMap(addr_width=3, data_width=8)

reg_ctrl = csr.Register(csr.Field(csr.action.RW, 32), "rw")
reg_data = csr.Register(csr.Field(csr.action.RW, 32), "rw")
```

```pycon
>>> memory_map.add_resource(reg_ctrl, size=4, addr=0x0, name=("ctrl",))
(0, 4)
>>> memory_map.add_resource(reg_data, size=4, addr=0x4, name=("data",))
(4, 8)
```

<a id="memory-implicit-next-address"></a>

#### NOTE
The `addr` parameter of [`MemoryMap.add_resource()`](#amaranth_soc.memory.MemoryMap.add_resource) and [`MemoryMap.add_window()`](#amaranth_soc.memory.MemoryMap.add_window) is optional.

To simplify address assignment, each [`MemoryMap`](#amaranth_soc.memory.MemoryMap) has an *implicit next address*, starting at 0. If a resource or a window is added without an explicit address, the implicit next address is used. In any case, the implicit next address is set to the address immediately following the newly added resource or window.

### Accessing resources

Memory map resources can be iterated with [`MemoryMap.resources()`](#amaranth_soc.memory.MemoryMap.resources):

```pycon
>>> for resource, name, (start, end) in memory_map.resources():
...     print(f"name={name}, start={start:#x}, end={end:#x}, resource={resource}")
name=Name('ctrl'), start=0x0, end=0x4, resource=<...>
name=Name('data'), start=0x4, end=0x8, resource=<...>
```

A memory map can be queried with [`MemoryMap.find_resource()`](#amaranth_soc.memory.MemoryMap.find_resource) to get the name and address range of a given resource:

```pycon
>>> memory_map.find_resource(reg_ctrl)
ResourceInfo(path=(Name('ctrl'),), start=0x0, end=0x4, width=8)
```

The resource located at a given address can be retrieved with [`MemoryMap.decode_address()`](#amaranth_soc.memory.MemoryMap.decode_address):

```pycon
>>> memory_map.decode_address(0x4) is reg_data
True
```

<a id="memory-alignment"></a>

## Alignment

The value of `MemoryMap.alignment` constrains the layout of a memory map. If unspecified, it defaults to 0.

Each resource or window added to a memory map is placed at an address that is a multiple of `2 ** alignment`, and its size is rounded up to a multiple of `2 ** alignment`.

For example, the resources of this memory map are 64-bit aligned:

```python
memory_map = MemoryMap(addr_width=8, data_width=8, alignment=3)

reg_foo = csr.Register(csr.Field(csr.action.RW, 32), "rw")
reg_bar = csr.Register(csr.Field(csr.action.RW, 32), "rw")
reg_baz = csr.Register(csr.Field(csr.action.RW, 32), "rw")
```

```pycon
>>> memory_map.add_resource(reg_foo, size=4, name=("foo",))
(0, 8)
>>> memory_map.add_resource(reg_bar, size=4, name=("bar",), addr=0x9)
Traceback (most recent call last):
...
ValueError: Explicitly specified address 0x9 must be a multiple of 0x8 bytes
```

[`MemoryMap.add_resource()`](#amaranth_soc.memory.MemoryMap.add_resource) takes an optional `alignment` parameter. If a value greater than `MemoryMap.alignment` is given, it becomes the alignment of this resource:

```pycon
>>> memory_map.add_resource(reg_bar, size=4, name=("bar",), alignment=4)
(16, 32)
```

[`MemoryMap.align_to()`](#amaranth_soc.memory.MemoryMap.align_to) can be used to align the [implicit next address](#memory-implicit-next-address). Its alignment is modified if a value greater than `MemoryMap.alignment` is given.

```pycon
>>> memory_map.align_to(6)
64
>>> memory_map.add_resource(reg_baz, size=4, name=("baz",))
(64, 72)
```

#### NOTE
[`MemoryMap.align_to()`](#amaranth_soc.memory.MemoryMap.align_to) has no effect on the size of the next resource or window.

<a id="memory-windows"></a>

## Windows

A *window* is a [`MemoryMap`](#amaranth_soc.memory.MemoryMap) nested inside another memory map. Each window occupies an unique range of addresses within the memory map, and represents a bridge to a subordinate bus.

### Adding windows

Windows are added with [`MemoryMap.add_window()`](#amaranth_soc.memory.MemoryMap.add_window), which returns a `(start, end, ratio)` tuple describing their address range:

```python
reg_ctrl    = csr.Register(csr.Field(csr.action.RW, 32), "rw")
reg_rx_data = csr.Register(csr.Field(csr.action.RW, 32), "rw")
reg_tx_data = csr.Register(csr.Field(csr.action.RW, 32), "rw")

memory_map = MemoryMap(addr_width=14, data_width=32)
rx_window  = MemoryMap(addr_width=12, data_width=32)
tx_window  = MemoryMap(addr_width=12, data_width=32)
```

```pycon
>>> memory_map.add_resource(reg_ctrl, size=1, name=("ctrl",))
(0, 1)

>>> rx_window.add_resource(reg_rx_data, size=1, name=("data",))
(0, 1)
>>> memory_map.add_window(rx_window, name=("rx",))
(4096, 8192, 1)
```

The third value returned by [`MemoryMap.add_window()`](#amaranth_soc.memory.MemoryMap.add_window) represents the number of addresses that are accessed in the bus described by `rx_window` for one transaction in the bus described by `memory_map`. It is 1 in this case, as both busses have the same width.

```pycon
>>> tx_window.add_resource(reg_tx_data, size=1, name=("data",))
(0, 1)
>>> memory_map.add_window(tx_window, name=("tx",))
(8192, 12288, 1)
```

<a id="memory-accessing-windows"></a>

#### Accessing windows

Memory map windows can be iterated with [`MemoryMap.windows()`](#amaranth_soc.memory.MemoryMap.windows):

```pycon
>>> for window, name, (start, end, ratio) in memory_map.windows():
...     print(f"{name}, start={start:#x}, end={end:#x}, ratio={ratio}")
Name('rx'), start=0x1000, end=0x2000, ratio=1
Name('tx'), start=0x2000, end=0x3000, ratio=1
```

Windows can also be iterated with [`MemoryMap.window_patterns()`](#amaranth_soc.memory.MemoryMap.window_patterns), which encodes their address ranges as bit patterns compatible with the [match operator](../amaranth/guide.md#lang-matchop) and the [Case block](../amaranth/guide.md#lang-switch):

```pycon
>>> for window, name, (pattern, ratio) in memory_map.window_patterns():
...     print(f"{name}, pattern='{pattern}', ratio={ratio}")
Name('rx'), pattern='01------------', ratio=1
Name('tx'), pattern='10------------', ratio=1
```

Memory map resources can be recursively iterated with [`MemoryMap.all_resources()`](#amaranth_soc.memory.MemoryMap.all_resources), which yields instances of [`ResourceInfo`](#amaranth_soc.memory.ResourceInfo):

```pycon
>>> for res_info in memory_map.all_resources():
...     print(res_info)
ResourceInfo(path=(Name('ctrl'),), start=0x0, end=0x1, width=32)
ResourceInfo(path=(Name('rx'), Name('data')), start=0x1000, end=0x1001, width=32)
ResourceInfo(path=(Name('tx'), Name('data')), start=0x2000, end=0x2001, width=32)
```

### Address translation

When a memory map resource is accessed through a window, address translation may happen in three different modes.

#### Transparent mode

In *transparent mode*, each transaction on the primary bus results in one transaction on the subordinate bus without loss of data. This mode is selected when [`MemoryMap.add_window()`](#amaranth_soc.memory.MemoryMap.add_window) is given `sparse=None`, which will fail if the window and the memory map have a different data widths.

#### NOTE
In practice, transparent mode is identical to other modes; it can only be used with equal data widths, which results in the same behavior regardless of the translation mode. However, it causes [`MemoryMap.add_window()`](#amaranth_soc.memory.MemoryMap.add_window) to fail if the data widths are different.

#### Sparse mode

In *sparse mode*, each transaction on the wide primary bus results in one transaction on the narrow subordinate bus. High data bits on the primary bus are ignored, and any contiguous resource on the subordinate bus becomes discontiguous on the primary bus. This mode is selected when [`MemoryMap.add_window()`](#amaranth_soc.memory.MemoryMap.add_window) is given `sparse=True`.

#### Dense mode

In *dense mode*, each transaction on the wide primary bus results in several transactions on the narrow subordinate bus, and any contiguous resource on the subordinate bus stays contiguous on the primary bus. This mode is selected when [`MemoryMap.add_window()`](#amaranth_soc.memory.MemoryMap.add_window) is given `sparse=False`.

## Freezing

The state of a memory map can become immutable by calling [`MemoryMap.freeze()`](#amaranth_soc.memory.MemoryMap.freeze):

```python
memory_map = MemoryMap(addr_width=3, data_width=8)

reg_ctrl = csr.Register(csr.Field(csr.action.RW, 32), "rw")
```

```pycon
>>> memory_map.freeze()
>>> memory_map.add_resource(reg_ctrl, size=4, addr=0x0, name=("ctrl",))
Traceback (most recent call last):
...
ValueError: Memory map has been frozen. Cannot add resource <...>
```

It is recommended to freeze a memory map before passing it to external logic, as a preventive measure against TOCTTOU bugs.

### *class* amaranth_soc.memory.MemoryMap

#### freeze()

Freeze the [`MemoryMap`](#amaranth_soc.memory.MemoryMap).

Once the [`MemoryMap`](#amaranth_soc.memory.MemoryMap) is frozen, its visible state becomes immutable. Resources and
windows cannot be added anymore.

#### align_to(alignment)

Align the [implicit next address](#memory-implicit-next-address).

* **Parameters:**
  **alignment** ([`int`](https://docs.python.org/3/library/functions.html#int), power-of-2 exponent) – Address alignment. The start of the implicit next address will be a multiple of
  `2 ** max(alignment, self.alignment)`.
* **Returns:**
  Implicit next address.
* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

#### add_resource(resource, \*, name, size, addr=None, alignment=None)

Add a resource.

A resource is any device on the bus that is a destination for bus transactions, e.g.
a register or a memory block.

* **Parameters:**
  * **resource** ([`amaranth.lib.wiring.Component`](../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Component)) – The resource to be added.
  * **name** (`MemoryMap.Name`) – Name of the resource. It must not conflict with the name of other resources or windows
    present in this memory map.
  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Address of the resource. Optional. If `None`, the [implicit next address](#memory-implicit-next-address) will be used. Otherwise, the exact specified address
    (which must be a multiple of `2 ** max(alignment, self.alignment)`) will be used.
  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Size of the resource, in minimal addressable units. Rounded up to a multiple of
    `2 ** max(alignment, self.alignment)`.
  * **alignment** ([`int`](https://docs.python.org/3/library/functions.html#int), power-of-2 exponent) – Alignment of the resource. Optional. If `None`, the memory map alignment is used.
* **Returns:**
  A tuple `(start, end)` describing the address range assigned to the resource.
* **Return type:**
  [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of ([`int`](https://docs.python.org/3/library/functions.html#int), [`int`](https://docs.python.org/3/library/functions.html#int))
* **Raises:**
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the memory map is frozen.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the requested address and size, after alignment, would overlap with any resources or
        windows that have already been added, or would be out of bounds.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `resource` has already been added to this memory map.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the requested name would conflict with the name of other resources or windows that
        have already been added.

#### resources()

Iterate local resources and their address ranges.

Non-recursively iterate resources in ascending order of their address.

* **Yields:**
  [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of ([`amaranth.lib.wiring.Component`](../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Component), `MemoryMap.Name`,         [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of ([`int`](https://docs.python.org/3/library/functions.html#int), [`int`](https://docs.python.org/3/library/functions.html#int))) – A tuple `resource, name, (start, end)` describing the address range assigned to the
  resource.

#### add_window(window, \*, name=None, addr=None, sparse=None)

Add a window.

A window is a device on a bus that provides access to a different bus, i.e. a bus bridge.
It performs address translation, such that the devices on a subordinate bus have different
addresses; the memory map reflects this address translation when resources are looked up
through the window.

* **Parameters:**
  * **window** ([`MemoryMap`](#amaranth_soc.memory.MemoryMap)) – A [`MemoryMap`](#amaranth_soc.memory.MemoryMap) describing the layout of the window. It is frozen as a side-effect
    of being added to this memory map.
  * **name** (`MemoryMap.Name`) – Name of the window. Optional. It must not conflict with the name of other resources or
    windows present in this memory map.
  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Address of the window. Optional. If `None`, the [implicit next address](#memory-implicit-next-address) will be used after aligning it to
    `2 ** window.addr_width`. Otherwise, the exact specified address (which must be a
    multiple of `2 ** window.addr_width`) will be used.
  * **sparse** ([`bool`](https://docs.python.org/3/library/functions.html#bool)) – Address translation type. Optional. Ignored if the datapath widths of both memory maps
    are equal; must be specified otherwise.
* **Returns:**
  A tuple `(start, end, ratio)` describing the address range assigned to the window.
  When bridging buses of unequal data width, `ratio` is the amount of contiguous
  addresses on the narrower bus that are accessed for each transaction on the wider bus.
  Otherwise, it is always 1.
* **Return type:**
  [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of ([`int`](https://docs.python.org/3/library/functions.html#int), [`int`](https://docs.python.org/3/library/functions.html#int), [`int`](https://docs.python.org/3/library/functions.html#int))
* **Raises:**
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the memory map is frozen.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the requested address and size, after alignment, would overlap with any resources or
        windows that have already been added, or would be out of bounds.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `window.data_width` is wider than `data_width`.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the address translation mode is unspecified and `window.data_width` is different
        than `data_width`.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If dense address translation is used and `data_width` is not an integer multiple
        of `window.data_width`.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If dense address translation is used and the ratio of `data_width` to
        `window.data_width` is not a power of 2.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If dense address translation is used and the ratio of `data_width` to
        `window.data_width` is lesser than 2 raised to the power of `alignment`.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the requested name would conflict with the name of other resources or windows that
        have already been added.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `window` is anonymous and the name of one of its resources or windows would
        conflict with the name of any resources or windows that have already been added.

#### windows()

Iterate local windows and their address ranges.

Non-recursively iterate windows in ascending order of their address.

* **Yields:**
  [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of ([`MemoryMap`](#amaranth_soc.memory.MemoryMap), `MemoryMap.Name`, [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of         ([`int`](https://docs.python.org/3/library/functions.html#int), [`int`](https://docs.python.org/3/library/functions.html#int), [`int`](https://docs.python.org/3/library/functions.html#int))) – A tuple `window, name, (start, end, ratio)` describing the address range assigned to
  the window. When bridging busses of unequal data widths, `ratio` is the amount of
  contiguous addresses on the narrower bus that are accessed for each transaction on the
  wider bus. Otherwise, it is always 1.

#### window_patterns()

Iterate local windows and patterns that match their address ranges.

Non-recursively iterate windows in ascending order of their address.

* **Yields:**
  [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of ([`MemoryMap`](#amaranth_soc.memory.MemoryMap), `MemoryMap.Name`, [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of         ([`str`](https://docs.python.org/3/library/stdtypes.html#str), [`int`](https://docs.python.org/3/library/functions.html#int))) – A tuple `window, name, (pattern, ratio)` describing the address range assigned to the
  window. `pattern` is a `addr_width` wide pattern that may be used in `Case`
  or `match` to determine if a value is within the address range of `window`. When
  bridging busses of unequal data widths, `ratio` is the amount of contiguous addresses
  on the narrower bus that are accessed for each transaction on the wider bus. Otherwise,
  it is always 1.

#### all_resources()

Iterate all resources and their address ranges.

Recursively iterate all resources in ascending order of their address, performing address
translation for resources that are located behind a window.

* **Yields:**
  [`ResourceInfo`](#amaranth_soc.memory.ResourceInfo) – A description of the resource and its address range.

#### find_resource(resource)

Find address range corresponding to a resource.

Recursively find the address range of a resource, performing address translation for
resources that are located behind a window.

* **Parameters:**
  **resource** ([`amaranth.lib.wiring.Component`](../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Component)) – Resource previously added to this [`MemoryMap`](#amaranth_soc.memory.MemoryMap) or one of its windows.
* **Returns:**
  A description of the resource and its address range.
* **Return type:**
  [`ResourceInfo`](#amaranth_soc.memory.ResourceInfo)
* **Raises:**
  [**KeyError**](https://docs.python.org/3/library/exceptions.html#KeyError) – If the resource is not found.

#### decode_address(address)

Decode an address to a resource.

* **Parameters:**
  **address** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Address of interest.
* **Returns:**
  A resource mapped to the provided address, or `None` if there is no such resource.
* **Return type:**
  [`amaranth.lib.wiring.Component`](../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Component) or `None`

### *class* amaranth_soc.memory.ResourceInfo

Resource metadata.

A description of a [`MemoryMap`](#amaranth_soc.memory.MemoryMap) resource with its assigned path and address range.

* **Parameters:**
  * **resource** ([`amaranth.lib.wiring.Component`](../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Component)) – A resource located in the [`MemoryMap`](#amaranth_soc.memory.MemoryMap). See [`MemoryMap.add_resource()`](#amaranth_soc.memory.MemoryMap.add_resource) for
    details.
  * **path** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of `MemoryMap.Name`) – Path of the resource. It is composed of the names of each window sitting between
    the resource and the [`MemoryMap`](#amaranth_soc.memory.MemoryMap) from which this [`ResourceInfo`](#amaranth_soc.memory.ResourceInfo) was obtained.
    See [`MemoryMap.add_window()`](#amaranth_soc.memory.MemoryMap.add_window) for details.
  * **start** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Start of the address range assigned to the resource.
  * **end** ([`int`](https://docs.python.org/3/library/functions.html#int)) – End of the address range assigned to the resource.
  * **width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Amount of data bits accessed at each address. It may be equal to the data width of the
    [`MemoryMap`](#amaranth_soc.memory.MemoryMap) from which this [`ResourceInfo`](#amaranth_soc.memory.ResourceInfo) was obtained, or less if the
    resource is located behind a window that uses sparse addressing.


# memory.html.md

# Memory arrays

The [`amaranth.lib.memory`](#module-amaranth.lib.memory) module provides a way to efficiently store data organized as an array of identically shaped rows, which may be addressed (read and/or written) one at a time. This organization is well suited for an efficient implementation in hardware.

## Introduction

A memory [component](wiring.md#wiring) is accessed through read and write *memory ports*, which are [interface objects](wiring.md#wiring) with address, data, and enable ports. The address input selects the memory row to be accessed, the enable input determines whether an access will be made, and the data output (for read ports) or data input (for write ports) transfers data between the memory row and the rest of the design. Read ports can be synchronous (where the memory row access is triggered by the [active edge](../guide.md#lang-sync) of a clock) or asynchronous (where the memory row is accessed continuously); write ports are always synchronous.

#### NOTE
Unfortunately, the terminology related to memories has an ambiguity: a “port” could refer to either an *interface port* (`Signal` objects created by the [`amaranth.lib.wiring`](wiring.md#module-amaranth.lib.wiring) module) or to a *memory port* ([`ReadPort`](#amaranth.lib.memory.ReadPort) or [`WritePort`](#amaranth.lib.memory.WritePort) object created by [`amaranth.lib.memory.Memory`](#amaranth.lib.memory.Memory)).

Amaranth documentation always uses the term “memory port” when referring to the latter.

To use a memory, first create a [`Memory`](#amaranth.lib.memory.Memory) object, providing a shape, depth (the number of rows), and initial contents. Then, request as many memory ports as the number of concurrent accesses you need to perform by using the [`Memory.read_port()`](#amaranth.lib.memory.Memory.read_port) and [`Memory.write_port()`](#amaranth.lib.memory.Memory.write_port) methods.

#### WARNING
While [`Memory`](#amaranth.lib.memory.Memory) will provide virtually any memory configuration on request and all will simulate correctly, only a subset of configurations can implemented in hardware efficiently or at all. Exactly what any given hardware platform supports is specific to both the device and the toolchain used.

However, the following two configurations are well-supported on most platforms:

1. Zero or one write ports and any amount of read ports. Almost all devices include one or two read ports in a hardware memory block, but the toolchain will replicate memory blocks as needed to meet the requested amount of read ports, using more resources.
2. Two write ports and any amount of read ports whose address input always matches that of the either write port. Most devices include two combined read/write ports in a hardware memory block (known as “true dual-port”, or “TDP”, block RAM), and the toolchain will replicate memory blocks to meet the requested amount of read ports. However, some devices include one read-only and one write-only port in a hardware memory block (known as “simple dual-port”, or “SDP”, block RAM), making this configuration unavailable. Also, the combined (synchronous) read/write port of a TDP block RAM usually does not have independent read enable and write enable inputs; in this configuration, the read enable input should usually be left in the (default if not driven) asserted state.

Most devices include hardware primitives that can efficiently implement memories with asynchronous read ports (known as “LUT RAM”, “distributed RAM”, or “DRAM”; not to be confused with “dynamic RAM”, also abbreviated as “DRAM”). On devices without these hardware primitives, memories with asynchronous read ports are implemented using logic resources, which are consumed at an extremely high rate. Synchronous read ports should be always preferred over asynchronous ones.

Additionally, some memory configurations (that seem like they should be supported by the device and the toolchain) may fail to be recognized, or may use much more resources than they should. This can happen due to device and/or toolchain errata (including defects in Amaranth). Unfortunately, such issues can only be handled on a case-by-case basis; in general, simpler memory configurations are better and more widely supported.

## Examples

<!-- from amaranth import * -->

First, import the [`Memory`](#amaranth.lib.memory.Memory) class.

```python
from amaranth.lib.memory import Memory
```

### Read-only memory

In the following example, a read-only memory is used to output a fixed message in a loop:

<!-- m = Module() -->
```python
message = b"Hello world\n"
m.submodules.memory = memory = \
    Memory(shape=unsigned(8), depth=len(message), init=message)

rd_port = memory.read_port(domain="comb")
with m.If(rd_port.addr == memory.depth - 1):
    m.d.sync += rd_port.addr.eq(0)
with m.Else():
    m.d.sync += rd_port.addr.eq(rd_port.addr + 1)

character = Signal(8)
m.d.comb += character.eq(rd_port.data)
```

In this example, the memory read port is asynchronous, and a change of the address input (labelled a on the diagram below) results in an immediate change of the data output (labelled d).

### First-in, first-out queue

In a more complex example, a power-of-2 sized writable memory is used to implement a first-in, first-out queue:

<!-- m = Module() -->
```python
push = Signal()
pop  = Signal()

m.submodules.memory = memory = \
    Memory(shape=unsigned(8), depth=16, init=[])

wr_port = memory.write_port()
m.d.comb += wr_port.en.eq(push)
with m.If(push):
    m.d.sync += wr_port.addr.eq(wr_port.addr + 1)

rd_port = memory.read_port(transparent_for=(wr_port,))
m.d.comb += rd_port.en.eq(pop)
with m.If(pop):
    m.d.sync += rd_port.addr.eq(rd_port.addr + 1)

# Data can be shifted in via `wr_port.data` and out via `rd_port.data`.
# This example assumes that empty queue will be never popped from.
```

In this example, the memory read and write ports are synchronous. A write operation (labelled x, w) updates the addressed row 0 on the next clock cycle, and a read operation (labelled y, r) retrieves the contents of the same addressed row 0 on the next clock cycle as well.

However, the memory read port is also configured to be *transparent* relative to the memory write port. This means that if a write and a read operation (labelled t, u respectively) access the same row with address 3, the new contents will be read out, reducing the minimum push-to-pop latency to one cycle, down from two cycles that would be required without the use of transparency.

### Simulation

There are two ways to interact with a memory array in a simulator: requesting a read and/or write port that is used only in a testbench, or directly reading and writing memory contents. In most cases, directly accessing memory contents using [`MemoryData.__getitem__`](#amaranth.hdl.MemoryData.__getitem__) is more convenient.

For example, this testbench </simulator> will clear the least significant bit of every memory row:

```python
async def testbench(ctx):
    for index in len(memory.data):
        ctx.set(memory.data[index], ctx.get(memory.data[index]) & ~1)
```

## Memory description

### *exception* amaranth.hdl.AlreadyElaborated

Exception raised when an elaboratable is being modified after elaboration.

<!-- :canonical: amaranth.hdl.AlreadyElaborated
(not available until `amaranth.hdl` documents it) -->

### *class* amaranth.hdl.MemoryData(\*, shape, depth, init, src_loc_at=0)

Abstract description of a memory array.

A [`MemoryData`](#amaranth.hdl.MemoryData) object describes the geometry (shape and depth) and the initial contents
of a memory array, without specifying the way in which it is accessed. It is conceptually
similar to an array of `Signal`s.

The `init` parameter and assignment to the `init` attribute have the same effect, with
[`MemoryData.Init`](#amaranth.hdl.MemoryData.Init) converting elements of the iterable to match `shape` and using
a default value for rows that are not explicitly initialized.

Changing the initial contents of a [`MemoryData`](#amaranth.hdl.MemoryData) is only possible until it is used to
elaborate a memory; afterwards, attempting to do so will raise the `AlreadyElaborated`
exception.

#### WARNING
Uninitialized memories (including ASIC memories and some FPGA memories) are
[not yet supported](https://github.com/amaranth-lang/amaranth/issues/270), and
the `init` parameter must be always provided, if only as `init=[]`.

* **Parameters:**
  * **shape** ([shape-like](../guide.md#lang-shapelike) object) – Shape of each memory row.
  * **depth** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Number of memory rows.
  * **init** (*iterable* *of* *initial values*) – Initial values for memory rows.

<!-- :canonical: amaranth.hdl.MemoryData
(not available until `amaranth.hdl` documents it) -->

#### *class* Init(...)

Memory initialization data.

This is a special container used only for initial contents of memories. It is similar
to [`list`](https://docs.python.org/3/library/stdtypes.html#list), but does not support inserting or deleting elements; its length is always
the same as the depth of the memory it belongs to.

If `shape` is a [custom shape-castable object](../guide.md#lang-shapecustom), then:

* Each element must be convertible to `shape` via [`ShapeCastable.const()`](../reference.md#amaranth.hdl.ShapeCastable.const), and
* Elements that are not explicitly initialized default to `shape.const(None)`.

Otherwise (when `shape` is a [`Shape`](../reference.md#amaranth.hdl.Shape)):

* Each element must be an [`int`](https://docs.python.org/3/library/functions.html#int), and
* Elements that are not explicitly initialized default to `0`.

#### \_\_getitem_\_(index)

Retrieve a memory row for simulation.

A [`MemoryData`](#amaranth.hdl.MemoryData) object can be indexed with an [`int`](https://docs.python.org/3/library/functions.html#int) to construct a special
value that can be used to read and write the selected memory row in a simulation testbench,
without having to create a memory port.

* **Return type:**
  [`Value`](../reference.md#amaranth.hdl.Value), [assignable](../guide.md#lang-assignable)

## Memory component

<!-- attributes are not documented because they can be easily used to break soundness and we don't
document them for signals either; they are rarely necessary for interoperability -->
<!-- the following two directives document a pair of overloads of :class:`Memory`; this is a little
weird and not really how rst/sphinx are supposed to work but it results in a comprehensible
generated document. be careful to not break this! -->

### *class* amaranth.lib.memory.Memory(data, \*, src_loc_at=0)

### *class* amaranth.lib.memory.Memory(\*, shape, depth, init, src_loc_at=0)

Addressable array of rows.

This [component](wiring.md#wiring) is used to construct a memory array by first specifying its
dimensions and initial contents using the [`MemoryData`](#amaranth.hdl.MemoryData) object and
the `data` parameter (or by providing `shape`, `depth`, and `init` parameters
directly instead) and then adding memory ports using the [`read_port()`](#amaranth.lib.memory.Memory.read_port) and
[`write_port()`](#amaranth.lib.memory.Memory.write_port) methods. Because it is mutable, it should be created and used locally within
the [elaborate](../guide.md#lang-elaboration) method.

Adding ports or changing initial contents of a [`Memory`](#amaranth.lib.memory.Memory) is only possible until it is
elaborated; afterwards, attempting to do so will raise the
`AlreadyElaborated` exception.

### Platform overrides

Define the `get_memory()` platform method to override the implementation of
[`Memory`](#amaranth.lib.memory.Memory), e.g. to instantiate library cells directly.

* **Parameters:**
  * **data** ([`MemoryData`](#amaranth.hdl.MemoryData)) – Representation of memory geometry and contents.
  * **shape** ([shape-like](../guide.md#lang-shapelike) object) – Shape of each memory row.
  * **depth** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Number of memory rows.
  * **init** (*iterable* *of* *initial values*) – Initial values for memory rows.

#### read_port(\*, domain='sync', transparent_for=(), src_loc_at=0)

Request a read port.

If `domain` is `"comb"`, the created read port is asynchronous and always enabled
(with its enable input is tied to `Const(1)`), and its data output always reflects
the contents of the selected row. Otherwise, the created read port is synchronous,
and its data output is updated with the contents of the selected row at each
[active edge](../guide.md#lang-sync) of `domain` where the enable input is asserted.

The `transparent_for` parameter specifies the *transparency set* of this port: zero or
more [`WritePort`](#amaranth.lib.memory.WritePort)s, all of which must belong to the same memory and clock domain.
If another port writes to a memory row at the same time as this port reads from the same
memory row, and that write port is a part of the transparency set, then this port retrieves
the new contents of the row; otherwise, this port retrieves the old contents of the row.

If another write port belonging to a different clock domain updates a memory row that this
port is reading at the same time, the behavior is undefined.

The signature of the returned port is
`ReadPort.Signature(shape=self.shape, addr_width=ceil_log2(self.depth))`.

* **Return type:**
  [`ReadPort`](#amaranth.lib.memory.ReadPort)

#### write_port(\*, domain='sync', granularity=None, src_loc_at=0)

Request a write port.

The created write port is synchronous, updating the contents of the selected row at each
[active edge](../guide.md#lang-sync) of `domain` where the enable input is asserted.

Specifying a *granularity* when `shape` is [`unsigned(width)`](../reference.md#amaranth.hdl.unsigned) or
[`data.ArrayLayout(_, width)`](data.md#amaranth.lib.data.ArrayLayout) makes it possible to partially
update a memory row. In this case, `granularity` must be an integer that evenly divides
`width`, and the memory row is split into `width // granularity` equally sized
parts, each of which is updated if the corresponding bit of the enable input is asserted.

The signature of the new port is
`WritePort.Signature(shape=self.shape, addr_width=ceil_log2(self.depth), granularity=granularity)`.

* **Return type:**
  [`WritePort`](#amaranth.lib.memory.WritePort)

#### *property* read_ports

All read ports defined so far.

This property is provided for the `platform.get_memory()` override.

#### *property* write_ports

All write ports defined so far.

This property is provided for the `platform.get_memory()` override.

## Memory ports

### *class* amaranth.lib.memory.ReadPort(...)

A read memory port.

Memory read ports, which are [interface objects](wiring.md#wiring), can be constructed by calling
[`Memory.read_port()`](#amaranth.lib.memory.Memory.read_port) or via [`ReadPort.Signature.create()`](../../amaranth-soc/csr/bus.md#amaranth_soc.csr.bus.Element.Signature.create).

An asynchronous (`"comb"` domain) memory read port is always enabled. The `en` input of
such a port is tied to `Const(1)`.

* **Attributes:**
  * **signature** ([`ReadPort.Signature`](#amaranth.lib.memory.ReadPort.Signature)) – Signature of this memory port.
  * **memory** ([`Memory`](#amaranth.lib.memory.Memory) or `None`) – Memory associated with this memory port.
  * **domain** ([`str`](https://docs.python.org/3/library/stdtypes.html#str)) – Name of this memory port’s clock domain. For asynchronous ports, `"comb"`.
  * **transparent_for** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of [`WritePort`](#amaranth.lib.memory.WritePort)) – Transparency set of this memory port.

#### *class* Signature(\*, addr_width, shape)

Signature of a memory read port.

* **Parameters:**
  * **addr_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Width of the address port.
  * **shape** ([shape-like](../guide.md#lang-shapelike) object) – Shape of the data port.
* **Members:**
  * **en** (`In(1, init=1)`) – Enable input.
  * **addr** (`In(addr_width)`) – Address input.
  * **data** (`Out(shape)`) – Data output.

### *class* amaranth.lib.memory.WritePort(...)

A write memory port.

Memory write ports, which are [interface objects](wiring.md#wiring), can be constructed by calling
[`Memory.write_port()`](#amaranth.lib.memory.Memory.write_port) or via [`WritePort.Signature.create()`](../../amaranth-soc/csr/bus.md#amaranth_soc.csr.bus.Element.Signature.create).

* **Attributes:**
  * **signature** ([`WritePort.Signature`](#amaranth.lib.memory.WritePort.Signature)) – Signature of this memory port.
  * **memory** ([`Memory`](#amaranth.lib.memory.Memory) or `None`) – Memory associated with this memory port.
  * **domain** ([`str`](https://docs.python.org/3/library/stdtypes.html#str)) – Name of this memory port’s clock domain. Never `"comb"`.

#### *class* Signature(\*, addr_width, shape, granularity=None)

Signature of a memory write port.

Width of the enable input is determined as follows:

* If `granularity` is `None`,
  then `en_width == 1`.
* If `shape` is [`unsigned(data_width)`](../reference.md#amaranth.hdl.unsigned),
  then `en_width == data_width // granularity`.
* If `shape` is [`data.ArrayLayout(_, elem_count)`](data.md#amaranth.lib.data.ArrayLayout),
  then `en_width == elem_count // granularity`.

* **Parameters:**
  * **addr_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Width of the address port.
  * **shape** ([shape-like](../guide.md#lang-shapelike) object) – Shape of the data port.
  * **granularity** ([`int`](https://docs.python.org/3/library/functions.html#int) or `None`) – Granularity of memory access.
* **Members:**
  * **en** (`In(en_width)`) – Enable input.
  * **addr** (`In(addr_width)`) – Address input.
  * **data** (`In(shape)`) – Data input.


# meta.html.md

<a id="meta"></a>

# Interface metadata

The [`amaranth.lib.meta`](#module-amaranth.lib.meta) module provides a way to annotate objects in an Amaranth design and exchange these annotations with external tools in a standardized format.

<!-- from amaranth import *
from amaranth.lib import wiring, meta
from amaranth.lib.wiring import In, Out -->

## Introduction

Many Amaranth designs stay entirely within the Amaranth ecosystem, using the facilities it provides to define, test, and build hardware. In this case, the design is available for exploration using Python code, and metadata is not necessary. However, if an Amaranth design needs to fit into an existing ecosystem, or, conversely, to integrate components developed for another ecosystem, metadata can be used to exchange structured information about the design.

Consider a simple [component](wiring.md#wiring):

```python
class Adder(wiring.Component):
    a: In(unsigned(32))
    b: In(unsigned(32))
    o: Out(unsigned(33))

    def elaborate(self, platform):
        m = Module()
        m.d.comb += self.o.eq(self.a + self.b)
        return m
```

<!-- TODO: link to Verilog backend doc when we have it -->

While it can be easily converted to Verilog, external tools will find the interface of the resulting module opaque unless they parse its Verilog source (a difficult and unrewarding task), or are provided with a description of it. Components can describe their signature with JSON-based metadata:

```pycon
>>> adder = Adder()
>>> adder.metadata 
<amaranth.lib.wiring.ComponentMetadata for ...Adder object at ...>
>>> adder.metadata.as_json() 
{
    'interface': {
        'members': {
            'a': {
                'type': 'port',
                'name': 'a',
                'dir': 'in',
                'width': 32,
                'signed': False,
                'init': '0'
            },
            'b': {
                'type': 'port',
                'name': 'b',
                'dir': 'in',
                'width': 32,
                'signed': False,
                'init': '0'
            },
            'o': {
                'type': 'port',
                'name': 'o',
                'dir': 'out',
                'width': 33,
                'signed': False,
                'init': '0'
            }
        },
        'annotations': {}
    }
}
```

<!-- # The way doctest requires this object to be formatted is truly hideous, even with +NORMALIZE_WHITESPACE.
assert adder.metadata.as_json() == {'interface': {'members': {'a': {'type': 'port', 'name': 'a', 'dir': 'in', 'width': 32, 'signed': False, 'init': '0'}, 'b': {'type': 'port', 'name': 'b', 'dir': 'in', 'width': 32, 'signed': False, 'init': '0'}, 'o': {'type': 'port', 'name': 'o', 'dir': 'out', 'width': 33, 'signed': False, 'init': '0'}}, 'annotations': {}}} -->

All metadata in Amaranth must adhere to a schema in the [JSON Schema](https://json-schema.org) language, which is integral to its definition, and can be used to validate the generated JSON:

```pycon
>>> wiring.ComponentMetadata.validate(adder.metadata.as_json())
```

The built-in component metadata can be extended to provide arbitrary information about an interface through user-defined annotations. For example, a memory bus interface could provide the layout of any memory-mapped peripherals accessible through that bus.

## Defining annotations

Consider a simple control and status register (CSR) bus that provides the memory layout of the accessible registers via an annotation:

```python
class CSRLayoutAnnotation(meta.Annotation):
    schema = {
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "$id": "https://amaranth-lang.org/schema/example/0/csr-layout.json",
        "type": "object",
        "properties": {
            "registers": {
                "type": "object",
                "patternProperties": {
                    "^.+$": {
                        "type": "integer",
                        "minimum": 0,
                    },
                },
            },
        },
        "requiredProperties": [
            "registers",
        ],
    }

    def __init__(self, origin):
        self._origin = origin

    @property
    def origin(self):
        return self._origin

    def as_json(self):
        instance = {
            "registers": self.origin.registers,
        }
        # Validating the value returned by `as_json()` ensures its conformance.
        self.validate(instance)
        return instance


class CSRSignature(wiring.Signature):
    def __init__(self):
        super().__init__({
            "addr":     Out(16),
            "w_en":     Out(1),
            "w_data":   Out(32),
            "r_en":     Out(1),
            "r_data":   In(32),
        })

    def annotations(self, obj, /):
        # Unfortunately `super()` cannot be used in `wiring.Signature` subclasses;
        # instead, use a direct call to a superclass method. In this case that is
        # `wiring.Signature` itself, but in a more complex class hierarchy it could
        # be different.
        return wiring.Signature.annotations(self, obj) + (CSRLayoutAnnotation(obj),)
```

A component that embeds a few CSR registers would define their addresses:

```python
class MyPeripheral(wiring.Component):
    csr_bus: In(CSRSignature())

    def __init__(self):
        super().__init__()
        self.csr_bus.registers = {
            "control": 0x0000,
            "status":  0x0004,
            "data":    0x0008,
        }
```

```pycon
>>> peripheral = MyPeripheral()
>>> peripheral.metadata.as_json() 
{
    'interface': {
        'members': {
            'csr_bus': {
                'type': 'interface',
                'members': {
                    'addr': {
                        'type': 'port',
                        'name': 'csr_bus__addr',
                        'dir': 'in',
                        'width': 16,
                        'signed': False,
                        'init': '0'
                    },
                    'w_en': {
                        'type': 'port',
                        'name': 'csr_bus__w_en',
                        'dir': 'in',
                        'width': 1,
                        'signed': False,
                        'init': '0'
                    },
                    'w_data': {
                        'type': 'port',
                        'name': 'csr_bus__w_data',
                        'dir': 'in',
                        'width': 32,
                        'signed': False,
                        'init': '0'
                    },
                    'r_en': {
                        'type': 'port',
                        'name': 'csr_bus__r_en',
                        'dir': 'in',
                        'width': 1,
                        'signed': False,
                        'init': '0'
                    },
                    'r_data': {
                        'type': 'port',
                        'name': 'csr_bus__r_data',
                        'dir': 'out',
                        'width': 32,
                        'signed': False,
                        'init': '0'
                    },
                },
                'annotations': {
                    'https://amaranth-lang.org/schema/example/0/csr-layout.json': {
                        'registers': {
                            'control': 0,
                            'status':  4,
                            'data':    8
                        }
                    }
                }
            }
        },
        'annotations': {}
    }
}
```

<!-- # The way doctest requires this object to be formatted is truly hideous, even with +NORMALIZE_WHITESPACE.
assert peripheral.metadata.as_json() == {'interface': {'members': {'csr_bus': {'type': 'interface', 'members': {'addr': {'type': 'port', 'name': 'csr_bus__addr', 'dir': 'in', 'width': 16, 'signed': False, 'init': '0'}, 'w_en': {'type': 'port', 'name': 'csr_bus__w_en', 'dir': 'in', 'width': 1, 'signed': False, 'init': '0'}, 'w_data': {'type': 'port', 'name': 'csr_bus__w_data', 'dir': 'in', 'width': 32, 'signed': False, 'init': '0'}, 'r_en': {'type': 'port', 'name': 'csr_bus__r_en', 'dir': 'in', 'width': 1, 'signed': False, 'init': '0'}, 'r_data': {'type': 'port', 'name': 'csr_bus__r_data', 'dir': 'out', 'width': 32, 'signed': False, 'init': '0'}}, 'annotations': {'https://amaranth-lang.org/schema/example/0/csr-layout.json': {'registers': {'control': 0, 'status': 4, 'data': 8}}}}}, 'annotations': {}}} -->

## Identifying schemas

An [`Annotation`](#amaranth.lib.meta.Annotation) schema must have a `"$id"` property, whose value is a URL that serves as its globally unique identifier. The suggested format of this URL is:

```default
<protocol>://<domain>/schema/<package>/<version>/<path>.json
```

where:

> * `<domain>` is a domain name registered to the person or entity defining the annotation;
> * `<package>` is the name of the Python package providing the [`Annotation`](#amaranth.lib.meta.Annotation) subclass;
> * `<version>` is the version of that package;
> * `<path>` is a non-empty string specific to the annotation.

#### NOTE
Annotations used in the Amaranth project packages are published under [https://amaranth-lang.org/schema/](https://amaranth-lang.org/schema/) according to this URL format, and are covered by the usual compatibility commitment.

Other projects that define additional Amaranth annotations are encouraged, but not required, to make their schemas publicly accessible; the only requirement is for the URL to be globally unique.

## Reference

### *exception* amaranth.lib.meta.InvalidSchema

Exception raised when a subclass of [`Annotation`](#amaranth.lib.meta.Annotation) is defined with a non-conformant
[`schema`](#amaranth.lib.meta.Annotation.schema).

### *exception* amaranth.lib.meta.InvalidAnnotation

Exception raised by [`Annotation.validate()`](#amaranth.lib.meta.Annotation.validate) when the JSON representation of
an annotation does not conform to its schema.

### *class* amaranth.lib.meta.Annotation

Interface annotation.

Annotations are containers for metadata that can be retrieved from an interface object using
the [`Signature.annotations`](wiring.md#amaranth.lib.wiring.Signature.annotations) method.

Annotations have a JSON representation whose structure is defined by the [JSON Schema](https://json-schema.org)
language.

#### *classmethod* \_\_init_subclass_\_()

Defining a subclass of [`Annotation`](#amaranth.lib.meta.Annotation) causes its [`schema`](#amaranth.lib.meta.Annotation.schema) to be validated.

* **Raises:**
  * [**InvalidSchema**](#amaranth.lib.meta.InvalidSchema) – If [`schema`](#amaranth.lib.meta.Annotation.schema) doesn’t conform to the 2020-12 draft of [JSON Schema](https://json-schema.org).
  * [**InvalidSchema**](#amaranth.lib.meta.InvalidSchema) – If [`schema`](#amaranth.lib.meta.Annotation.schema) doesn’t have a  [“$id” keyword](https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-01#name-the-id-keyword) at its root. This requirement is
        specific to [`Annotation`](#amaranth.lib.meta.Annotation) schemas.

#### schema *= { "$id": "...", ... }*

Schema of this annotation, expressed in the [JSON Schema](https://json-schema.org) language.

Subclasses of [`Annotation`](#amaranth.lib.meta.Annotation) must define this class attribute.

* **Type:**
  [`dict`](https://docs.python.org/3/library/stdtypes.html#dict)

#### *abstract property* origin

Python object described by this [`Annotation`](#amaranth.lib.meta.Annotation) instance.

Subclasses of [`Annotation`](#amaranth.lib.meta.Annotation) must implement this property.

#### *abstract* as_json()

Convert to a JSON representation.

Subclasses of [`Annotation`](#amaranth.lib.meta.Annotation) must implement this method.

JSON representation returned by this method must adhere to [`schema`](#amaranth.lib.meta.Annotation.schema) and pass
validation by [`validate()`](#amaranth.lib.meta.Annotation.validate).

* **Returns:**
  JSON representation of this annotation, expressed in Python primitive types
  ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict), [`list`](https://docs.python.org/3/library/stdtypes.html#list), [`str`](https://docs.python.org/3/library/stdtypes.html#str), [`int`](https://docs.python.org/3/library/functions.html#int), [`bool`](https://docs.python.org/3/library/functions.html#bool)).
* **Return type:**
  [`dict`](https://docs.python.org/3/library/stdtypes.html#dict)

#### *classmethod* validate(instance)

Validate a JSON representation against [`schema`](#amaranth.lib.meta.Annotation.schema).

* **Parameters:**
  **instance** ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict)) – JSON representation to validate, either previously returned by [`as_json()`](#amaranth.lib.meta.Annotation.as_json)
  or retrieved from an external source.
* **Raises:**
  [**InvalidAnnotation**](#amaranth.lib.meta.InvalidAnnotation) – If `instance` doesn’t conform to [`schema`](#amaranth.lib.meta.Annotation.schema).


# minimal.html.md

# Minimal SoC Example

The `minimal` example demonstrates the simplest possible ChipFlow SoC design. It includes a RISC-V CPU core with basic peripherals.

## Overview

This example creates a System-on-Chip with:

- **Minerva RISC-V CPU** - A 32-bit RISC-V processor with multiply/divide support
- **QSPI Flash** - External flash memory for code storage
- **SRAM** - 1KB of on-chip RAM
- **GPIO** - 8-bit general purpose I/O
- **GPIO (Open Drain)** - 4-bit open-drain GPIO for I2C-style interfaces
- **UART** - Serial communication at 115200 baud

## Project Structure

```text
minimal/
├── chipflow.toml        # Project configuration
├── design/
│   ├── design.py        # Main SoC design
│   ├── software/        # Firmware source code
│   ├── steps/           # Custom build steps
│   └── tests/           # Test reference data
└── README.md
```

## Configuration

The `chipflow.toml` defines the project:

```toml
[chipflow]
project_name = "chipflow-examples-minimal"

[chipflow.top]
soc = "design.design:MySoC"

[chipflow.steps]
board = "design.steps.board:MyBoardStep"

[chipflow.silicon]
process = "sky130"
package = "openframe"

[chipflow.test]
event_reference = "design/tests/events_reference.json"
```

## Design Overview

The design is defined in `design/design.py`. Here’s the key structure:

```python
class MySoC(wiring.Component):
    def __init__(self):
        super().__init__({
            "flash": Out(QSPIFlashSignature()),
            "uart_0": Out(UARTSignature()),
            "gpio_0": Out(GPIOSignature(pin_count=8)),
            "gpio_open_drain": Out(GPIOSignature(
                pin_count=4,
                sky130_drive_mode=Sky130DriveMode.OPEN_DRAIN_STRONG_UP
            ))
        })
```

The component declares its external interfaces using IO Signatures. These signatures tell ChipFlow how to map the design to physical pins.

## Memory Map

The SoC uses the following memory map:

| Region     | Base Address   | Description                               |
|------------|----------------|-------------------------------------------|
| SPI Flash  | `0x00000000`   | Code storage (boot address at 1MB offset) |
| SRAM       | `0x10000000`   | 1KB on-chip RAM                           |
| CSR Base   | `0xb0000000`   | Control/Status registers                  |
| GPIO CSR   | `0xb1000000`   | GPIO peripheral registers                 |
| UART CSR   | `0xb2000000`   | UART peripheral registers                 |
| SoC ID CSR | `0xb4000000`   | SoC identification registers              |

## Running the Example

```bash
cd minimal
pdm chipflow pin lock
pdm sim-check
pdm submit --wait
```

## Key Concepts Demonstrated

1. **IO Signatures**: Using `QSPIFlashSignature`, `UARTSignature`, and `GPIOSignature` to define peripheral interfaces.
2. **Wishbone Bus**: Connecting CPU, memory, and peripherals using Wishbone arbiters and decoders.
3. **CSR Registers**: Using the CSR bus for low-speed peripheral configuration.
4. **Software Builds**: Attaching firmware to the design with `SoftwareBuild`.

## Next Steps

- Modify the GPIO pin count or add more peripherals
- Change the target process in `chipflow.toml`
- Explore the [MCU SoC Example](mcu-soc.md) example for a more complete design


# platform-api.html.md

# Platform API Reference

This section provides the API reference for the ChipFlow platform library.

* [chipflow](chipflow-lib/autoapi/chipflow/index.md)
  * [Submodules](chipflow-lib/autoapi/chipflow/index.md#submodules)
    * [chipflow.auth](chipflow-lib/autoapi/chipflow/auth/index.md)
    * [chipflow.auth_command](chipflow-lib/autoapi/chipflow/auth_command/index.md)
    * [chipflow.common](chipflow-lib/autoapi/chipflow/common/index.md)
    * [chipflow.config](chipflow-lib/autoapi/chipflow/config/index.md)
    * [chipflow.packages](chipflow-lib/autoapi/chipflow/packages/index.md)
    * [chipflow.packaging](chipflow-lib/autoapi/chipflow/packaging/index.md)
    * [chipflow.platform](chipflow-lib/autoapi/chipflow/platform/index.md)
    * [chipflow.utils](chipflow-lib/autoapi/chipflow/utils/index.md)
  * [Exceptions](chipflow-lib/autoapi/chipflow/index.md#exceptions)
  * [Functions](chipflow-lib/autoapi/chipflow/index.md#functions)
  * [Package Contents](chipflow-lib/autoapi/chipflow/index.md#package-contents)
    * [`ChipFlowError`](chipflow-lib/autoapi/chipflow/index.md#chipflow.ChipFlowError)
    * [`ensure_chipflow_root()`](chipflow-lib/autoapi/chipflow/index.md#chipflow.ensure_chipflow_root)


# platform.html.md

<a id="platform"></a>

# Platform integration

* [Altera](platform/altera.md)
  * [`AlteraPlatform`](platform/altera.md#amaranth.vendor.AlteraPlatform)
* [Gowin](platform/gowin.md)
  * [`GowinPlatform`](platform/gowin.md#amaranth.vendor.GowinPlatform)
* [Lattice](platform/lattice.md)
  * [`LatticePlatform`](platform/lattice.md#amaranth.vendor.LatticePlatform)
* [Quicklogic](platform/quicklogic.md)
  * [`QuicklogicPlatform`](platform/quicklogic.md#amaranth.vendor.QuicklogicPlatform)
* [SiliconBlue](platform/siliconblue.md)
  * [`SiliconBluePlatform`](platform/siliconblue.md#amaranth.vendor.SiliconBluePlatform)
* [Xilinx](platform/xilinx.md)
  * [`XilinxPlatform`](platform/xilinx.md#amaranth.vendor.XilinxPlatform)


# processors.html.md

# Processors

CPU cores and debug modules.


# quicklogic.html.md

# Quicklogic

The [`QuicklogicPlatform`](#amaranth.vendor.QuicklogicPlatform) class provides a base platform to support Quicklogic toolchains.

The Symbiflow toolchain is supported.

### *class* amaranth.vendor.QuicklogicPlatform

### Symbiflow toolchain

Required tools:
: * `symbiflow_synth`
  * `symbiflow_pack`
  * `symbiflow_place`
  * `symbiflow_route`
  * `symbiflow_write_fasm`
  * `symbiflow_write_bitstream`

The environment is populated by running the script specified in the environment variable
`AMARANTH_ENV_QLSYMBIFLOW`, if present.

Available overrides:
: * `add_constraints`: inserts commands in XDC file.


# reference.html.md

# Language reference

#### WARNING
This reference is a work in progress and is seriously incomplete!

While the wording below states that anything not described in this document isn’t covered by the backwards compatibility guarantee, this should be ignored until the document is complete and this warning is removed.

This reference describes the Python classes that underlie the Amaranth language’s syntax. It assumes familiarity with the language guide <guide>.

<a id="lang-stability"></a>

## Backwards compatibility

As part of the Amaranth backwards compatibility guarantee, any behaviors described in this document will not change from a version to another without at least one version including a warning about the impending change. Any nontrivial change to these behaviors must also go through the public review as a part of the [Amaranth Request for Comments process](https://amaranth-lang.org/rfcs/).

Conversely, any behavior not documented here is subject to change at any time with or without notice, and any names under the [`amaranth.hdl`](#module-amaranth.hdl) module that are not explicitly included in this document, even if they do not begin with an underscore, are internal to the implementation of the language.

<a id="lang-importing"></a>

## Importing syntax

There are two ways to import the Amaranth syntax into a Python file: by importing the [prelude](guide.md#lang-prelude) or by importing individual names from the [`amaranth.hdl`](#module-amaranth.hdl) module. Since the prelude is kept small and rarely extended to avoid breaking downstream code that uses a glob import, there are some names that are only exported from the [`amaranth.hdl`](#module-amaranth.hdl) module. The following three snippets are equivalent:

```python
from amaranth import *

m = Module()
```

```python
import amaranth as am

m = am.Module()
```

```python
from amaranth.hdl import Module

m = Module()
```

The prelude exports exactly the following names:

<!-- must be kept in sync with amaranth/__init__.py! -->
* [`Shape`](#amaranth.hdl.Shape)
* [`unsigned()`](#amaranth.hdl.unsigned)
* [`signed()`](#amaranth.hdl.signed)
* [`Value`](#amaranth.hdl.Value)
* `Const`
* `C()`
* `Mux()`
* `Cat()`
* `Array`
* `Signal`
* `ClockSignal`
* `ResetSignal`
* `Format`
* `Print`
* `Assert()`
* `Module`
* `ClockDomain`
* `Elaboratable`
* `Fragment`
* `Instance`
* `Memory`
* `Record` (deprecated)
* `DomainRenamer`
* `ResetInserter`
* `EnableInserter`

<a id="lang-srcloc"></a>

## Source locations

Many functions and methods in Amaranth take the `src_loc_at=0` keyword argument. These language constructs may inspect the call stack to determine the file and line of its call site, which will be used to annotate generated code when a netlist is generated or to improve diagnostic messages.

Some call sites are not relevant for an Amaranth designer; e.g. when an Amaranth language construct is called from a user-defined utility function, the source location of the call site within this utility function is usually not interesting to the designer. In these cases, one or more levels of function calls can be removed from consideration using the `src_loc_at` argument as follows (using [`Shape.cast()`](#amaranth.hdl.Shape.cast) to demonstrate the concept):

```python
def my_shape_cast(obj, *, src_loc_at=0):
    ... # additionally process `obj`...
    return Shape.cast(obj, src_loc_at=1 + src_loc_at)
```

The number `1` corresponds to the number of call stack frames that should be skipped.

## Shapes

See also the introduction to [shapes](guide.md#lang-shapes) and [casting from shape-like objects](guide.md#lang-shapelike) in the language guide.

### *class* amaranth.hdl.Shape(width=1, signed=False)

Bit width and signedness of a [`Value`](#amaranth.hdl.Value).

A [`Shape`](#amaranth.hdl.Shape) can be obtained by:

* constructing with explicit bit width and signedness;
* using the [`signed()`](#amaranth.hdl.signed) and [`unsigned()`](#amaranth.hdl.unsigned) aliases if the signedness is known upfront;
* casting from a variety of objects using the [`cast()`](#amaranth.hdl.Shape.cast) method.

* **Parameters:**
  * **width** ([*int*](https://docs.python.org/3/library/functions.html#int)) – The number of bits in the representation of a value. This includes the sign bit for signed
    values. Cannot be zero if the value is signed.
  * **signed** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – Whether the value is signed. Signed values use the
    [two’s complement](https://en.wikipedia.org/wiki/Two's_complement) representation.

#### *static* cast(obj, \*, src_loc_at=0)

Cast `obj` to a shape.

Many [shape-like](guide.md#lang-shapelike) objects can be cast to a shape:

* a [`Shape`](#amaranth.hdl.Shape), where the result is itself;
* an [`int`](https://docs.python.org/3/library/functions.html#int), where the result is [`unsigned(obj)`](#amaranth.hdl.unsigned);
* a [`range`](https://docs.python.org/3/library/stdtypes.html#range), where the result has minimal width required to represent all elements
  of the range, and is signed if any element of the range is signed;
* an [`enum.Enum`](https://docs.python.org/3/library/enum.html#enum.Enum) whose members are all [constant-castable](guide.md#lang-constcasting)
  or [`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum), where the result is wide enough to represent any member of
  the enumeration, and is signed if any member of the enumeration is signed;
* a [`ShapeCastable`](#amaranth.hdl.ShapeCastable) object, where the result is obtained by repeatedly calling
  [`obj.as_shape()`](#amaranth.hdl.ShapeCastable.as_shape).

* **Raises:**
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `obj` cannot be converted to a [`Shape`](#amaranth.hdl.Shape).
  * [**RecursionError**](https://docs.python.org/3/library/exceptions.html#RecursionError) – If `obj` is a [`ShapeCastable`](#amaranth.hdl.ShapeCastable) object that casts to itself.

#### \_\_repr_\_()

Python code that creates this shape.

Returns `f"signed({self.width})"` or `f"unsigned({self.width})"`.

### amaranth.hdl.unsigned(width)

Returns `Shape(width, signed=False)`.

### amaranth.hdl.signed(width)

Returns `Shape(width, signed=True)`.

### *class* amaranth.hdl.ShapeCastable

Interface class for objects that can be cast to a [`Shape`](#amaranth.hdl.Shape).

Shapes of values in the Amaranth language are specified using [shape-like objects](guide.md#lang-shapelike). Inheriting a class from [`ShapeCastable`](#amaranth.hdl.ShapeCastable) and implementing all of
the methods described below adds instances of that class to the list of shape-like objects
recognized by the [`Shape.cast()`](#amaranth.hdl.Shape.cast) method. This is a part of the mechanism for seamlessly
extending the Amaranth language in third-party code.

To illustrate their purpose, consider constructing a signal from a shape-castable object
`shape_castable`:

```default
value_like = Signal(shape_castable, init=initializer)
```

The code above is equivalent to:

```default
value_like = shape_castable(Signal(
    shape_castable.as_shape(),
    init=shape_castable.const(initializer)
))
```

Note that the `shape_castable(x)` syntax performs `shape_castable.__call__(x)`.

#### as_shape()

Convert `self` to a [shape-like object](guide.md#lang-shapelike).

This method is called by the Amaranth language to convert `self` to a concrete
[`Shape`](#amaranth.hdl.Shape). It will usually return a [`Shape`](#amaranth.hdl.Shape) object, but it may also return
another shape-like object to delegate its functionality.

This method must be idempotent: when called twice on the same object, the result must be
exactly the same.

This method may also be called by code that is not a part of the Amaranth language.

* **Return type:**
  Any other object recognized by [`Shape.cast()`](#amaranth.hdl.Shape.cast).
* **Raises:**
  [**Exception**](https://docs.python.org/3/library/exceptions.html#Exception) – When the conversion cannot be done. This exception must be propagated by callers
      (except when checking whether an object is shape-castable or not), either directly
      or as a cause of another exception.

#### const(obj)

Convert a constant initializer `obj` to its value representation.

This method is called by the Amaranth language to convert `obj`, which may be an
arbitrary Python object, to a concrete [value-like object](guide.md#lang-valuelike).
The object `obj` will usually be a Python literal that can conveniently represent
a constant value whose shape is described by `self`. While not constrained here,
the result will usually be an instance of the return type of [`__call__()`](#amaranth.hdl.ShapeCastable.__call__).

For any `obj`, the following condition must hold:

```default
Shape.cast(self) == Const.cast(self.const(obj)).shape()
```

This method may also be called by code that is not a part of the Amaranth language.

* **Return type:**
  A [value-like object](guide.md#lang-valuelike) that is [constant-castable](guide.md#lang-constcasting).
* **Raises:**
  [**Exception**](https://docs.python.org/3/library/exceptions.html#Exception) – When the conversion cannot be done. This exception must be propagated by callers,
      either directly or as a cause of another exception. While not constrained here,
      usually the exception class will be [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError) or [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError).

#### from_bits(raw)

Lift a bit pattern to a higher-level representation.

This method is called by the Amaranth language to lift `raw`, which is an [`int`](https://docs.python.org/3/library/functions.html#int),
to a higher-level representation, which may be any object accepted by [`const()`](#amaranth.hdl.ShapeCastable.const).
Most importantly, the simulator calls this method when the value of a shape-castable
object is retrieved.

For any valid bit pattern `raw`, the following condition must hold:

```default
Const.cast(self.const(self.from_bits(raw))).value == raw
```

While [`const()`](#amaranth.hdl.ShapeCastable.const) will usually return an Amaranth value or a custom value-castable
object that is convenient to use while constructing the design, this method will usually
return a Python object that is convenient to use while simulating the design. While not
constrained here, these objects should have the same type whenever feasible.

This method may also be called by code that is not a part of the Amaranth language.

* **Return type:**
  unspecified type
* **Raises:**
  [**Exception**](https://docs.python.org/3/library/exceptions.html#Exception) – When the bit pattern isn’t valid. This exception must be propagated by callers,
      either directly or as a cause of another exception. While not constrained here,
      usually the exception class will be [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError).

#### \_\_call_\_(obj)

Lift a [value-like object](guide.md#lang-valuelike) to a higher-level representation.

This method is called by the Amaranth language to lift `obj`, which may be any
[value-like object](guide.md#lang-valuelike) whose shape equals `Shape.cast(self)`,
to a higher-level representation, which may be any value-like object with the same
shape. While not constrained here, usually a [`ShapeCastable`](#amaranth.hdl.ShapeCastable) implementation will
be paired with a [`ValueCastable`](#amaranth.hdl.ValueCastable) implementation, and this method will return
an instance of the latter.

If `obj` is not as described above, this interface does not constrain the behavior
of this method. This may be used to implement another call-based protocol at the same
time.

For any compliant `obj`, the following condition must hold:

```default
Value.cast(self(obj)) == Value.cast(obj)
```

This method may also be called by code that is not a part of the Amaranth language.

* **Return type:**
  A [value-like object](guide.md#lang-valuelike).

#### format(obj, spec)

Format a value.

This method is called by the Amaranth language to implement formatting for custom
shapes. Whenever `"{obj:spec}"` is encountered by `Format`, and `obj`
has a custom shape that has a [`format()`](#amaranth.hdl.ShapeCastable.format) method, `obj.shape().format(obj, "spec")`
is called, and the format specifier is replaced with the result.

The default [`format()`](#amaranth.hdl.ShapeCastable.format) implementation is:

```default
def format(self, obj, spec):
    return Format(f"{{:{spec}}}", Value.cast(obj))
```

* **Return type:**
  `Format`

### *class* amaranth.hdl.ShapeLike

Abstract class representing all objects that can be cast to a [`Shape`](#amaranth.hdl.Shape).

`issubclass(cls, ShapeLike)` returns `True` for:

* [`Shape`](#amaranth.hdl.Shape);
* [`ShapeCastable`](#amaranth.hdl.ShapeCastable) and its subclasses;
* [`int`](https://docs.python.org/3/library/functions.html#int) and its subclasses;
* [`range`](https://docs.python.org/3/library/stdtypes.html#range) and its subclasses;
* `enum.EnumMeta` and its subclasses;
* [`ShapeLike`](#amaranth.hdl.ShapeLike) itself.

`isinstance(obj, ShapeLike)` returns `True` for:

* [`Shape`](#amaranth.hdl.Shape) instances;
* [`ShapeCastable`](#amaranth.hdl.ShapeCastable) instances;
* non-negative [`int`](https://docs.python.org/3/library/functions.html#int) values;
* [`range`](https://docs.python.org/3/library/stdtypes.html#range) instances;
* [`enum.Enum`](https://docs.python.org/3/library/enum.html#enum.Enum) subclasses where all values are [value-like objects](guide.md#lang-valuelike).

This class cannot be instantiated or subclassed. It can only be used for checking types of
objects.

## Values

See also the introduction to [values](guide.md#lang-values) and [casting from value-like objects](guide.md#lang-valuelike) in the language guide.

### *class* amaranth.hdl.Value(\*, src_loc_at=0)

Abstract representation of a bit pattern computed in a circuit.

The Amaranth language gives Python code the ability to create a circuit netlist by manipulating
objects representing the computations within that circuit. The [`Value`](#amaranth.hdl.Value) class represents
the bit pattern of a constant, or of a circuit input or output, or within a storage element; or
the result of an arithmetic, logical, or bit container operation.

Operations on this class interpret this bit pattern either as an integer, which can be signed
or unsigned depending on the value’s [`shape()`](#amaranth.hdl.Value.shape), or as a bit container. In either case,
the semantics of operations that implement Python’s syntax, like `+` (also known as
[`__add__()`](#amaranth.hdl.Value.__add__)), are identical to the corresponding operation on a Python [`int`](https://docs.python.org/3/library/functions.html#int) (or on
a Python sequence container). The bitwise inversion `~` (also known as [`__invert__()`](#amaranth.hdl.Value.__invert__))
is the sole exception to this rule.

Data that is not conveniently representable by a single integer or a bit container can be
represented by wrapping a [`Value`](#amaranth.hdl.Value) in a [`ValueCastable`](#amaranth.hdl.ValueCastable) subclass that provides
domain-specific operations. It is possible to extend Amaranth in third-party code using
value-castable objects, and the Amaranth standard library provides several built-in ones:

* [`amaranth.lib.enum`](stdlib/enum.md#module-amaranth.lib.enum) classes are a drop-in replacement for the standard Python
  [`enum`](https://docs.python.org/3/library/enum.html#module-enum) classes that can be defined with an Amaranth shape;
* [`amaranth.lib.data`](stdlib/data.md#module-amaranth.lib.data) classes allow defining complex data structures such as structures
  and unions.

Operations on [`Value`](#amaranth.hdl.Value) instances return another [`Value`](#amaranth.hdl.Value) instance. Unless the exact
type and value of the result is explicitly specified below, it should be considered opaque, and
may change without notice between Amaranth releases as long as the semantics remains the same.

#### NOTE
In each of the descriptions below, you will see a line similar to:

**Return type:** [`Value`](#amaranth.hdl.Value), `unsigned(1)`, [assignable](guide.md#lang-assignable)

The first part ([`Value`](#amaranth.hdl.Value)) indicates that the returned object’s type is a subclass
of [`Value`](#amaranth.hdl.Value). The second part (`unsigned(1)`) describes the shape of that value.
The third part, if present, indicates that the value is assignable if `self` is
assignable.

#### *static* cast(obj)

Cast `obj` to an Amaranth value.

Many [value-like](guide.md#lang-valuelike) objects can be cast to a value:

* a [`Value`](#amaranth.hdl.Value) instance, where the result is itself;
* a [`bool`](#amaranth.hdl.Value.bool) or [`int`](https://docs.python.org/3/library/functions.html#int) instance, where the result is `Const(obj)`;
* an [`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum) instance, or a [`enum.Enum`](https://docs.python.org/3/library/enum.html#enum.Enum) instance whose members are
  all integers, where the result is a `Const(obj, enum_shape)` where `enum_shape`
  is a shape that can represent every member of the enumeration;
* a [`ValueCastable`](#amaranth.hdl.ValueCastable) instance, where the result is obtained by repeatedly calling
  [`obj.as_value()`](#amaranth.hdl.ValueCastable.as_value).

* **Raises:**
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `obj` cannot be converted to a [`Value`](#amaranth.hdl.Value).
  * [**RecursionError**](https://docs.python.org/3/library/exceptions.html#RecursionError) – If `obj` is a [`ValueCastable`](#amaranth.hdl.ValueCastable) object that casts to itself.

#### *abstract* shape()

Shape of `self`.

* **Return type:**
  [shape-like object](guide.md#lang-shapelike)

#### as_unsigned()

Reinterpretation as an unsigned value.

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(len(self))`, [assignable](guide.md#lang-assignable)

#### as_signed()

Reinterpretation as a signed value.

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `signed(len(self))`, [assignable](guide.md#lang-assignable)
* **Raises:**
  [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `len(self) == 0`.

#### \_\_bool_\_()

Forbidden conversion to boolean.

Python uses this operator for its built-in semantics, e.g. `if`, and requires it to
return a [`bool`](#amaranth.hdl.Value.bool). Since this is not possible for Amaranth values, this operator
always raises an exception.

* **Raises:**
  [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – Always.

#### bool()

Conversion to boolean.

Returns the same value as [`any()`](#amaranth.hdl.Value.any), but should be used where `self` is semantically
a number.

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(1)`

#### \_\_pos_\_()

Unary position, `+self`.

* **Returns:**
  `self`
* **Return type:**
  [`Value`](#amaranth.hdl.Value), `self.shape()`

#### \_\_neg_\_()

Unary negation, `-self`.

<!-- >>> C(-1).value, C(-1).shape()
-1, signed(1)
>>> C(-(-1), signed(1)).value # overflows
-1 -->
* **Return type:**
  [`Value`](#amaranth.hdl.Value), `signed(len(self) + 1)`

#### \_\_add_\_(other)

Addition, `self + other`.

* **Returns:**
  * [`Value`](#amaranth.hdl.Value), `unsigned(max(self.width(), other.width()) + 1)` – If both `self` and `other` are unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width() + 1, other.width()) + 1)` – If `self` is unsigned and `other` is signed.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width(), other.width() + 1) + 1)` – If `self` is signed and `other` is unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width(), other.width()) + 1)` – If both `self` and `other` are unsigned.

#### \_\_radd_\_(other)

Addition, `other + self` (reflected).

Like [`__add__()`](#amaranth.hdl.Value.__add__), with operands swapped.

#### \_\_sub_\_(other)

Subtraction, `self - other`.

* **Returns:**
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width(), other.width()) + 1)` – If both `self` and `other` are unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width() + 1, other.width()) + 1)` – If `self` is unsigned and `other` is signed.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width(), other.width() + 1) + 1)` – If `self` is signed and `other` is unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width(), other.width()) + 1)` – If both `self` and `other` are unsigned.
* **Return type:**
  [`Value`](#amaranth.hdl.Value)

#### \_\_rsub_\_(other)

Subtraction, `other - self` (reflected).

Like [`__sub__()`](#amaranth.hdl.Value.__sub__), with operands swapped.

#### \_\_mul_\_(other)

Multiplication, `self * other`.

* **Returns:**
  * [`Value`](#amaranth.hdl.Value), `unsigned(len(self) + len(other))` – If both `self` and `other` are unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(len(self) + len(other))` – If either `self` or `other` are signed.

#### \_\_rmul_\_(other)

Multiplication, `other * self` (reflected).

Like [`__mul__()`](#amaranth.hdl.Value.__mul__), with operands swapped.

#### \_\_floordiv_\_(other)

Flooring division, `self // other`.

If `other` is zero, the result of this operation is zero.

* **Returns:**
  * [`Value`](#amaranth.hdl.Value), `unsigned(len(self))` – If both `self` and `other` are unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(len(self) + 1)` – If `self` is unsigned and `other` is signed.
  * [`Value`](#amaranth.hdl.Value), `signed(len(self))` – If `self` is signed and `other` is unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(len(self) + 1)` – If both `self` and `other` are signed.

#### \_\_rfloordiv_\_(other)

Flooring division, `other // self` (reflected).

If `self` is zero, the result of this operation is zero.

Like [`__floordiv__()`](#amaranth.hdl.Value.__floordiv__), with operands swapped.

#### \_\_mod_\_(other)

Flooring modulo or remainder, `self % other`.

If `other` is zero, the result of this operation is zero.

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `other.shape()`

#### \_\_rmod_\_(other)

Flooring modulo or remainder, `other % self` (reflected).

Like [`__mod__()`](#amaranth.hdl.Value.__mod__), with operands swapped.

#### \_\_eq_\_(other)

Equality comparison, `self == other`.

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(1)`

#### \_\_ne_\_(other)

Inequality comparison, `self != other`.

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(1)`

#### \_\_lt_\_(other)

Less than comparison, `self < other`.

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(1)`

#### \_\_le_\_(other)

Less than or equals comparison, `self <= other`.

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(1)`

#### \_\_gt_\_(other)

Greater than comparison, `self > other`.

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(1)`

#### \_\_ge_\_(other)

Greater than or equals comparison, `self >= other`.

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(1)`

#### \_\_abs_\_()

Absolute value, `abs(self)`.

<!-- >>> abs(C(-1)).shape()
unsigned(1)
>>> C(1).shape()
unsigned(1) -->
* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(len(self))`

#### \_\_invert_\_()

Bitwise NOT, `~self`.

The shape of the result is the same as the shape of `self`, even for unsigned values.

#### WARNING
In Python, `~0` equals `-1`. In Amaranth, `~C(0)` equals `C(1)`.
This is the only case where an Amaranth operator deviates from the Python operator
with the same name.

This deviation is necessary because Python does not allow overriding the logical
`and`, `or`, and `not` operators. Amaranth uses `&`, `|`, and
`~` instead; if it wasn’t the case that `~C(0) == C(1)`, that would have
been impossible.

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `self.shape()`

#### \_\_and_\_(other)

Bitwise AND, `self & other`.

* **Returns:**
  * [`Value`](#amaranth.hdl.Value), `unsigned(max(self.width(), other.width()))` – If both `self` and `other` are unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width() + 1, other.width()))` – If `self` is unsigned and `other` is signed.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width(), other.width() + 1))` – If `self` is signed and `other` is unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width(), other.width()))` – If both `self` and `other` are unsigned.

#### \_\_rand_\_(other)

Bitwise AND, `other & self`.

Like [`__and__()`](#amaranth.hdl.Value.__and__), with operands swapped.

#### all()

Reduction AND; are all bits `1`?

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(1)`

#### \_\_or_\_(other)

Bitwise OR, `self | other`.

* **Returns:**
  * [`Value`](#amaranth.hdl.Value), `unsigned(max(self.width(), other.width()))` – If both `self` and `other` are unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width() + 1, other.width()))` – If `self` is unsigned and `other` is signed.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width(), other.width() + 1))` – If `self` is signed and `other` is unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width(), other.width()))` – If both `self` and `other` are unsigned.

#### \_\_ror_\_(other)

Bitwise OR, `other | self`.

Like [`__or__()`](#amaranth.hdl.Value.__or__), with operands swapped.

#### any()

Reduction OR; is any bit `1`?

Performs the same operation as [`bool()`](#amaranth.hdl.Value.bool), but should be used where `self` is
semantically a bit sequence.

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(1)`

#### \_\_xor_\_(other)

Bitwise XOR, `self ^ other`.

* **Returns:**
  * [`Value`](#amaranth.hdl.Value), `unsigned(max(self.width(), other.width()))` – If both `self` and `other` are unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width() + 1, other.width()))` – If `self` is unsigned and `other` is signed.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width(), other.width() + 1))` – If `self` is signed and `other` is unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(max(self.width(), other.width()))` – If both `self` and `other` are unsigned.

#### \_\_rxor_\_(other)

Bitwise XOR, `other ^ self`.

Like [`__xor__()`](#amaranth.hdl.Value.__xor__), with operands swapped.

#### xor()

Reduction XOR; are an odd amount of bits `1`?

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(1)`

#### \_\_lshift_\_(other)

Left shift by variable amount, `self << other`.

* **Returns:**
  * [`Value`](#amaranth.hdl.Value), `unsigned(len(self) + 2 ** len(other) - 1)` – If `self` is unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(len(self) + 2 ** len(other) - 1)` – If `self` is signed.
* **Raises:**
  [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `other` is signed.

#### \_\_rlshift_\_(other)

Left shift by variable amount, `other << self`.

Like [`__lshift__()`](#amaranth.hdl.Value.__lshift__), with operands swapped.

#### shift_left(amount)

Left shift by constant amount.

If `amount < 0`, performs the same operation as `self.shift_right(-amount)`.

* **Returns:**
  * [`Value`](#amaranth.hdl.Value), `unsigned(max(len(self) + amount, 0))` – If `self` is unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(max(len(self) + amount, 1))` – If `self` is signed.

#### rotate_left(amount)

Left rotate by constant amount.

If `amount < 0`, performs the same operation as `self.rotate_right(-amount)`.

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(len(self))`, [assignable](guide.md#lang-assignable)

#### \_\_rshift_\_(other)

Right shift by variable amount, `self >> other`.

* **Returns:**
  * [`Value`](#amaranth.hdl.Value), `unsigned(len(self))` – If `self` is unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(len(self))` – If `self` is signed.
* **Raises:**
  [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `other` is signed.

#### \_\_rrshift_\_(other)

Right shift by variable amount, `other >> self`.

Like [`__rshift__()`](#amaranth.hdl.Value.__rshift__), with operands swapped.

#### shift_right(amount)

Right shift by constant amount.

If `amount < 0`, performs the same operation as `self.shift_left(-amount)`.

* **Returns:**
  * [`Value`](#amaranth.hdl.Value), `unsigned(max(len(self) - amount, 0))` – If `self` is unsigned.
  * [`Value`](#amaranth.hdl.Value), `signed(max(len(self) - amount, 1))` – If `self` is signed.

#### rotate_right(amount)

Right rotate by constant amount.

If `amount < 0`, performs the same operation as `self.rotate_left(-amount)`.

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(len(self))`, [assignable](guide.md#lang-assignable)

#### \_\_len_\_()

Bit width of `self`.

* **Returns:**
  `self.shape().width`
* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

#### \_\_getitem_\_(key)

Bit slicing.

Selects a constant-width, constant-offset part of `self`. All three slicing syntaxes
(`self[i]`, `self[i:j]`, and `self[i:j:k]`) as well as negative indices are
supported. Like with other Python containers, out-of-bounds indices are trimmed to
the bounds of `self`.

To select a variable-offset part of `self`, use [`bit_select()`](#amaranth.hdl.Value.bit_select) or
[`word_select()`](#amaranth.hdl.Value.word_select) instead.

* **Returns:**
  * [`Value`](#amaranth.hdl.Value), `unsigned(1)`, [assignable](guide.md#lang-assignable) – If `key` is an [`int`](https://docs.python.org/3/library/functions.html#int).
  * [`Value`](#amaranth.hdl.Value), `unsigned(j - i)`, [assignable](guide.md#lang-assignable) – If `key` is a slice `i:j` where `i` and `j` are [`int`](https://docs.python.org/3/library/functions.html#int)s.
  * [`Value`](#amaranth.hdl.Value), `unsigned(len(range(*slice(i, j, k).indices(len(self)))))`, [assignable](guide.md#lang-assignable) – If `key` is a slice `i:j:k` where `i`, `j`, and `k` are [`int`](https://docs.python.org/3/library/functions.html#int)s.

#### \_\_contains_\_(other)

Forbidden membership test operator.

Python requires this operator to return a [`bool`](#amaranth.hdl.Value.bool). Since this is not possible
for Amaranth values, this operator always raises an exception.

To check membership in a set of constant integer values, use [`matches()`](#amaranth.hdl.Value.matches) instead.

* **Raises:**
  [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – Always.

#### bit_select(offset, width)

Part-select with bit granularity.

Selects a constant width, variable offset part of `self`, where parts with successive
offsets overlap by `width - 1` bits. Bits above the most significant bit of `self`
may be selected; they are equal to zero if `self` is unsigned, to `self[-1]` if
`self` is signed, and assigning to them does nothing.

When `offset` is a constant integer and `offset + width <= len(self)`,
this operation is equivalent to `self[offset:offset + width]`.

* **Parameters:**
  * **offset** ([value-like](guide.md#lang-valuelike)) – Index of the first selected bit.
  * **width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Amount of bits to select.
* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(width)`, [assignable](guide.md#lang-assignable)
* **Raises:**
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `offset` is signed.
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `width` is negative.

#### word_select(offset, width)

Part-select with word granularity.

Selects a constant width, variable offset part of `self`, where parts with successive
offsets are adjacent but do not overlap. Bits above the most significant bit of `self`
may be selected; they are equal to zero if `self` is unsigned, to `self[-1]` if
`self` is signed, and assigning to them does nothing.

When `offset` is a constant integer and `width:(offset + 1) * width <= len(self)`,
this operation is equivalent to `self[offset * width:(offset + 1) * width]`.

* **Parameters:**
  * **offset** ([value-like](guide.md#lang-valuelike)) – Index of the first selected word.
  * **width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Amount of bits to select.
* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(width)`, [assignable](guide.md#lang-assignable)
* **Raises:**
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `offset` is signed.
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `width` is negative.

#### replicate(count)

Replication.

Equivalent to `Cat(self for _ in range(count))`, but not assignable.

<!-- Technically assignable right now, but we don't want to commit to that. -->
* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(len(self) * count)`
* **Raises:**
  [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `count` is negative.

#### matches(\*patterns)

Pattern matching.

Matches against a set of patterns, recognizing the same grammar as `with m.Case()`.
The pattern syntax is described in the [language guide](guide.md#lang-matchop).

Each of the `patterns` may be a [`str`](https://docs.python.org/3/library/stdtypes.html#str) or a [constant-castable object](guide.md#lang-constcasting).

* **Return type:**
  [`Value`](#amaranth.hdl.Value), `unsigned(1)`
* **Raises:**
  [**SyntaxError**](https://docs.python.org/3/library/exceptions.html#SyntaxError) – If a pattern has invalid syntax.

#### eq(value, \*, src_loc_at=0)

[Assignment](guide.md#lang-assigns).

Once it is placed in a domain, an assignment changes the bit pattern of `self` to
equal `value`. If the bit width of `value` is less than that of `self`,
it is zero-extended (for unsigned `value`s) or sign-extended (for signed
`value`s). If the bit width of `value` is greater than that of `self`,
it is truncated.

* **Return type:**
  `Statement`

#### \_\_hash_\_ *= None*

Forbidden hashing.

Python objects are [hashable](https://docs.python.org/3/glossary.html#term-hashable) if they provide a `__hash__` method
that returns an [`int`](https://docs.python.org/3/library/functions.html#int) and an `__eq__` method that returns a [`bool`](#amaranth.hdl.Value.bool).
Amaranth values define [`__eq__()`](#amaranth.hdl.Value.__eq__) to return a [`Value`](#amaranth.hdl.Value), which precludes them
from being hashable.

To use a [`Value`](#amaranth.hdl.Value) as a key in a [`dict`](https://docs.python.org/3/library/stdtypes.html#dict), use the following pattern:

```python
value = Signal()
assoc = {}
assoc[id(value)] = value, "a signal"
_, info = assoc[id(value)]
assert info == "a signal"
```

#### \_\_format_\_(format_desc)

Forbidden formatting.

Since normal Python formatting (f-strings and `str.format`) must immediately return
a string, it is unsuitable for formatting Amaranth values. To format a value at simulation
time, use `Format` instead. If you really want to dump the AST at elaboration time,
use `repr` instead (for instance, via `f"{value!r}"`).

### *class* amaranth.hdl.ValueCastable

Interface class for objects that can be cast to a [`Value`](#amaranth.hdl.Value).

Computations in the Amaranth language are described by combining [value-like objects](guide.md#lang-valuelike). Inheriting a class from [`ValueCastable`](#amaranth.hdl.ValueCastable) and implementing
all of the methods described below adds instances of that class to the list of
value-like objects recognized by the [`Value.cast()`](#amaranth.hdl.Value.cast) method. This is a part of the mechanism
for seamlessly extending the Amaranth language in third-party code.

#### NOTE
All methods and operators defined by the [`Value`](#amaranth.hdl.Value) class will implicitly cast
a [`ValueCastable`](#amaranth.hdl.ValueCastable) object to a [`Value`](#amaranth.hdl.Value), with the exception of arithmetic
operators, which will prefer calling a reflected arithmetic operation on
the [`ValueCastable`](#amaranth.hdl.ValueCastable) argument if it defines one.

For example, if `value_castable` implements `__radd__`, then
`C(1) + value_castable` will perform `value_castable.__radd__(C(1))`, and otherwise
it will perform `C(1).__add__(value_castable.as_value())`.

#### as_value()

Convert `self` to a [value-like object](guide.md#lang-valuelike).

This method is called by the Amaranth language to convert `self` to a concrete
[`Value`](#amaranth.hdl.Value). It will usually return a [`Value`](#amaranth.hdl.Value) object, but it may also return
another value-like object to delegate its functionality.

This method must be idempotent: when called twice on the same object, the result must be
exactly the same.

This method may also be called by code that is not a part of the Amaranth language.

* **Return type:**
  Any other object recognized by [`Value.cast()`](#amaranth.hdl.Value.cast).
* **Raises:**
  [**Exception**](https://docs.python.org/3/library/exceptions.html#Exception) – When the conversion cannot be done. This exception must be propagated by callers,
      either directly or as a cause of another exception.
    
      It is recommended that, in cases where this method raises an exception,
      the [`shape()`](#amaranth.hdl.ValueCastable.shape) method also raises an exception.

#### shape()

Compute the shape of `self`.

This method is not called by the Amaranth language itself; whenever it needs to discover
the shape of a value-castable object, it calls `self.as_value().shape()`. However,
that method must return a [`Shape`](#amaranth.hdl.Shape), and [`ValueCastable`](#amaranth.hdl.ValueCastable) subclasses may have
a richer representation of their shape provided by an instance of a [`ShapeCastable`](#amaranth.hdl.ShapeCastable)
subclass. This method may return such a representation.

This method must be idempotent: when called twice on the same object, the result must be
exactly the same.

The following condition must hold:

```default
Shape.cast(self.shape()) == Value.cast(self).shape()
```

* **Return type:**
  A [shape-like](guide.md#lang-shapelike) object.
* **Raises:**
  [**Exception**](https://docs.python.org/3/library/exceptions.html#Exception) – When the conversion cannot be done. This exception must be propagated by callers,
      either directly or as a cause of another exception.
    
      It is recommended that, in cases where this method raises an exception,
      the [`as_value()`](#amaranth.hdl.ValueCastable.as_value) method also raises an exception.

### *class* amaranth.hdl.ValueLike

Abstract class representing all objects that can be cast to a [`Value`](#amaranth.hdl.Value).

`issubclass(cls, ValueLike)` returns `True` for:

* [`Value`](#amaranth.hdl.Value);
* [`ValueCastable`](#amaranth.hdl.ValueCastable) and its subclasses;
* [`int`](https://docs.python.org/3/library/functions.html#int) and its subclasses (including [`bool`](https://docs.python.org/3/library/functions.html#bool));
* [`enum.Enum`](https://docs.python.org/3/library/enum.html#enum.Enum) subclasses where all values are [value-like](guide.md#lang-valuelike);
* [`ValueLike`](#amaranth.hdl.ValueLike) itself.

`isinstance(obj, ValueLike)` returns the same value as
`issubclass(type(obj), ValueLike)`.

This class cannot be instantiated or subclassed. It can only be used for checking types of
objects.

#### NOTE
It is possible to define an enumeration with a member that is
[value-like](guide.md#lang-valuelike) but not [constant-castable](guide.md#lang-constcasting),
meaning that `issubclass(BadEnum, ValueLike)` returns `True`, but
`Value.cast(BadEnum.MEMBER)` raises an exception.

The [`amaranth.lib.enum`](stdlib/enum.md#module-amaranth.lib.enum) module prevents such enumerations from being defined when
the shape is specified explicitly. Using [`amaranth.lib.enum`](stdlib/enum.md#module-amaranth.lib.enum) and specifying the shape
ensures that all of your enumeration members are constant-castable and fit in the provided
shape.


# reg.html.md

# CSR registers

The [`amaranth_soc.csr.reg`](#module-amaranth_soc.csr.reg) module provides a way to define and create CSR registers and register fields.

<!-- from amaranth import *
from amaranth.lib import wiring
from amaranth.lib.wiring import In, Out, flipped, connect

from amaranth_soc import csr
from amaranth_soc.memory import * -->

## Introduction

Control and Status registers are commonly used as an interface between SoC peripherals and the firmware that operates them.

This module provides the following functionality:

1. Register field description and implementation via the [`Field`](#amaranth_soc.csr.reg.Field) and [`FieldAction`](#amaranth_soc.csr.reg.FieldAction) classes. The [`amaranth_soc.csr.action`](action.md#module-amaranth_soc.csr.action) module provides a built-in [`FieldAction`](#amaranth_soc.csr.reg.FieldAction) subclasses for common use cases. If needed, users can implement their own subclasses.
2. Composable layouts of register fields via [`FieldActionMap`](#amaranth_soc.csr.reg.FieldActionMap) and [`FieldActionArray`](#amaranth_soc.csr.reg.FieldActionArray). These classes are not meant to be instantiated directly, but are useful when introspecting the layout of a register.
3. Register definitions via the [`Register`](#amaranth_soc.csr.reg.Register) class. The fields of a register can be provided as [variable annotations](https://docs.python.org/3/glossary.html#term-variable-annotation) or as instance parameters.
4. A [`Builder`](#amaranth_soc.csr.reg.Builder) class to organize registers of a peripheral into a hierarchy of clusters and arrays, to be converted into a [`MemoryMap`](../memory.md#amaranth_soc.memory.MemoryMap).
5. A bridge between a CSR bus interface and the registers of a peripheral, via the [`Bridge`](#amaranth_soc.csr.reg.Bridge) class.

## Examples

### Defining a register declaratively

If its layout and access mode are known in advance, a register can be concisely defined using [variable annotations](https://docs.python.org/3/glossary.html#term-variable-annotation):

```python
class Status(csr.Register, access="rw"):
    rdy:    csr.Field(csr.action.R,       1)
    err:    csr.Field(csr.action.RW1C,    1)
    _unimp: csr.Field(csr.action.ResR0W0, 6)
```

#### NOTE
By convention, names of [reserved fields](action.md#csr-action-reserved) (such as `_unimp` in the above example) should begin with an underscore.

### Defining a register with instance parameters

If the layout or access mode of a register aren’t known until instantiation, a [`Register`](#amaranth_soc.csr.reg.Register) subclass can override them in `__init__`:

```python
class Data(csr.Register):
    def __init__(self, width=8, access="w"):
        super().__init__(fields={"data": csr.Field(csr.action.W, width)},
                         access=access)
```

### Defining a single-field register

In the previous example, the `Data` register has a single field named `"Data.data"`, which is redundant.

If no other fields are expected to be added in future revisions of the peripheral (or forward compatibility is not a concern), the field name can be omitted like so:

```python
class Data(csr.Register, access="w"):
    def __init__(self):
        super().__init__(csr.Field(csr.action.W, 8))
```

### Defining a register with nested fields

Hierarchical layouts of register fields can be expressed using lists and dicts:

```python
class SetClr(csr.Register, access="r"):
    pin: [{"set": csr.Field(csr.action.W, 1),
           "clr": csr.Field(csr.action.W, 1)} for _ in range(8)]
```

### Connecting registers to a CSR bus

In this example, the registers of `FooPeripheral` are added to a [`Builder`](#amaranth_soc.csr.reg.Builder) to produce a memory map, and then bridged to a bus interface:

```python
class FooPeripheral(wiring.Component):
    class Ctrl(csr.Register, access="rw"):
        enable: csr.Field(csr.action.RW, 1)
        _unimp: csr.Field(csr.action.ResR0W0, 7)

    class Data(csr.Register, access="r"):
        def __init__(self, width):
            super().__init__(csr.Field(csr.action.R, width))

    def __init__(self):
        regs = csr.Builder(addr_width=4, data_width=8)

        reg_ctrl = regs.add("Ctrl", Ctrl())
        reg_data = regs.add("Data", Data(width=32), offset=4)

        self._bridge = csr.Bridge(regs.as_memory_map())

        super().__init__({"csr_bus": In(csr.Signature(addr_width=4, data_width=8))})
        self.csr_bus.memory_map = self._bridge.bus.memory_map

    def elaborate(self, platform):
        return Module() # ...
```

### Defining a custom field action

If [`amaranth_soc.csr.action`](action.md#module-amaranth_soc.csr.action) built-ins do not cover a desired use case, a custom [`FieldAction`](#amaranth_soc.csr.reg.FieldAction) may provide an alternative.

This example shows a “read/write-0-to-set” field action:

```python
class RW0S(csr.FieldAction):
    def __init__(self, shape, init=0):
        super().__init__(shape, access="rw", members={
            "data":  Out(shape),
            "clear": In(shape),
        })
        self._storage = Signal(shape, init=init)
        self._init    = init

    @property
    def init(self):
        return self._init

    def elaborate(self, platform):
        m = Module()

        for i, storage_bit in enumerate(self._storage):
            with m.If(self.clear[i]):
                m.d.sync += storage_bit.eq(0)
            with m.If(self.port.w_stb & ~self.port.w_data[i]):
                m.d.sync += storage_bit.eq(1)

        m.d.comb += [
            self.port.r_data.eq(self._storage),
            self.data.eq(self._storage),
        ]

        return m
```

`RW0S` can then be passed to [`Field`](#amaranth_soc.csr.reg.Field):

```python
class Foo(csr.Register, access="rw"):
    mask: csr.Field(RW0S, 8)
    data: csr.Field(csr.action.RW, 8)
```

## Fields

#### *class* FieldPort.Access

Field access mode.

#### R *= 'r'*

Read-only mode.

#### W *= 'w'*

Write-only mode.

#### RW *= 'rw'*

Read/write mode.

#### NC *= 'nc'*

Not connected.

#### readable()

Readable access mode.

* **Returns:**
  `True` if equal to [`R`](#amaranth_soc.csr.reg.FieldPort.Access.R) or [`RW`](#amaranth_soc.csr.reg.FieldPort.Access.RW).
* **Return type:**
  [`bool`](https://docs.python.org/3/library/functions.html#bool)

#### writable()

Writable access mode.

* **Returns:**
  `True` if equal to [`W`](#amaranth_soc.csr.reg.FieldPort.Access.W) or [`RW`](#amaranth_soc.csr.reg.FieldPort.Access.RW).
* **Return type:**
  [`bool`](https://docs.python.org/3/library/functions.html#bool)

#### *class* FieldPort.Signature

CSR register field port signature.

* **Parameters:**
  * **shape** ([shape-like object](../../amaranth/guide.md#lang-shapelike)) – Shape of the field.
  * **access** ([`FieldPort.Access`](#amaranth_soc.csr.reg.FieldPort.Access)) – Field access mode.
* **Members:**
  * **r_data** (`In(shape)`) – Read data. Must always be valid, and is sampled when `r_stb` is asserted.
  * **r_stb** (`Out(1)`) – Read strobe. Fields with read side effects should perform them when this strobe is
    asserted.
  * **w_data** (`Out(shape)`) – Write data. Valid only when `w_stb` is asserted.
  * **w_stb** (`Out(1)`) – Write strobe. Fields should update their value or perform the write side effect when
    this strobe is asserted.

#### create(\*, path=None, src_loc_at=0)

Create a compatible interface.

See [`amaranth.lib.wiring.Signature.create()`](../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Signature.create) for details.

* **Return type:**
  [`FieldPort`](#amaranth_soc.csr.reg.FieldPort)

#### \_\_eq_\_(other)

Compare signatures.

Two signatures are equal if they have the same shape and field access mode.

### *class* amaranth_soc.csr.reg.FieldPort

CSR register field port.

An interface between a [`Register`](#amaranth_soc.csr.reg.Register) and one of its fields.

* **Parameters:**
  * **signature** ([`FieldPort.Signature`](#amaranth_soc.csr.reg.FieldPort.Signature)) – Field port signature.
  * **path** (iterable of [`str`](https://docs.python.org/3/library/stdtypes.html#str)) – Path to the field port. Optional. See [`amaranth.lib.wiring.PureInterface`](../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.PureInterface).

### *class* amaranth_soc.csr.reg.Field

Description of a CSR register field.

* **Parameters:**
  * **action_cls** (subclass of [`FieldAction`](#amaranth_soc.csr.reg.FieldAction)) – The type of field action to be instantiated by [`Field.create()`](#amaranth_soc.csr.reg.Field.create).
  * **\*args** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple)) – Positional arguments passed to `action_cls.__init__`.
  * **\*\*kwargs** ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict)) – Keyword arguments passed to `action_cls.__init__`.

#### create()

Instantiate a field action.

* **Returns:**
  The object returned by `action_cls(*args, **kwargs)`.
* **Return type:**
  [`FieldAction`](#amaranth_soc.csr.reg.FieldAction)

## Field actions

### *class* amaranth_soc.csr.reg.FieldAction

CSR register field action.

A component mediating access between a CSR bus and a range of bits within a [`Register`](#amaranth_soc.csr.reg.Register).

* **Parameters:**
  * **shape** ([shape-like object](../../amaranth/guide.md#lang-shapelike)) – Shape of the field.
  * **access** ([`FieldPort.Access`](#amaranth_soc.csr.reg.FieldPort.Access)) – Field access mode.
  * **members** (iterable of ([`str`](https://docs.python.org/3/library/stdtypes.html#str), [`amaranth.lib.wiring.Member`](../../amaranth/stdlib/wiring.md#amaranth.lib.wiring.Member)) pairs, optional) – Additional signature members.
* **Members:**
  **port** (`In(csr.reg.FieldPort.Signature(shape, access))`) – Field port.

### *class* amaranth_soc.csr.reg.FieldActionMap

A mapping of field actions.

* **Parameters:**
  **fields** ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict) of [`str`](https://docs.python.org/3/library/stdtypes.html#str) to ([`Field`](#amaranth_soc.csr.reg.Field) or [`dict`](https://docs.python.org/3/library/stdtypes.html#dict) or [`list`](https://docs.python.org/3/library/stdtypes.html#list))) – 

  Register fields. Fields are instantiated according to their type:
  > - a [`Field`](#amaranth_soc.csr.reg.Field) is instantiated as a [`FieldAction`](#amaranth_soc.csr.reg.FieldAction);
  > - a [`dict`](https://docs.python.org/3/library/stdtypes.html#dict) is instantiated as a [`FieldActionMap`](#amaranth_soc.csr.reg.FieldActionMap);
  > - a [`list`](https://docs.python.org/3/library/stdtypes.html#list) is instantiated as a [`FieldActionArray`](#amaranth_soc.csr.reg.FieldActionArray).

#### \_\_getitem_\_(key)

Access a field by name or index.

* **Returns:**
  The field instance associated with `key`.
* **Return type:**
  [`FieldAction`](#amaranth_soc.csr.reg.FieldAction) or [`FieldActionMap`](#amaranth_soc.csr.reg.FieldActionMap) or [`FieldActionArray`](#amaranth_soc.csr.reg.FieldActionArray)
* **Raises:**
  [**KeyError**](https://docs.python.org/3/library/exceptions.html#KeyError) – If there is no field instance associated with `key`.

#### \_\_getattr_\_(name)

Access a field by name.

* **Returns:**
  The field instance associated with `name`.
* **Return type:**
  [`FieldAction`](#amaranth_soc.csr.reg.FieldAction) or [`FieldActionMap`](#amaranth_soc.csr.reg.FieldActionMap) or [`FieldActionArray`](#amaranth_soc.csr.reg.FieldActionArray)
* **Raises:**
  * [**AttributeError**](https://docs.python.org/3/library/exceptions.html#AttributeError) – If the field map does not have a field instance associated with `name`.
  * [**AttributeError**](https://docs.python.org/3/library/exceptions.html#AttributeError) – If `name` is reserved (i.e. starts with an underscore).

#### \_\_iter_\_()

Iterate over the field map.

* **Yields:**
  [`str`](https://docs.python.org/3/library/stdtypes.html#str) – Key (name) for accessing the field.

#### \_\_len_\_()

Field map size.

* **Returns:**
  The number of items in the map.
* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

#### flatten()

Recursively iterate over the field map.

* **Yields:**
  * iterable of [`str`](https://docs.python.org/3/library/stdtypes.html#str) – Path of the field. It is prefixed by the name of every nested [`FieldActionMap`](#amaranth_soc.csr.reg.FieldActionMap)
    or [`FieldActionArray`](#amaranth_soc.csr.reg.FieldActionArray).
  * [`FieldAction`](#amaranth_soc.csr.reg.FieldAction) – Field instance.

### *class* amaranth_soc.csr.reg.FieldActionArray

An array of CSR register fields.

* **Parameters:**
  **fields** ([`list`](https://docs.python.org/3/library/stdtypes.html#list) of ([`Field`](#amaranth_soc.csr.reg.Field) or [`dict`](https://docs.python.org/3/library/stdtypes.html#dict) or [`list`](https://docs.python.org/3/library/stdtypes.html#list))) – 

  Register fields. Fields are instantiated according to their type:
  > - a [`Field`](#amaranth_soc.csr.reg.Field) is instantiated as a [`FieldAction`](#amaranth_soc.csr.reg.FieldAction);
  > - a [`dict`](https://docs.python.org/3/library/stdtypes.html#dict) is instantiated as a [`FieldActionMap`](#amaranth_soc.csr.reg.FieldActionMap);
  > - a [`list`](https://docs.python.org/3/library/stdtypes.html#list) is instantiated as a [`FieldActionArray`](#amaranth_soc.csr.reg.FieldActionArray).

#### \_\_getitem_\_(key)

Access a field by index.

* **Returns:**
  The field instance associated with `key`.
* **Return type:**
  [`FieldAction`](#amaranth_soc.csr.reg.FieldAction) or [`FieldActionMap`](#amaranth_soc.csr.reg.FieldActionMap) or [`FieldActionArray`](#amaranth_soc.csr.reg.FieldActionArray)

#### \_\_len_\_()

Field array size.

* **Returns:**
  The number of items in the array.
* **Return type:**
  [`int`](https://docs.python.org/3/library/functions.html#int)

#### flatten()

Recursively iterate over the field array.

* **Yields:**
  * iterable of [`str`](https://docs.python.org/3/library/stdtypes.html#str) – Path of the field. It is prefixed by the name of every nested [`FieldActionMap`](#amaranth_soc.csr.reg.FieldActionMap)
    or [`FieldActionArray`](#amaranth_soc.csr.reg.FieldActionArray).
  * [`FieldAction`](#amaranth_soc.csr.reg.FieldAction) – Field instance.

## Registers

### *class* amaranth_soc.csr.reg.Register

A CSR register.

* **Parameters:**
  * **fields** ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict) or [`list`](https://docs.python.org/3/library/stdtypes.html#list) or [`Field`](#amaranth_soc.csr.reg.Field), optional) – Collection of register fields. If omitted, a dict is populated from Python [variable
    annotations](https://docs.python.org/3/glossary.html#term-variable-annotation). `fields` is used to create
    a [`FieldActionMap`](#amaranth_soc.csr.reg.FieldActionMap), [`FieldActionArray`](#amaranth_soc.csr.reg.FieldActionArray), or [`FieldAction`](#amaranth_soc.csr.reg.FieldAction),
    depending on its type ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict), [`list`](https://docs.python.org/3/library/stdtypes.html#list), or [`Field`](#amaranth_soc.csr.reg.Field)).
  * **access** ([`Access`](bus.md#amaranth_soc.csr.bus.Element.Access)) – Element access mode.
* **Members:**
  **element** (`In(csr.Element.Signature(shape, access))`) – Interface between this [`Register`](#amaranth_soc.csr.reg.Register) and a CSR bus primitive.
* **Raises:**
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `fields` is not `None` and at least one [variable annotation](https://docs.python.org/3/glossary.html#term-variable-annotation) is a [`Field`](#amaranth_soc.csr.reg.Field).
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `element.access` is not readable and at least one field is readable.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `element.access` is not writable and at least one field is writable.

#### field

Collection of field instances.

* **Return type:**
  [`FieldActionMap`](#amaranth_soc.csr.reg.FieldActionMap) or [`FieldActionArray`](#amaranth_soc.csr.reg.FieldActionArray) or [`FieldAction`](#amaranth_soc.csr.reg.FieldAction)

#### f

Shorthand for [`Register.field`](#amaranth_soc.csr.reg.Register.field).

* **Return type:**
  [`FieldActionMap`](#amaranth_soc.csr.reg.FieldActionMap) or [`FieldActionArray`](#amaranth_soc.csr.reg.FieldActionArray) or [`FieldAction`](#amaranth_soc.csr.reg.FieldAction)

#### \_\_iter_\_()

Recursively iterate over the field collection.

* **Yields:**
  * iterable of [`str`](https://docs.python.org/3/library/stdtypes.html#str) – Path of the field. It is prefixed by the name of every nested [`FieldActionMap`](#amaranth_soc.csr.reg.FieldActionMap)
    or [`FieldActionArray`](#amaranth_soc.csr.reg.FieldActionArray).
  * [`FieldAction`](#amaranth_soc.csr.reg.FieldAction) – Field instance.

### *class* amaranth_soc.csr.reg.Builder

CSR builder.

A CSR builder collects a group of [`Register`](#amaranth_soc.csr.reg.Register)s within an address range with the goal
of producing a [`MemoryMap`](../memory.md#amaranth_soc.memory.MemoryMap) of the resulting layout.

* **Parameters:**
  * **addr_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Address width.
  * **data_width** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Data width.
  * **granularity** ([`int`](https://docs.python.org/3/library/functions.html#int), optional) – Granularity. Defaults to 8 bits.
* **Raises:**
  [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `data_width` is not a multiple of `granularity`.

#### freeze()

Freeze the builder.

Once the builder is frozen, [`Register`](#amaranth_soc.csr.reg.Register)s cannot be added anymore.

#### add(name, reg, \*, offset=None)

Add a register.

* **Parameters:**
  * **name** ([`str`](https://docs.python.org/3/library/stdtypes.html#str)) – Register name.
  * **reg** ([`Register`](#amaranth_soc.csr.reg.Register)) – Register.
  * **offset** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Register offset. Optional.
* **Returns:**
  `reg`, which is added to the builder. Its name is `name`, prefixed by the names and
  indices of any parent [`Cluster()`](#amaranth_soc.csr.reg.Builder.Cluster) and [`Index()`](#amaranth_soc.csr.reg.Builder.Index).
* **Return type:**
  [`Register`](#amaranth_soc.csr.reg.Register)
* **Raises:**
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the builder is frozen.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `reg` is already added to the builder.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `offset` is not a multiple of `self.data_width // self.granularity`.

#### Cluster(name)

Define a cluster.

* **Parameters:**
  **name** ([`str`](https://docs.python.org/3/library/stdtypes.html#str)) – Cluster name.

#### Index(index)

Define an array index.

* **Parameters:**
  **index** ([`int`](https://docs.python.org/3/library/functions.html#int)) – Array index.

#### as_memory_map()

Build a memory map.

If a register was added without an explicit `offset`, the [implicit next address](../memory.md#memory-implicit-next-address) of the memory map is used. Otherwise, the register address
is `offset * granularity // data_width`.

Registers are added to the memory map in the same order as they were added to the builder.

* **Return type:**
  [`MemoryMap`](../memory.md#amaranth_soc.memory.MemoryMap).

### *class* amaranth_soc.csr.reg.Bridge

CSR bridge.

* **Parameters:**
  **memory_map** ([`MemoryMap`](../memory.md#amaranth_soc.memory.MemoryMap)) – Memory map of [`Register`](#amaranth_soc.csr.reg.Register)s.
* **Members:**
  **bus** (`In(csr.Signature(memory_map.addr_width, memory_map.data_width))`) – CSR bus providing access to the contents of `memory_map`.
* **Raises:**
  [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `memory_map` has windows.


# siliconblue.html.md

# SiliconBlue

The [`SiliconBluePlatform`](#amaranth.vendor.SiliconBluePlatform) class provides a base platform to support Lattice (earlier SiliconBlue) iCE40 devices.

The IceStorm and iCECube2 toolchains are supported.

### *class* amaranth.vendor.SiliconBluePlatform(\*, toolchain='IceStorm')

### IceStorm toolchain

Required tools:
: * `yosys`
  * `nextpnr-ice40`
  * `icepack`

The environment is populated by running the script specified in the environment variable
`AMARANTH_ENV_ICESTORM`, if present.

Available overrides:
: * `verbose`: enables logging of informational messages to standard error.
  * `read_verilog_opts`: adds options for `read_verilog` Yosys command.
  * `synth_opts`: adds options for `synth_ice40` Yosys command.
  * `script_after_read`: inserts commands after `read_rtlil` in Yosys script.
  * `script_after_synth`: inserts commands after `synth_ice40` in Yosys script.
  * `yosys_opts`: adds extra options for `yosys`.
  * `nextpnr_opts`: adds extra options for `nextpnr-ice40`.
  * `add_pre_pack`: inserts commands at the end in pre-pack Python script.
  * `add_constraints`: inserts commands at the end in the PCF file.

Build products:
: * `{{name}}.rpt`: Yosys log.
  * `{{name}}.json`: synthesized RTL.
  * `{{name}}.tim`: nextpnr log.
  * `{{name}}.asc`: ASCII bitstream.
  * `{{name}}.bin`: binary bitstream.

### iCECube2 toolchain

This toolchain comes in two variants: `LSE-iCECube2` and `Synplify-iCECube2`.

Required tools:
: * iCECube2 toolchain
  * `tclsh`

The environment is populated by setting the necessary environment variables based on
`AMARANTH_ENV_ICECUBE2`, which must point to the root of the iCECube2 installation, and
is required.

Available overrides:
: * `verbose`: enables logging of informational messages to standard error.
  * `lse_opts`: adds options for LSE.
  * `script_after_add`: inserts commands after `add_file` in Synplify Tcl script.
  * `script_after_options`: inserts commands after `set_option` in Synplify Tcl script.
  * `add_constraints`: inserts commands in SDC file.
  * `script_after_flow`: inserts commands after `run_sbt_backend_auto` in SBT
    Tcl script.

Build products:
: * `{{name}}_lse.log` (LSE) or `{{name}}_design/{{name}}.htm` (Synplify): synthesis log.
  * `sbt/outputs/router/{{name}}_timing.rpt`: timing report.
  * `{{name}}.edf`: EDIF netlist.
  * `{{name}}.bin`: binary bitstream.


# simulation-guide.html.md

# Simulation Guide

This guide explains how to use ChipFlow’s simulation system to test your designs before committing to silicon.

## Overview

ChipFlow uses CXXRTL (C++ RTL simulation) to create fast, compiled simulations of your designs. The simulation system:

1. Converts your Amaranth design to CXXRTL C++ code
2. Automatically instantiates C++ models for your peripherals (UART, SPI flash, GPIO)
3. Compiles everything into a standalone executable
4. Runs your firmware on the simulated SoC

This allows cycle-accurate testing with real firmware, interactive debugging, and automated integration testing.

## Basic Workflow

The typical simulation workflow:

```bash
# Lock pins (required before simulation)
pdm run chipflow pin lock

# Build the simulation
pdm run chipflow sim build

# Run the simulation
pdm run chipflow sim run

# Run simulation and check against reference
pdm run chipflow sim check
```

## What Happens During Simulation

1. **Design Elaboration**

   ChipFlow elaborates your design and extracts:
   - Top-level I/O signatures (UART, GPIO, SPI, etc.)
   - Pin assignments from `pins.lock`
   - Software binaries to load (from `attach_data()`)
   - Peripheral metadata (from `SoftwareDriverSignature`)
2. **CXXRTL Code Generation**

   Amaranth converts your design to C++ using CXXRTL:
   ```text
   design.py → Fragment → RTLIL → CXXRTL C++ → sim_soc.cc
   ```
3. **Model Instantiation**

   For each interface with a `SimInterface` annotation, ChipFlow:
   - Looks up the corresponding C++ model (uart_model, spiflash_model, etc.)
   - Generates code to instantiate and wire it up
   - Configures the model based on signature parameters
4. **Main.cc Generation**

   ChipFlow generates `main.cc` that:
   - Instantiates your design (`p_sim__top`)
   - Instantiates peripheral models
   - Sets up the CXXRTL debugger agent
   - Loads software binaries into flash models
   - Runs the clock for the configured number of steps
5. **Compilation**

   Everything is compiled together using Zig as the C++ compiler:
   ```bash
   zig c++ -O3 -g -std=c++17 \\
       sim_soc.cc main.cc models.cc \\
       -o sim_soc
   ```
6. **Execution**

   The resulting `sim_soc` executable runs your design.

## SimPlatform Internals

The `SimPlatform` class is responsible for managing the simulation build process.

### Automatic Model Matching

ChipFlow includes built-in models for common peripherals:

```python
# From chipflow/platform/sim.py
_COMMON_BUILDER = BasicCxxBuilder(
    models=[
        SimModel('spi', 'chipflow::models', SPISignature),
        SimModel('spiflash', 'chipflow::models', QSPIFlashSignature, [SimModelCapability.LOAD_DATA]),
        SimModel('uart', 'chipflow::models', UARTSignature),
        SimModel('i2c', 'chipflow::models', I2CSignature),
        SimModel('gpio', 'chipflow::models', GPIOSignature),
    ],
    ...
)
```

When you use `UARTSignature()` in your design, SimPlatform automatically:

1. Extracts the `SimInterface` annotation with UID `"com.chipflow.chipflow.UARTSignature"`
2. Looks up the model in `_COMMON_BUILDER._table`
3. Generates: `chipflow::models::uart uart_0("uart_0", top.p_uart__0____tx____o, top.p_uart__0____rx____i)`

### Port Instantiation

SimPlatform creates `SimulationPort` objects for each pin in your design:

```python
# Inside SimPlatform.instantiate_ports()
for name, port_desc in interface_desc.items():
    self._ports[port_desc.port_name] = io.SimulationPort(
        port_desc.direction,
        port_desc.width,
        invert=port_desc.invert,
        name=port_desc.port_name
    )
```

These ports become the top-level I/O of your simulated design.

### Clock and Reset Handling

Clocks and resets receive special treatment:

- **Clocks**: Connected to Amaranth `ClockDomain`
- **Resets**: Synchronized with `FFSynchronizer` for proper reset behavior

```python
# Clock domain creation
setattr(m.domains, domain, ClockDomain(name=domain))
clk_buffer = io.Buffer(clock.direction, self._ports[clock.port_name])
m.d.comb += ClockSignal().eq(clk_buffer.i)

# Reset synchronization
rst_buffer = io.Buffer(reset.direction, self._ports[reset.port_name])
ffsync = FFSynchronizer(rst_buffer.i, ResetSignal())
```

### Generated main.cc

The generated `main.cc` follows this structure:

```cpp
#include <cxxrtl/cxxrtl.h>
#include <cxxrtl/cxxrtl_server.h>
#include "sim_soc.h"
#include "models.h"

int main(int argc, char **argv) {
    // Instantiate design
    p_sim__top top;

    // Instantiate peripheral models
    chipflow::models::spiflash flash("flash", top.p_flash____clk____o, ...);
    chipflow::models::uart uart_0("uart_0", top.p_uart__0____tx____o, ...);
    chipflow::models::gpio gpio_0("gpio_0", top.p_gpio__0____gpio____o, ...);

    // Set up debugger
    cxxrtl::agent agent(cxxrtl::spool("spool.bin"), top);
    if (getenv("DEBUG"))
        std::cerr << "Waiting for debugger on " << agent.start_debugging() << std::endl;

    // Set up event logging
    open_event_log("events.json");

    // Clock tick function
    auto tick = [&]() {
        flash.step(timestamp);
        uart_0.step(timestamp);
        gpio_0.step(timestamp);

        top.p_clk.set(false);
        agent.step();
        agent.advance(1_us);
        ++timestamp;

        top.p_clk.set(true);
        agent.step();
        agent.advance(1_us);
        ++timestamp;
    };

    // Load software
    flash.load_data("../software/software.bin", 0x00100000U);

    // Reset sequence
    top.p_rst.set(true);
    tick();
    top.p_rst.set(false);

    // Run simulation
    for (int i = 0; i < num_steps; i++)
        tick();

    close_event_log();
    return 0;
}
```

## Configuration

### chipflow.toml Settings

```toml
[chipflow.simulation]
# Number of clock cycles to simulate (default: 3000000)
num_steps = 3000000

[chipflow.test]
# Reference event log for integration testing
event_reference = "design/tests/events_reference.json"
```

## Simulation Commands

### chipflow sim build

Builds the simulation executable:

1. Elaborates the design
2. Generates CXXRTL C++
3. Generates main.cc
4. Compiles to `build/sim/sim_soc`

### chipflow sim run

Runs the simulation:

1. Builds software (if needed)
2. Builds simulation (if needed)
3. Executes `build/sim/sim_soc`

Output appears in the terminal, and `events.json` is written to `build/sim/`.

### chipflow sim check

Runs simulation and validates output:

1. Runs `chipflow sim run`
2. Compares `build/sim/events.json` against reference
3. Reports pass/fail

Useful for regression testing in CI/CD.

## Debugging with RTL Debugger

ChipFlow simulations integrate with the [RTL Debugger](https://github.com/amaranth-lang/rtl-debugger) VS Code extension.

### Enable Debugging

```bash
DEBUG=1 pdm run chipflow sim run
```

This starts the CXXRTL debug server and prints:

```text
Waiting for debugger on localhost:37268
```

<!-- Attach Debugger
~~~~~~~~~~~~~~~

1. Install the RTL Debugger extension in VS Code
2. Open the command palette (Cmd+Shift+P / Ctrl+Shift+P)
3. Run "RTL Debugger: Connect to CXXRTL Server"
4. Enter the host:port from the simulation output

You can now:

- View signal values in real-time
- Set breakpoints on signal conditions
- Step through clock cycles
- Inspect design hierarchy -->

## Event Logging for Testing

Peripheral models can log events to `events.json` for automated testing.

### Logging Events

UART model automatically logs received characters:

```json
[
  {"type": "uart_rx", "data": "H", "timestamp": 1234},
  {"type": "uart_rx", "data": "e", "timestamp": 1256},
  {"type": "uart_rx", "data": "l", "timestamp": 1278},
  {"type": "uart_rx", "data": "l", "timestamp": 1300},
  {"type": "uart_rx", "data": "o", "timestamp": 1322}
]
```

### Creating Reference

1. Run simulation and capture good output:
   ```bash
   pdm run chipflow sim run
   cp build/sim/events.json design/tests/events_reference.json
   ```
2. Configure in `chipflow.toml`:
   ```toml
   [chipflow.test]
   event_reference = "design/tests/events_reference.json"
   ```
3. Use in testing:
   ```bash
   pdm run chipflow sim check
   ```

### Input Commands (Optional)

You can provide input commands via `design/tests/input.json`. To reduce test churn from timing changes, input files use output events as triggers rather than timestamps:

```json
{
  "commands": [
    {"type": "action", "peripheral": "uart_0", "event": "tx", "payload": 72},
    {"type": "wait", "peripheral": "uart_0", "event": "tx", "payload": 62},
    {"type": "action", "peripheral": "uart_0", "event": "tx", "payload": 10}
  ]
}
```

Commands are processed sequentially:

- `action` commands queue an action (like transmitting data) for a peripheral
- `wait` commands pause execution until the specified event occurs

See the [mcu_soc example](https://github.com/ChipFlow/chipflow-examples/blob/main/mcu_soc/design/tests/input.json) for a working input.json file.

## Customizing Simulation

### Adding Custom Models

ChipFlow’s built-in simulation models cover common peripherals (UART, SPI, I2C, GPIO, QSPI Flash). For custom peripherals, you’ll need to write C++ models that interact with the CXXRTL-generated design.

#### WARNING
The custom simulation model interface is subject to change. Model APIs may be updated in future ChipFlow releases. Built-in models (UART, SPI, etc.) are stable, but custom model registration and integration mechanisms may evolve.

**Learning Resources:**

1. **Study existing models**: The best way to learn is to examine ChipFlow’s built-in implementations:
   - `chipflow/common/sim/models.h` - Model interfaces and helper functions
   - `chipflow/common/sim/models.cc` - Complete implementations for:
     - `uart` - UART transceiver with baud rate control
     - `spiflash` - QSPI flash memory with command processing
     - `spi` - Generic SPI peripheral
     - `i2c` - I2C bus controller with start/stop detection
2. **CXXRTL Runtime API**: Models interact with the generated design using CXXRTL’s API:
   - [CXXRTL Documentation](https://yosyshq.readthedocs.io/projects/yosys/en/latest/cmd/write_cxxrtl.html) - Command reference
   - CXXRTL runtime source: `yosys/backends/cxxrtl/runtime/` (in Yosys repository)
   - Key types: `cxxrtl::value<WIDTH>` for signal access, `.get()` to read, `.set()` to write

**Model Registration:**

Once you’ve written a model (e.g., `design/sim/my_model.h`), register it with ChipFlow:

```python
from chipflow.platform import SimPlatform, SimModel, BasicCxxBuilder
from pathlib import Path

MY_BUILDER = BasicCxxBuilder(
    models=[
        SimModel('my_peripheral', 'my_design', MyPeripheralSignature),
    ],
    hpp_files=[Path('design/sim/my_model.h')],
)

class MySimStep(SimStep):
    def __init__(self, config):
        super().__init__(config)
        self.platform._builders.append(MY_BUILDER)
```

Then reference your custom step in `chipflow.toml`:

```toml
[chipflow.steps]
sim = "my_design.steps.sim:MySimStep"
```

#### NOTE
Comprehensive CXXRTL runtime documentation is planned for a future release. For now, refer to existing model implementations and the Yosys CXXRTL source code.

## Performance Tips

1. **Reduce sim cycles**: Lower `num_steps` during development
   ```toml
   [chipflow.simulation]
   num_steps = 100000  # Instead of 3000000
   ```
2. **Use Release builds**: Already enabled by default (`-O3`)
3. **Disable debug server**: Don’t set `DEBUG=1` unless actively debugging
4. **Profile your design**: Use the RTL Debugger to find bottlenecks in your HDL

## Common Issues

### Incomplete Simulation Output

**Symptom**: Simulation completes but expected operations are incomplete

**Note**: The simulation will always stop after `num_steps` clock cycles, regardless of what the design or software is doing. If your firmware hasn’t completed by then, you’ll see incomplete output.

**Causes**:
- `num_steps` too low for the operations being performed
- Firmware stuck in infinite loop
- Waiting for peripheral that never responds

**Solutions**:
- Increase `num_steps` in chipflow.toml if legitimate operations need more time
- Enable `DEBUG=1` and attach debugger to see where execution is stuck
- Add timeout checks in your firmware to detect hangs
- Use event logging to see how far the simulation progressed

### No UART Output

**Symptom**: Expected UART output doesn’t appear

**Causes**:
- UART baud rate misconfigured
- UART peripheral not initialized
- Software not running

**Solutions**:
- Check `init_divisor` matches clock frequency
- Verify UART initialization in firmware
- Check that flash model loaded software correctly

### Model Not Found

**Symptom**: `Unable to find a simulation model for 'com.chipflow.chipflow.XXX'`

**Causes**:
- Using a signature without a corresponding model
- Custom signature not registered in a builder

**Solutions**:
- Use built-in signatures (UART, GPIO, SPI, I2C, QSPIFlash)
- Or create a custom model and register it with a `BasicCxxBuilder`

## Example: Complete Simulation Setup

Here’s a complete example showing simulation setup for a simple SoC:

### Design (design/design.py)

```python
from amaranth import Module
from amaranth.lib.wiring import Component, Out, connect, flipped
from amaranth_soc import csr

from chipflow_digital_ip.io import UARTPeripheral, GPIOPeripheral
from chipflow_digital_ip.memory import QSPIFlash
from chipflow.platform import (
    UARTSignature, GPIOSignature, QSPIFlashSignature,
    attach_data, SoftwareBuild
)

class MySoC(Component):
    def __init__(self):
        super().__init__({
            "flash": Out(QSPIFlashSignature()),
            "uart": Out(UARTSignature()),
            "gpio": Out(GPIOSignature(pin_count=4)),
        })
        self.bios_offset = 0x100000

    def elaborate(self, platform):
        m = Module()

        # CSR decoder
        csr_decoder = csr.Decoder(addr_width=28, data_width=8)
        m.submodules.csr_decoder = csr_decoder

        # Flash
        m.submodules.flash = flash = QSPIFlash()
        csr_decoder.add(flash.csr_bus, name="flash", addr=0x00000000)
        connect(m, flipped(self.flash), flash.pins)

        # UART
        m.submodules.uart = uart = UARTPeripheral(init_divisor=217)
        csr_decoder.add(uart.bus, name="uart", addr=0x02000000)
        connect(m, flipped(self.uart), uart.pins)

        # GPIO
        m.submodules.gpio = gpio = GPIOPeripheral(pin_count=4)
        csr_decoder.add(gpio.bus, name="gpio", addr=0x01000000)
        connect(m, flipped(self.gpio), gpio.pins)

        # Attach software
        from pathlib import Path
        sw = SoftwareBuild(
            sources=Path('design/software').glob('*.c'),
            offset=self.bios_offset
        )
        attach_data(self.flash, flash, sw)

        return m
```

### Configuration (chipflow.toml)

```toml
[chipflow]
project_name = "my_soc"
clock_domains = ["sync"]

[chipflow.top]
soc = "design.design:MySoC"

[chipflow.silicon]
process = "sky130"
package = "pga144"

[chipflow.simulation]
num_steps = 1000000

[chipflow.test]
event_reference = "design/tests/events_reference.json"
```

### Firmware (design/software/main.c)

```c
#include "soc.h"

int main() {
    // UART is auto-initialized by attach_data

    // Print test message
    puts("Hello from ChipFlow simulation!");

    // Blink GPIO
    for (int i = 0; i < 10; i++) {
        UART->gpio_data = i & 0xF;
    }

    return 0;
}
```

### Running

```bash
# Lock pins
pdm run chipflow pin lock

# Run simulation
pdm run chipflow sim run
```

Expected output:

```text
Building simulation...
Building software...
🐱: nyaa~!
Hello from ChipFlow simulation!
```

## See Also

- architecture - Overall ChipFlow architecture
- using-pin-signatures - Pin signature usage guide
- chipflow-commands - CLI command reference
- [RTL Debugger](https://github.com/amaranth-lang/rtl-debugger) - Interactive debugging
- [CXXRTL Documentation](https://yosyshq.readthedocs.io/projects/yosys/en/latest/cmd/write_cxxrtl.html)


# simulator.html.md

# Simulator

The [`amaranth.sim`](#module-amaranth.sim) module, also known as the simulator, makes it possible to evaluate a design’s functionality in a virtual environment before it is implemented in hardware.

## Simulating circuits

<!-- from amaranth import * -->

The following examples simulate one of the two designs below: synchronous counter running in the `sync` clock domain, and combinational adder. They assume familiarity with the language guide <guide>.

```python
from amaranth.lib import wiring
from amaranth.lib.wiring import In, Out

class Counter(wiring.Component):
    en: In(1, init=1)
    count: Out(4)

    def elaborate(self, platform):
        m = Module()
        with m.If(self.en):
            m.d.sync += self.count.eq(self.count + 1)
        return m

class Adder(wiring.Component):
    a: In(16)
    b: In(16)
    o: Out(17)

    def elaborate(self, platform):
        m = Module()
        m.d.comb += self.o.eq(self.a + self.b)
        return m
```

### Running a simulation

Simulating a design always requires the three basic steps: constructing the , constructing a [`Simulator`](#amaranth.sim.Simulator) for it, and running the simulation with the [`Simulator.run()`](#amaranth.sim.Simulator.run) or [`Simulator.run_until()`](#amaranth.sim.Simulator.run_until) method:

```python
from amaranth.sim import Simulator

dut = Counter()
sim = Simulator(dut)
sim.run()
```

However, the code above neither stimulates the DUT’s inputs nor measures the DUT’s outputs; the [`Simulator.run()`](#amaranth.sim.Simulator.run) method also immediately returns if no stimulus is added to the simulation. To make it useful, several changes are necessary:

* The [`Simulator.add_clock()`](#amaranth.sim.Simulator.add_clock) method adds a *stimulus*: a process external to the DUT that manipulates its inputs (in this case, toggles the clock of the `sync` domain).
* The [`Simulator.run_until()`](#amaranth.sim.Simulator.run_until) method runs the simulation until a specific deadline is reached.
* The [`Simulator.write_vcd()`](#amaranth.sim.Simulator.write_vcd) method captures the DUT’s inputs, state, and outputs, and writes it to a  file.

The following code simulates a design and capture the values of all the signals used in the design for each moment of simulation time:

```python
dut = Counter()
sim = Simulator(dut)
sim.add_clock(1e-6) # 1 µs period, or 1 MHz
with sim.write_vcd("example1.vcd"):
    sim.run_until(1e-6 * 15) # 15 periods of the clock
```

The captured data is saved to a  file `example1.vcd`, which can be displayed with a *waveform viewer* such as [Surfer](https://surfer-project.org/) or [GTKWave](https://gtkwave.sourceforge.net/):

The [`Simulator.reset()`](#amaranth.sim.Simulator.reset) method reverts the simulation to its initial state. It can be used to speed up tests by capturing the waveforms only when the simulation is known to encounter an error:

```python
try:
    sim.run()
except:
    sim.reset()
    with sim.write_vcd("example1_error.vcd"):
        sim.run()
```

### Testing synchronous circuits

To verify that the DUT works as intended during a simulation, known values are provided as the inputs, and the outputs are compared with the expected results.

This is done by adding a different type of stimulus to the simulator, a *testbench*: an `async` Python function that runs concurrently with the DUT and can manipulate the signals used in the simulation. A testbench is added using the [`Simulator.add_testbench()`](#amaranth.sim.Simulator.add_testbench) method, and receives a [`SimulatorContext`](#amaranth.sim.SimulatorContext) object through which it can interact with the simulator: inspect the value of signals using the [`ctx.get()`](#amaranth.sim.SimulatorContext.get) method, change the value of signals using the [`ctx.set()`](#amaranth.sim.SimulatorContext.set) method, or wait for an active edge of a [clock domain](guide.md#lang-clockdomains) using the [`ctx.tick()`](#amaranth.sim.SimulatorContext.tick) method.

The following example simulates a counter and verifies that it can be stopped using its `en` input:

```python
dut = Counter()

async def testbench_example2(ctx):
    await ctx.tick().repeat(5)     # wait until after the 5th edge of the `sync` domain clock
    assert ctx.get(dut.count) == 5 # verify that the counter has the expected value
    ctx.set(dut.en, False)         # deassert `dut.en`, disabling the counter
    await ctx.tick().repeat(5)     # wait until after the 10th edge of clock
    assert ctx.get(dut.count) == 5 # verify that the counter has not been incrementing
    ctx.set(dut.en, True)          # assert `dut.en`, enabling the counter again

sim = Simulator(dut)
sim.add_clock(1e-6)
sim.add_testbench(testbench_example2) # add the testbench; run_until() calls the function
with sim.write_vcd("example2.vcd"):
    sim.run_until(1e-6 * 15)
```

Since this circuit is synchronous, and the [`ctx.tick()`](#amaranth.sim.SimulatorContext.tick) method waits until after the circuit has reacted to the clock edge, the change to the `en` input affects the behavior of the circuit on the next clock cycle after the change:

### Testing combinational circuits

A testbench that tests a combinational circuit advances simulation time using the [`ctx.delay()`](#amaranth.sim.SimulatorContext.delay) method instead of the [`ctx.tick()`](#amaranth.sim.SimulatorContext.tick) method, since the simulation does not contain a clock in this case. The [`Simulator.run()`](#amaranth.sim.Simulator.run) method stops the simulation and returns once all testbenches finish executing.

The following example simulates an adder:

```python
dut = Adder()

async def testbench_example3(ctx):
    await ctx.delay(1e-6)
    ctx.set(dut.a, 2)
    ctx.set(dut.b, 2)
    assert ctx.get(dut.o) == 4

    await ctx.delay(1e-6)
    ctx.set(dut.a, 1717)
    ctx.set(dut.b, 420)
    assert ctx.get(dut.o) == 2137

    await ctx.delay(2e-6)

sim = Simulator(dut)
sim.add_testbench(testbench_example3)
with sim.write_vcd("example3.vcd"):
    sim.run()
```

Since this circuit is entirely combinational, and the Amaranth simulator uses a *zero-delay model* of combinational circuits, the outputs change in the same instant as the inputs do:

## Replacing circuits with code

#### NOTE
This section describes an advanced technique that is not commonly used. If you are first learning how to use the simulator, you can skip it.

During simulation, it is possible to replace an Amaranth circuit with the equivalent Python code. This can be used to improve simulation performance, or to avoid reimplementing complex Python algorithms in Amaranth if they do not need to be synthesized.

This is done by adding a *process* to the simulator: an `async` Python function that runs as an integral part of the simulation, simultaneously with the DUT. A process is added using the [`Simulator.add_process()`](#amaranth.sim.Simulator.add_process) method, and receives a [`SimulatorContext`](#amaranth.sim.SimulatorContext) object through which it can interact with the simulator. A process is conceptually similar to a testbench but differs from it in two important ways:

* Testbenches run in a well-defined order (from first to last in the order they were added, yielding control only at `await` points) and cannot observe inconsistent intermediate states of a design, but processes run in an undefined order while the design is converging after a change to its inputs.
* In a process, it is not possible to inspect the value of a signal using the [`ctx.get()`](#amaranth.sim.SimulatorContext.get) method, which guarantees that inconsistent intermediate states of a design cannot be observed by a process either.

A process communicates with the rest of the design in the same way an elaboratable would: through `Signal`s.

### Replacing synchronous circuits

Processes cannot inspect values of signals using the [`ctx.get()`](#amaranth.sim.SimulatorContext.get) method. Instead, values of signals in a synchronous process are sampled at each active edge of the clock domain (or, for domains with asynchronous reset, at the assertion of the reset signal) using the [`ctx.tick()`](#amaranth.sim.SimulatorContext.tick) method.

The following code replaces the `Counter` elaboratable with the equivalent Python code in a process, and uses a testbench to verify its correct operation:

```python
m = Module()
m.domains.sync = cd_sync = ClockDomain()
en = Signal(init=1)
count = Signal(4)

async def process_example4(ctx):
    count_value = 0 # initialize counter to 0
    async for clk_edge, rst_value, en_value in ctx.tick().sample(en):
        if rst_value: # can be asserted with or without clk_edge
            count_value = 0 # re-initialize counter
        elif clk_edge and en_value:
            count_value += 1 # advance the counter
            ctx.set(count, count_value) # publish its value to the simulation

async def testbench_example4(ctx):
    await ctx.tick().repeat(5)
    assert ctx.get(count) == 5
    ctx.set(en, False)
    await ctx.tick().repeat(5)
    assert ctx.get(count) == 5
    ctx.set(en, True)

sim = Simulator(m)
sim.add_clock(1e-6)
sim.add_process(process_example4)
sim.add_testbench(testbench_example4)
with sim.write_vcd("example4.vcd", traces=(cd_sync.clk, cd_sync.rst, en, count)):
    sim.run()
```

Unless it is instructed otherwise, the [`Simulator.write_vcd()`](#amaranth.sim.Simulator.write_vcd) method only captures values of signals that appear in the circuit provided to the simulator when it is created. The `en` and `count` signals do not, and are added explicitly using the `traces` argument so that they will appear in the VCD file.

### Replacing combinational circuits

Values of signals in a combinational process are sampled anytime they change using the [`ctx.changed()`](#amaranth.sim.SimulatorContext.changed) method.

The following code replaces the `Adder` elaboratable with the equivalent Python code in a process, and uses a testbench to verify its correct operation:

```python
m = Module()
a = Signal(16)
b = Signal(16)
o = Signal(17)

async def process_example5(ctx):
    async for a_value, b_value in ctx.changed(a, b):
        ctx.set(o, a_value + b_value)

async def testbench_example5(ctx):
    await ctx.delay(1e-6)
    ctx.set(a, 2)
    ctx.set(b, 2)
    assert ctx.get(o) == 4

    await ctx.delay(1e-6)
    ctx.set(a, 1717)
    ctx.set(b, 420)
    assert ctx.get(o) == 2137

    await ctx.delay(2e-6)

sim = Simulator(m)
sim.add_process(process_example5)
sim.add_testbench(testbench_example5)
with sim.write_vcd("example5.vcd", traces=[a, b, o]):
    sim.run()
```

## Reference

### *class* amaranth.sim.Simulator(toplevel)

Simulator for Amaranth designs.

The simulator accepts a *top-level design* (an [elaboratable](guide.md#lang-elaboration)),
*processes* that replace circuits with behavioral code, *clocks* that drive clock domains, and
*testbenches* that exercise the circuits and verify that they work correctly.

The simulator lifecycle consists of four stages:

1. The simulator is created:
   ```default
   sim = Simulator(design)
   ```
2. Processes, clocks, and testbenches are added as necessary:
   ```default
   sim.add_clock(1e-6)
   sim.add_clock(1e-7, domain="fast")
   sim.add_process(process_instr_decoder)
   sim.add_testbench(testbench_cpu_execute)
   ```
3. The simulation is run:
   ```default
   with sim.write_vcd("waveform.vcd"):
       sim.run()
   ```
4. (Optional) The simulator is reset:
   ```default
   sim.reset()
   ```

After the simulator is reset, it may be reused to run the simulation again.

#### NOTE
Resetting the simulator can also be used to amortize the startup cost of repeatedly
simulating a large design.

* **Parameters:**
  **toplevel** (`Elaboratable`) – Simulated design.

#### add_clock(period, \*, phase=None, domain='sync', if_exists=False)

Add a clock to the simulation.

Adds a stimulus that toggles the clock signal of `domain` at a 50% duty cycle.

The driven clock signal will toggle every half-`period` seconds starting at `phase`
seconds after the beginning of the simulation; if not specified, `phase` defaults to
half-`period` to avoid coinciding the first active edge with the beginning of
the simulation.

The clock domain to drive is selected by the `domain` argument, which may be
a `ClockDomain` object or a [`str`](https://docs.python.org/3/library/stdtypes.html#str). If it is a string,
the clock domain with that name is retrieved from the `toplevel` elaboratable.

* **Raises:**
  * [**NameError**](https://docs.python.org/3/library/exceptions.html#NameError) – If `domain` is a [`str`](https://docs.python.org/3/library/stdtypes.html#str), the `toplevel` elaboratable does not have
        a clock domain with that name, and `if_exists` is `False`.
  * **DriverConflict** – If `domain` already has a clock driving it.
  * [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError) – If the simulation has been advanced since its creation or last reset.

#### add_testbench(constructor, \*, background=False)

Add a testbench to the simulation.

Adds a testbench that runs concurrently with the `toplevel` elaboratable and is able to
manipulate its inputs, outputs, and state.

The behavior of the testbench is defined by its *constructor function*, which is
an `async` function that takes a single argument, the [`SimulatorContext`](#amaranth.sim.SimulatorContext):

```default
async def testbench(ctx):
    ...
    await ctx.tick()
    ...

sim.add_testbench(testbench)
```

This method does not accept coroutines. Rather, the provided `constructor` coroutine
function is called immediately when the testbench is added to create a coroutine, as well as
by the [`reset()`](#amaranth.sim.Simulator.reset) method.

The testbench can be *critical* (the default) or *background* (if the `background=True`
argument is specified). The [`run()`](#amaranth.sim.Simulator.run) method will continue advancing the simulation while
any critical testbenches or processes are running, and will exit when only background
testbenches or processes remain. A background testbench can temporarily become critical
using the [`critical()`](#amaranth.sim.SimulatorContext.critical) context manager.

At each point in time, all of the non-waiting testbenches are executed in the order in
which they were added. If two testbenches share state, or must manipulate the design in
a coordinated way, they may rely on this execution order for correctness.

* **Raises:**
  [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError) – If the simulation has been advanced since its creation or last reset.

#### add_process(process)

Add a process to the simulation.

Adds a process that is evaluated as a part of the `toplevel` elaboratable and is able to
replace circuits with Python code.

The behavior of the process is defined by its *constructor function*, which is
an `async` function that takes a single argument, the [`SimulatorContext`](#amaranth.sim.SimulatorContext):

```default
async def process(ctx):
    async for clk_edge, rst, ... in ctx.tick().sample(...):
        ...

sim.add_process(process)
```

This method does not accept coroutines. Rather, the provided `constructor` coroutine
function is called immediately when the procss is added to create a coroutine, as well as
by the [`reset()`](#amaranth.sim.Simulator.reset) method.

Processes can be *critical* or *background*, and are always background when added.
The [`run()`](#amaranth.sim.Simulator.run) method will continue advancing the simulation while any critical testbenches
or processes are running, and will exit when only background testbenches or processes
remain. A background process can temporarily become critical using
the [`critical()`](#amaranth.sim.SimulatorContext.critical) context manager.

At each point in time, all of the non-waiting processes are executed in an arbitrary order
that may be different between individual simulation runs.

#### WARNING
If two processes share state, they must do so in a way that does not rely on
a particular order of execution for correctness.

Preferably, the shared state would be stored in `Signal`s (even
if it is not intended to be a part of a circuit), with access to it synchronized using
`await ctx.tick().sample(...)`. Such state is visible in a waveform viewer,
simplifying debugging.

* **Raises:**
  [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError) – If the simulation has been advanced since its creation or last reset.

#### run()

Run the simulation indefinitely.

This method advances the simulation while any critical testbenches or processes continue
executing. It is equivalent to:

```default
while self.advance():
    pass
```

#### run_until(deadline)

Run the simulation until a specific point in time.

This method advances the simulation until the simulation time reaches `deadline`,
without regard for whether there are critical testbenches or processes executing.

<!-- This should show the code like in :meth:`run` once the code is not horrible. -->

#### advance()

Advance the simulation.

This method advances the simulation by one time step. After this method completes, all of
the events scheduled for the current point in time will have taken effect, and the current
point in time was advanced to the closest point in the future for which any events are
scheduled (which may be the same point in time).

The non-waiting testbenches are executed in the order they were added, and the processes
are executed as necessary.

Returns `True` if the simulation contains any critical testbenches or processes, and
`False` otherwise.

#### write_vcd(vcd_file, gtkw_file=None, \*, traces=())

Capture waveforms to a file.

This context manager captures waveforms for each signal and memory that is referenced from
`toplevel`, as well as any additional signals or memories specified in `traces`,
and saves them to `vcd_file`. If `gtkw_file` is provided, it is populated with
a GTKWave save file displaying `traces` when opened.

Use this context manager to wrap a call to [`run()`](#amaranth.sim.Simulator.run) or [`run_until()`](#amaranth.sim.Simulator.run_until):

```default
with sim.write_vcd("simulation.vcd"):
    sim.run()
```

The `vcd_file` and `gtkw_file` arguments accept either a [file object](https://docs.python.org/3/glossary.html#term-file-object)
or a filename. If a file object is provided, it is closed when exiting the context manager
(once the simulation completes or encounters an error).

The `traces` argument accepts a *trace specification*, which can be one of:

* A [`ValueLike`](reference.md#amaranth.hdl.ValueLike) object, such as a `Signal`;
* A [`MemoryData`](stdlib/memory.md#amaranth.hdl.MemoryData) object or an individual row retrieved from one;
* A [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) or [`list`](https://docs.python.org/3/library/stdtypes.html#list) containing trace specifications;
* A [`dict`](https://docs.python.org/3/library/stdtypes.html#dict) associating [`str`](https://docs.python.org/3/library/stdtypes.html#str) names to trace specifications;
* An [interface object](stdlib/wiring.md#wiring).

* **Raises:**
  [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If a trace specification refers to a signal with a private name.

#### reset()

Reset the simulation.

This method reverts the simulation to its initial state:

* The value of each signal is changed to its initial value;
* The contents of each memory is changed to its initial contents;
* Each clock, testbench, and process is restarted.

### *class* amaranth.sim.SimulatorContext(...)

Simulator context.

Simulator processes and testbenches are `async` Python functions that interact with
the simulation using the only argument they receive: the *context*. Using a context, it is
possible to sample or update signals and wait for events to occur in the simulation.

The context has two kinds of methods: `async` methods and non-`async` methods. Calling
an `async` method may cause the caller to be preempted (be paused such that the simulation
time can advance), while calling non-`async` methods never causes that.

#### NOTE
While a testbench or process is executing without calling `async` methods, no other
testbench or process will run, with one exception: if a testbench calls [`set()`](#amaranth.sim.SimulatorContext.set), all
processes that wait (directly or indirectly) for the updated signals to change will execute
before the call returns.

* **Parameters:**
  * **engine** (*BaseEngine*)
  * **process** (*BaseProcess*)

#### get(expr: [Value](reference.md#amaranth.hdl.Value)) → [int](https://docs.python.org/3/library/functions.html#int)

#### get(expr: [ValueCastable](reference.md#amaranth.hdl.ValueCastable)) → [Any](https://docs.python.org/3/library/typing.html#typing.Any)

Sample the value of an expression.

The behavior of this method depends on the type of `expr`:

- If it is a [`ValueCastable`](reference.md#amaranth.hdl.ValueCastable) whose shape is a [`ShapeCastable`](reference.md#amaranth.hdl.ShapeCastable),
  its numeric value is converted to a higher-level representation using
  [`from_bits()`](reference.md#amaranth.hdl.ShapeCastable.from_bits) and then returned.
- If it is a [`Value`](reference.md#amaranth.hdl.Value) or a [`ValueCastable`](reference.md#amaranth.hdl.ValueCastable) whose shape is
  a [`Shape`](reference.md#amaranth.hdl.Shape), the numeric value is returned as an [`int`](https://docs.python.org/3/library/functions.html#int).

This method is only available in testbenches.

* **Raises:**
  [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If the caller is a process.

#### set(expr: [Value](reference.md#amaranth.hdl.Value), value: [int](https://docs.python.org/3/library/functions.html#int)) → [None](https://docs.python.org/3/library/constants.html#None)

#### set(expr: [ValueCastable](reference.md#amaranth.hdl.ValueCastable), value: [Any](https://docs.python.org/3/library/typing.html#typing.Any)) → [None](https://docs.python.org/3/library/constants.html#None)

Update the value of an expression.

The behavior of this method depends on the type of `expr`:

- If it is a [`ValueCastable`](reference.md#amaranth.hdl.ValueCastable) whose shape is a [`ShapeCastable`](reference.md#amaranth.hdl.ShapeCastable),
  `value` is converted to a numeric representation using
  [`const()`](reference.md#amaranth.hdl.ShapeCastable.const) and then assigned.
- If it is a [`Value`](reference.md#amaranth.hdl.Value) or a [`ValueCastable`](reference.md#amaranth.hdl.ValueCastable) whose shape is
  a [`Shape`](reference.md#amaranth.hdl.Shape), `value` is assigned as-is.

This method is available in both processes and testbenches.

When used in a testbench, this method runs all processes that wait (directly or
indirectly) for the signals in `expr` to change, and returns only after the change
propagates through the simulated circuits.

#### critical()

Context manager that temporarily makes the caller critical.

Testbenches and processes may be *background* or *critical*, where critical ones prevent
[`Simulator.run()`](#amaranth.sim.Simulator.run) from finishing. Processes are always created background, while
testbenches are created critical by default, but may also be created background.
This context manager makes the caller critical for the span of the `with` statement.

This may be useful in cases where an operation (for example, a bus transaction) takes
multiple clock cycles to complete, and must be completed after starting, but the testbench
or process performing it never finishes, always waiting for the next operation to arrive.
In this case, the caller would elevate itself to become critical only for the duration of
the operation itself using this context manager, for example:

```default
async def testbench_bus_transaction(ctx):
    # On every cycle, check whether the bus has an active transaction...
    async for clk_edge, rst_active, bus_active_value in ctx.tick().sample(bus.active):
        if bus_active_value: # ... if it does...
            with ctx.critical(): # ... make this testbench critical...
                addr_value = ctx.get(bus.r_addr)
                ctx.set(bus.r_data, ...) # ... perform the access...
                await ctx.tick()
                ctx.set(bus.done, 1)
                await ctx.tick()
                ctx.set(bus.done, 0) # ... and complete the transaction later.
            # The `run()` method could return at this point, but not before.
```

#### tick(domain: [str](https://docs.python.org/3/library/stdtypes.html#str), \*, context: Elaboratable = None) → [TickTrigger](#amaranth.sim.TickTrigger)

#### tick(domain: ClockDomain) → [TickTrigger](#amaranth.sim.TickTrigger)

Wait until an active clock edge or an asynchronous reset occurs.

This method returns a [`TickTrigger`](#amaranth.sim.TickTrigger) object that, when awaited, pauses the execution
of the calling process or testbench until the active edge of the clock, or the asynchronous
reset (if applicable), occurs. The returned object may be used to repeatedly wait for one
of these events until a condition is satisfied or a specific number of times. See
the [tick trigger reference](#sim-tick-trigger) for more details.

The `domain` may be either a `ClockDomain` or a [`str`](https://docs.python.org/3/library/stdtypes.html#str). If it is
a [`str`](https://docs.python.org/3/library/stdtypes.html#str), a clock domain with this name is looked up in
the [elaboratable](guide.md#lang-elaboration) `context`, or in `toplevel` if
`context` is not provided.

* **Raises:**
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `domain` is `"comb"`.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `domain` is a `ClockDomain` and `context` is provided and not
        `None`.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `context` is an elaboratable that is not a direct or indirect submodule of
        `toplevel`.
  * [**NameError**](https://docs.python.org/3/library/exceptions.html#NameError) – If `domain` is a [`str`](https://docs.python.org/3/library/stdtypes.html#str), but there is no clock domain with this name in
        `context` or `toplevel`.

#### delay(interval)

Wait until a time interval has elapsed.

This method returns a [`TriggerCombination`](#amaranth.sim.TriggerCombination) object that, when awaited, pauses
the execution of the calling process or testbench by `interval` seconds. The returned
object may be used to wait for multiple events.

The value captured by this trigger is `True` if the delay has expired when the wait has
completed, and `False` otherwise.

The `interval` may be zero, in which case the caller will be scheduled for execution
immediately after all of the processes and testbenches scheduled for the current time step
finish executing. In other words, if a call to [`Simulator.advance()`](#amaranth.sim.Simulator.advance) schedules a process
or testbench and it performs `await ctx.delay(0)`, this process or testbench will
continue execution only during the next call to [`Simulator.advance()`](#amaranth.sim.Simulator.advance).

#### NOTE
Although the behavior of `await ctx.delay(0)` is well-defined, it may make waveforms
difficult to understand and simulations hard to reason about.

* **Raises:**
  [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `delay` is negative.
* **Return type:**
  [*TriggerCombination*](#amaranth.sim.TriggerCombination)

#### changed(\*signals)

Asynchronously wait until one of the signals change.

This method returns a [`TriggerCombination`](#amaranth.sim.TriggerCombination) object that, when awaited, pauses
the execution of the calling process or testbench until any of the `signals` change.
The returned object may be used to wait for multiple events.

The values captured by this trigger are the values of `signals` at the time the wait
has completed.

#### WARNING
The simulation may produce *glitches*: transient changes to signals (e.g. from 0 to 1
and back to 0) during combinational propagation that are invisible in testbenches or
waveform captures. Glitches will wake up **both processes and testbenches** that use
this method to wait for a signal to change, and both processes and testbenches must be
prepared to handle such spurious wakeups. The presence, count, and sequence in which
glitches occur may also vary between simulation runs.

Testbenches that wait for a signal to change using an `await` statement might only
observe the final value of the signal, and testbenches that wait for changes using
an `async for` loop will crash with a [`BrokenTrigger`](#amaranth.sim.BrokenTrigger) exception if they
encounter a glitch.

Processes will observe all of the transient values of the signal.

* **Return type:**
  [*TriggerCombination*](#amaranth.sim.TriggerCombination)

#### edge(signal, polarity)

Asynchronously wait until a low-to-high or high-to-low transition of a signal occurs.

This method returns a [`TriggerCombination`](#amaranth.sim.TriggerCombination) object that, when awaited, pauses
the execution of the calling process or testbench until the value of `signal`
(a single-bit signal or a single-bit slice of a signal) changes from `not polarity`
to `polarity`. The returned object may be used to wait for multiple events.

The value captured by this trigger is `True` if the relevant transition has occurred
at the time the wait has completed, and `False` otherwise.

#### WARNING
In most cases, this method should not be used to wait for a status signal to be asserted
or deasserted in a testbench because it is likely to introduce a race condition.
Whenever a suitable clock domain is available, use
`await ctx.tick().until(signal == polarity)` instead.

* **Raises:**
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `signal` is neither a single-bit `Signal` nor a single-bit slice of
        a `Signal`.
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If the shape of `signal` is a `ShapeCastable`.
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `polarity` is neither 0 nor 1.
* **Return type:**
  [*TriggerCombination*](#amaranth.sim.TriggerCombination)

#### posedge(signal)

Asynchronously wait until a signal is asserted.

Equivalent to [`edge(signal, 1)`](#amaranth.sim.SimulatorContext.edge).

* **Return type:**
  [*TriggerCombination*](#amaranth.sim.TriggerCombination)

#### negedge(signal)

Asynchronously wait until a signal is deasserted.

Equivalent to [`edge(signal, 0)`](#amaranth.sim.SimulatorContext.edge).

* **Return type:**
  [*TriggerCombination*](#amaranth.sim.TriggerCombination)

### *exception* amaranth.sim.BrokenTrigger

Exception raised when a trigger that is repeatedly awaited using an `async for` loop has
a matching event occur while the body of the `async for` loop is still executing.

### *exception* amaranth.sim.DomainReset

Exception raised when a tick trigger is repeatedly awaited, and its domain has been reset.

<a id="sim-tick-trigger"></a>

### *class* amaranth.sim.TickTrigger(...)

A trigger that wakes up the caller when the active edge of a clock domain occurs or the domain
is asynchronously reset.

A [`TickTrigger`](#amaranth.sim.TickTrigger) is an immutable object that stores a reference to a clock domain and
a list of expressions to sample.

The [`SimulatorContext.tick()`](#amaranth.sim.SimulatorContext.tick) method creates a tick trigger with an empty list of sampled
expressions, and the [`TickTrigger.sample()`](#amaranth.sim.TickTrigger.sample) method creates a tick trigger based on another
tick trigger that additionally samples the specified expressions.

To wait for a tick trigger to be activated once (a *one-shot* wait), a process or testbench
calls `await trigger`, usually on a newly created tick trigger:

```default
async def testbench(ctx):
    clk_hit, rst_active, a_value, b_value = await ctx.tick().sample(dut.a, dut.b)
```

To repeatedly wait for a tick trigger to be activated (a *multi-shot* wait), a process or
testbench [asynchronously iterates](https://docs.python.org/3/glossary.html#term-asynchronous-iterable) the tick trigger,
usually using the `async for` loop:

```default
async def testbench(ctx):
    async for clk_hit, rst_active, a_value, b_value in ctx.tick().sample(dut.a, dut.b):
        ...
```

Both one-shot and multi-shot waits return the same [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple)
`(clk_hit, rst_active, *values)` of return values:

1. `clk_hit` is `True` if there was an active clock edge at the moment the wait has
   completed, and `False` otherwise (that is, if the clock domain was asynchronously reset).
2. `rst_active` is `True` if the clock domain is reset (synchronously or asynchronously)
   at the moment the wait has completed, `False` otherwise.
3. All following return values correspond to the sampled expressions in the order in which they
   were added.

Aside from the syntax, there are two differences between one-shot and multi-shot waits:

1. A multi-shot wait continues to observe the tick trigger while the process or testbench
   responds to the event. If the tick trigger is activated again before the next iteration of
   the asynchronous iterator (such as while the body of the `async for` loop is executing),
   the next iteration raises a [`BrokenTrigger`](#amaranth.sim.BrokenTrigger) exception to notify the caller of the missed
   event.
2. A repeated one-shot wait may be less efficient than a multi-shot wait.

#### NOTE
The exact behavior of `rst_active` differs depending on whether `domain` uses
synchronous or asynchronous reset; in both cases it is `True` if and only if
the domain reset has been asserted. Reusable processes and testbenches, as well as their
building blocks, should handle both cases.

* **Parameters:**
  * **engine** (*BaseEngine*)
  * **process** (*BaseProcess*)
  * **domain** (*ClockDomain*)
  * **sampled** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple) *[*[*ValueLike*](reference.md#amaranth.hdl.ValueLike) *]*)

#### sample(\*exprs)

Sample expressions when this trigger is activated.

This method returns a new [`TickTrigger`](#amaranth.sim.TickTrigger) object. When awaited, this object returns,
in addition to the values that would be otherwise returned by `await trigger`,
the values of `exprs` (any [`ValueLike`](reference.md#amaranth.hdl.ValueLike)) at exactly the moment at which
the active clock edge, or the asynchronous reset (if applicable), has occurred.

Combining [`tick()`](#amaranth.sim.SimulatorContext.tick) with [`sample()`](#amaranth.sim.TickTrigger.sample) can be used to capture
the state of a circuit after the active clock edge, but before propagation of signal values
that have been updated by that clock edge:

```default
async for clk_edge, rst_active, in_a_value, in_b_value in \
        ctx.tick().sample(in_a, in_b):
    ...
```

Chaining calls to [`sample()`](#amaranth.sim.TickTrigger.sample) has the same effect as calling it once with the combined
list of arguments. The code below has the same behavior as the code above:

```default
async for clk_edge, rst_active, in_a_value, in_b_value in \
        ctx.tick().sample(in_a).sample(in_b):
    ...
```

#### NOTE
Chaining calls to this method is useful for defining reusable building blocks.
The following (simplified for clarity) implementation of [`until()`](#amaranth.sim.TickTrigger.until) takes advantage
of it by first appending `condition` to the end of the list of captured expressions,
checking if it holds, and then removing it from the list of sampled values:

```default
async def until(trigger, condition):
    async for clk_edge, rst_active, *values, done in trigger.sample(condition):
        if done:
            return values
```

* **Parameters:**
  **exprs** ([*ValueLike*](reference.md#amaranth.hdl.ValueLike))
* **Return type:**
  [*TickTrigger*](#amaranth.sim.TickTrigger)

#### *async* until(condition)

Repeat this trigger until a condition is met.

This method awaits this trigger at least once, and returns a [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of the values
that are [`sample()`](#amaranth.sim.TickTrigger.sample)d when `condition` evaluates to a non-zero value. Values
sampled during previous repeats are discarded.

Awaiting a `trigger` returns values indicating the state of the clock and reset signals,
while awaiting `trigger.until(...)` does not:

```default
while True:
    clk_edge, rst_active, *values, flag_value = await trigger.sample(flag) # never raises
    if flag_value:
        break
# `values` may be used after the loop finishes
```

```default
values = await trigger.until(flag) # may raise `DomainReset`
```

* **Raises:**
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If the shape of `condition` is a `ShapeCastable`.
  * [**DomainReset**](#amaranth.sim.DomainReset) – If the clock domain has been synchronously or asynchronously reset during the wait.
* **Parameters:**
  **condition** ([*ValueLike*](reference.md#amaranth.hdl.ValueLike))

#### *async* repeat(count)

Repeat this trigger a specific number of times.

This method awaits this trigger at least once, and returns a [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of the values
that are [`sample()`](#amaranth.sim.TickTrigger.sample)d during the last repeat. Values sampled during previous repeats
are discarded.

Awaiting a `trigger` returns values indicating the state of the clock and reset signals,
while awaiting `trigger.repeat(...)` does not:

```default
for _ in range(3):
    clk_edge, rst_active, *values = await trigger # never raises
# `values` may be used after the loop finishes
```

```default
values = await trigger.repeat(3) # may raise `DomainReset`
```

* **Raises:**
  * [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If `count` is less than 1.
  * [**DomainReset**](#amaranth.sim.DomainReset) – If the clock domain has been synchronously or asynchronously reset during the wait.
* **Parameters:**
  **count** ([*int*](https://docs.python.org/3/library/functions.html#int))

### *class* amaranth.sim.TriggerCombination(...)

A list of triggers, the activation of any of which will wake up the caller.

A [`TriggerCombination`](#amaranth.sim.TriggerCombination) is an immutable object that stores a list of triggers and
expressions to sample. The trigger combination wakes up the caller when any of these triggers
activate, and it samples all of the signals at the same moment.

The [`SimulatorContext.delay()`](#amaranth.sim.SimulatorContext.delay), [`SimulatorContext.changed()`](#amaranth.sim.SimulatorContext.changed), and
[`SimulatorContext.edge()`](#amaranth.sim.SimulatorContext.edge) methods create a trigger combination that consists of just that
one trigger, while [`TriggerCombination.delay()`](#amaranth.sim.TriggerCombination.delay), [`TriggerCombination.changed()`](#amaranth.sim.TriggerCombination.changed), and
[`TriggerCombination.edge()`](#amaranth.sim.TriggerCombination.edge) methods create a trigger combination based on another trigger
combination by extending it with an additional trigger. The [`TriggerCombination.sample()`](#amaranth.sim.TriggerCombination.sample)
method creates a trigger combination based on another trigger combination that wakes up
the caller in the same conditions but additionally samples the specified expressions.

To wait for a trigger combination to be activated once (a *one-shot* wait), a process or
testbench calls `await triggers`, usually on a newly created trigger combination:

```default
async def testbench(ctx):
    a_value, b_value = await ctx.changed(dut.a, dut.b)
```

To repeatedly wait for a trigger combination to be activated (a *multi-shot* wait), a process
or testbench [asynchronously iterates](https://docs.python.org/3/glossary.html#term-asynchronous-iterable) the trigger
combination, usually using the `async for` loop:

```default
async def testbench(ctx):
    async a_value, b_value in ctx.changed(dut.a, dut.b):
        ...
```

Both one-shot and multi-shot waits return the same [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of return values, the elements
of which are determined by the triggers and sampled expressions that have been added to
the trigger combination, in the order in which they were added. For a detailed description of
the return values, refer to [`SimulatorContext.delay()`](#amaranth.sim.SimulatorContext.delay), [`SimulatorContext.changed()`](#amaranth.sim.SimulatorContext.changed),
[`SimulatorContext.edge()`](#amaranth.sim.SimulatorContext.edge), and [`TriggerCombination.sample()`](#amaranth.sim.TriggerCombination.sample).

Aside from the syntax, there are two differences between one-shot and multi-shot waits:

1. A multi-shot wait continues to observe the trigger combination while the process or testbench
   responds to the event. If the trigger combination is activated again before the next
   iteration of the asynchronous iterator (such as while the body of the `async for` loop is
   executing), the next iteration raises a [`BrokenTrigger`](#amaranth.sim.BrokenTrigger) exception to notify the caller
   of the missed event.
2. A repeated one-shot wait may be less efficient than a multi-shot wait.

* **Parameters:**
  * **engine** (*BaseEngine*)
  * **process** (*BaseProcess*)
  * **triggers** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple) *[**DelayTrigger* *|**ChangedTrigger* *|**SampleTrigger* *|**EdgeTrigger* *,*  *...* *]*)

#### sample(\*exprs)

Sample signals when a trigger from this combination is activated.

This method returns a new [`TriggerCombination`](#amaranth.sim.TriggerCombination) object. When awaited, this object
returns, in addition to the values that would be returned by `await trigger`, the values
of `exprs` at exactly the moment at which the wait has completed.

Combining [`delay()`](#amaranth.sim.SimulatorContext.delay), [`changed()`](#amaranth.sim.SimulatorContext.changed), or
[`edge()`](#amaranth.sim.SimulatorContext.edge) with [`sample()`](#amaranth.sim.TriggerCombination.sample) can be used to capture the state of
a circuit at the moment of the event:

```default
async for arst_edge, delay_expired, in_a_value, in_b_value in \
        ctx.posedge(arst).delay(1e-3).sample(in_a, in_b):
    ...
```

Chaining calls to [`sample()`](#amaranth.sim.TriggerCombination.sample) has the same effect as calling it once with the combined
list of arguments. The code below has the same behavior as the code above:

```default
async for arst_edge, delay_expired, in_a_value, in_b_value in \
        ctx.posedge(arst).delay(1e-3).sample(in_a).sample(in_b):
    ...
```

#### NOTE
Chaining calls to this method is useful for defining reusable building blocks. See
the documentation for [`TickTrigger.sample()`](#amaranth.sim.TickTrigger.sample) for a detailed example.

* **Return type:**
  [*TriggerCombination*](#amaranth.sim.TriggerCombination)

#### delay(interval)

Add a delay trigger to the list of triggers.

This method returns a new [`TriggerCombination`](#amaranth.sim.TriggerCombination) object. When awaited, this object
also waits for the same trigger as [`SimulatorContext.delay()`](#amaranth.sim.SimulatorContext.delay), and returns,
in addition to the values that would be returned by `await trigger`, the value
returned by [`SimulatorContext.delay()`](#amaranth.sim.SimulatorContext.delay).

* **Return type:**
  [*TriggerCombination*](#amaranth.sim.TriggerCombination)

#### changed(\*signals)

Add a signal change trigger to the list of triggers.

This method returns a new [`TriggerCombination`](#amaranth.sim.TriggerCombination) object. When awaited, this object
also waits for the same trigger as [`SimulatorContext.changed()`](#amaranth.sim.SimulatorContext.changed), and returns,
in addition to the values that would be returned by `await trigger`, the values
returned by [`SimulatorContext.changed()`](#amaranth.sim.SimulatorContext.changed).

* **Return type:**
  [*TriggerCombination*](#amaranth.sim.TriggerCombination)

#### edge(signal, polarity)

Add a low-to-high or high-to-low transition trigger to the list of triggers.

This method returns a new [`TriggerCombination`](#amaranth.sim.TriggerCombination) object. When awaited, this object
also waits for the same trigger as [`SimulatorContext.edge()`](#amaranth.sim.SimulatorContext.edge), and returns,
in addition to the values that would be returned by `await trigger`, the values
returned by [`SimulatorContext.edge()`](#amaranth.sim.SimulatorContext.edge).

* **Return type:**
  [*TriggerCombination*](#amaranth.sim.TriggerCombination)

#### posedge(signal)

Add a low-to-high transition trigger to the list of triggers.

Equivalent to [`edge(signal, 1)`](#amaranth.sim.TriggerCombination.edge).

* **Return type:**
  [*TriggerCombination*](#amaranth.sim.TriggerCombination)

#### negedge(signal)

Add a high-to-low transition trigger to the list of triggers.

Equivalent to [`edge(signal, 0)`](#amaranth.sim.TriggerCombination.edge).

* **Return type:**
  [*TriggerCombination*](#amaranth.sim.TriggerCombination)


# start.html.md

# Getting started

This section demonstrates the basic Amaranth workflow to provide a cursory overview of the language and the toolchain. See the tutorial <tutorial> for a step-by-step introduction to the language, and the language guide <guide> for a detailed explanation of every language construct.

<!-- TODO: add link to build system doc -->
<!-- TODO: add link to more complex examples? -->

## A counter

As a first example, consider a counter with a fixed limit, enable, and overflow. The code for this example is shown below. [`Download`](_code/up_counter.py) and run it:

```shell
$ python3 up_counter.py
```

### Implementing a counter

A 16-bit up counter with enable input, overflow output, and a limit fixed at design time can be implemented in Amaranth as follows:

```default
from amaranth import *
from amaranth.lib import wiring
from amaranth.lib.wiring import In, Out


class UpCounter(wiring.Component):
    """
    A 16-bit up counter with a fixed limit.

    Parameters
    ----------
    limit : int
        The value at which the counter overflows.

    Attributes
    ----------
    en : Signal, in
        The counter is incremented if ``en`` is asserted, and retains
        its value otherwise.
    ovf : Signal, out
        ``ovf`` is asserted when the counter reaches its limit.
    """

    en: In(1)
    ovf: Out(1)

    def __init__(self, limit):
        self.limit = limit
        self.count = Signal(16)

        super().__init__()

    def elaborate(self, platform):
        m = Module()

        m.d.comb += self.ovf.eq(self.count == self.limit)

        with m.If(self.en):
            with m.If(self.ovf):
                m.d.sync += self.count.eq(0)
            with m.Else():
                m.d.sync += self.count.eq(self.count + 1)

        return m
```

The reusable building block of Amaranth designs is a `Component`: a Python class declares its interface (`en` and `ovf`, in this case) and implements the `elaborate` method that defines its behavior.

<!-- TODO: link to Elaboratable reference -->

Most `elaborate` implementations use a `Module` helper to describe combinational (`m.d.comb`) and synchronous (`m.d.sync`) logic controlled with conditional syntax (`m.If`, `m.Elif`, `m.Else`) similar to Python’s. They can also instantiate vendor-defined black boxes or modules written in other HDLs.

<!-- TODO: link to DSL reference -->

### Testing a counter

To verify its functionality, the counter can be simulated for a small amount of time, with a test bench driving it and checking a few simple conditions:

```default
from amaranth.sim import Simulator


dut = UpCounter(25)
async def bench(ctx):
    # Disabled counter should not overflow.
    ctx.set(dut.en, 0)
    for _ in range(30):
        await ctx.tick()
        assert not ctx.get(dut.ovf)

    # Once enabled, the counter should overflow in 25 cycles.
    ctx.set(dut.en, 1)
    for _ in range(24):
        await ctx.tick()
        assert not ctx.get(dut.ovf)
    await ctx.tick()
    assert ctx.get(dut.ovf)

    # The overflow should clear in one cycle.
    await ctx.tick()
    assert not ctx.get(dut.ovf)


sim = Simulator(dut)
sim.add_clock(1e-6) # 1 MHz
sim.add_testbench(bench)
with sim.write_vcd("up_counter.vcd"):
    sim.run()
```

The testbench is implemented as a Python `async` function that is simulated concurrently with the counter itself. The testbench can inspect the simulated signals using `ctx.get(sig)`, update them using `ctx.set(sig, val)`, and advance the simulation by one clock cycle with `await ctx.tick()`. See the simulator documentation <simulator> for details.

When run, the testbench finishes successfully, since all of the assertions hold, and produces a VCD file with waveforms recorded for every `Signal` as well as the clock of the `sync` domain:

### Converting a counter

Although some Amaranth workflows do not include Verilog at all, it is still the de facto standard for HDL interoperability. Any Amaranth design can be converted to synthesizable Verilog using the corresponding backend:

```default
from amaranth.back import verilog


top = UpCounter(25)
with open("up_counter.v", "w") as f:
    f.write(verilog.convert(top))
```

The signals that will be connected to the ports of the top-level Verilog module should be specified explicitly. The rising edge clock and synchronous reset signals of the `sync` domain are added automatically; if necessary, the control signals can be configured explicitly. The result is the following Verilog code (lightly edited for clarity):

<!-- TODO: link to clock domain section of language reference -->
```verilog
(* generator = "Amaranth" *)
module top(ovf, clk, rst, en);
  reg \$auto$verilog_backend.cc:2255:dump_module$1  = 0;
  (* src = "up_counter.py:36" *)
  wire \$1 ;
  (* src = "up_counter.py:42" *)
  wire [16:0] \$3 ;
  (* src = "up_counter.py:42" *)
  wire [16:0] \$4 ;
  (* src = "<site-packages>/amaranth/hdl/ir.py:509" *)
  input clk;
  wire clk;
  (* src = "up_counter.py:29" *)
  reg [15:0] count = 16'h0000;
  (* src = "up_counter.py:29" *)
  reg [15:0] \count$next ;
  (* src = "<site-packages>/amaranth/lib/wiring.py:1647" *)
  input en;
  wire en;
  (* src = "<site-packages>/amaranth/lib/wiring.py:1647" *)
  output ovf;
  wire ovf;
  (* src = "<site-packages>/amaranth/hdl/ir.py:509" *)
  input rst;
  wire rst;
  assign \$1  = count == (* src = "up_counter.py:36" *) 5'h19;
  assign \$4  = count + (* src = "up_counter.py:42" *) 1'h1;
  always @(posedge clk)
    count <= \count$next ;
  always @* begin
    if (\$auto$verilog_backend.cc:2255:dump_module$1 ) begin end
    \count$next  = count;
    (* src = "up_counter.py:38" *)
    if (en) begin
      (* full_case = 32'd1 *)
      (* src = "up_counter.py:39" *)
      if (ovf) begin
        \count$next  = 16'h0000;
      end else begin
        \count$next  = \$4 [15:0];
      end
    end
    (* src = "<site-packages>/amaranth/hdl/xfrm.py:534" *)
    if (rst) begin
      \count$next  = 16'h0000;
    end
  end
  assign \$3  = \$4 ;
  assign ovf = \$1 ;
endmodule
```

To aid debugging, the generated Verilog code has the same general structure as the Amaranth source code (although more verbose), and contains extensive source location information.

#### NOTE
Unfortunately, at the moment none of the supported toolchains will use the source location information in diagnostic messages.

## A blinking LED

Although Amaranth works well as a standalone HDL, it also includes a build system that integrates with FPGA toolchains, and many board definition files for common developer boards that include pinouts and programming adapter invocations. The following code will blink a LED with a frequency of 1 Hz on any board that has a LED and an oscillator:

```default
from amaranth import *


class LEDBlinker(Elaboratable):
    def elaborate(self, platform):
        m = Module()

        led = platform.request("led")

        half_freq = int(platform.default_clk_frequency // 2)
        timer = Signal(range(half_freq + 1))

        with m.If(timer == half_freq):
            m.d.sync += led.o.eq(~led.o)
            m.d.sync += timer.eq(0)
        with m.Else():
            m.d.sync += timer.eq(timer + 1)

        return m
```

The `LEDBlinker` module will use the first LED available on the board, and derive the clock divisor from the oscillator frequency specified in the clock constraint. It can be used, for example, with the [Lattice iCEStick evaluation board](https://www.latticesemi.com/icestick), one of the many boards already supported by Amaranth:

<!-- TODO: link to list of supported boards -->
```default
from amaranth_boards.icestick import ICEStickPlatform


ICEStickPlatform().build(LEDBlinker(), do_program=True)
```

With only a single line of code, the design is synthesized, placed, routed, and programmed to the on-board Flash memory. Although not all applications will use the Amaranth build system, the designs that choose it can benefit from the “turnkey” built-in workflows; if necessary, the built-in workflows can be customized to include user-specified options, commands, and files.

<!-- TODO: link to build system reference -->

#### NOTE
The ability to check with minimal effort whether the entire toolchain functions correctly is so important that it is built into every board definition file. To use it with the iCEStick board, run:

```shell
$ python3 -m amaranth_boards.icestick
```

This command will build and program a test bitstream similar to the example above.


# stdlib.html.md

# Standard library

The `amaranth.lib` module, also known as the standard library, provides modules that falls into one of the three categories:

1. Modules that will used by essentially all idiomatic Amaranth code, or which are necessary for interoperability. This includes [`amaranth.lib.enum`](stdlib/enum.md#module-amaranth.lib.enum) (enumerations), [`amaranth.lib.data`](stdlib/data.md#module-amaranth.lib.data) (data structures), [`amaranth.lib.wiring`](stdlib/wiring.md#module-amaranth.lib.wiring) (interfaces and components), [`amaranth.lib.meta`](stdlib/meta.md#module-amaranth.lib.meta) (interface metadata), and [`amaranth.lib.stream`](stdlib/stream.md#module-amaranth.lib.stream) (data streams).
2. Modules that abstract common functionality whose implementation differs between hardware platforms. This includes [`amaranth.lib.memory`](stdlib/memory.md#module-amaranth.lib.memory) and [`amaranth.lib.cdc`](stdlib/cdc.md#module-amaranth.lib.cdc).
3. Modules that have essentially one correct implementation and are of broad utility in digital designs. This includes [`amaranth.lib.coding`](stdlib/coding.md#module-amaranth.lib.coding), [`amaranth.lib.fifo`](stdlib/fifo.md#module-amaranth.lib.fifo), and [`amaranth.lib.crc`](stdlib/crc.md#module-amaranth.lib.crc).

As part of the Amaranth backwards compatibility guarantee, any behaviors described in these documents will not change from a version to another without at least one version including a warning about the impending change. Any nontrivial change to these behaviors must also go through the public review as a part of the [Amaranth Request for Comments process](https://amaranth-lang.org/rfcs/).

The Amaranth standard library is separate from the Amaranth language: everything provided in it could have been implemented in a third-party library.

* [Enumerations](stdlib/enum.md)
  * [Metaclass](stdlib/enum.md#metaclass)
  * [Base classes](stdlib/enum.md#base-classes)
  * [View classes](stdlib/enum.md#view-classes)
* [Data structures](stdlib/data.md)
  * [Introduction](stdlib/data.md#introduction)
  * [Modeling structured data](stdlib/data.md#modeling-structured-data)
  * [Common data layouts](stdlib/data.md#common-data-layouts)
  * [Data views](stdlib/data.md#data-views)
  * [Data classes](stdlib/data.md#data-classes)
* [Interfaces and connections](stdlib/wiring.md)
  * [Introduction](stdlib/wiring.md#introduction)
  * [Signatures](stdlib/wiring.md#signatures)
  * [Interfaces](stdlib/wiring.md#interfaces)
  * [Making connections](stdlib/wiring.md#making-connections)
  * [Components](stdlib/wiring.md#components)
  * [Component metadata](stdlib/wiring.md#component-metadata)
* [Interface metadata](stdlib/meta.md)
  * [Introduction](stdlib/meta.md#introduction)
  * [Defining annotations](stdlib/meta.md#defining-annotations)
  * [Identifying schemas](stdlib/meta.md#identifying-schemas)
  * [Reference](stdlib/meta.md#reference)
* [Data streams](stdlib/stream.md)
  * [Introduction](stdlib/stream.md#introduction)
  * [Data transfer rules](stdlib/stream.md#data-transfer-rules)
  * [Examples](stdlib/stream.md#examples)
  * [Reference](stdlib/stream.md#reference)
* [Memory arrays](stdlib/memory.md)
  * [Introduction](stdlib/memory.md#introduction)
  * [Examples](stdlib/memory.md#examples)
  * [Memory description](stdlib/memory.md#memory-description)
  * [Memory component](stdlib/memory.md#memory-component)
  * [Memory ports](stdlib/memory.md#memory-ports)
* [Input/output buffers](stdlib/io.md)
  * [Introduction](stdlib/io.md#introduction)
  * [Examples](stdlib/io.md#examples)
  * [Simulation](stdlib/io.md#simulation)
  * [Ports](stdlib/io.md#ports)
  * [Buffers](stdlib/io.md#buffers)
* [Clock domain crossing](stdlib/cdc.md)
  * [`FFSynchronizer`](stdlib/cdc.md#amaranth.lib.cdc.FFSynchronizer)
  * [`AsyncFFSynchronizer`](stdlib/cdc.md#amaranth.lib.cdc.AsyncFFSynchronizer)
  * [`ResetSynchronizer`](stdlib/cdc.md#amaranth.lib.cdc.ResetSynchronizer)
  * [`PulseSynchronizer`](stdlib/cdc.md#amaranth.lib.cdc.PulseSynchronizer)
* [Code conversion](stdlib/coding.md)
  * [One-hot coding](stdlib/coding.md#one-hot-coding)
  * [Priority coding](stdlib/coding.md#priority-coding)
  * [Gray coding](stdlib/coding.md#gray-coding)
* [First-in first-out queues](stdlib/fifo.md)
  * [`FIFOInterface`](stdlib/fifo.md#amaranth.lib.fifo.FIFOInterface)
  * [`SyncFIFO`](stdlib/fifo.md#amaranth.lib.fifo.SyncFIFO)
  * [`SyncFIFOBuffered`](stdlib/fifo.md#amaranth.lib.fifo.SyncFIFOBuffered)
  * [`AsyncFIFO`](stdlib/fifo.md#amaranth.lib.fifo.AsyncFIFO)
  * [`AsyncFIFOBuffered`](stdlib/fifo.md#amaranth.lib.fifo.AsyncFIFOBuffered)
* [Cyclic redundancy checks](stdlib/crc.md)
  * [Introduction](stdlib/crc.md#introduction)
  * [Examples](stdlib/crc.md#examples)
  * [Algorithms and parameters](stdlib/crc.md#algorithms-and-parameters)
  * [CRC computation](stdlib/crc.md#crc-computation)
  * [Predefined algorithms](stdlib/crc.md#predefined-algorithms)


# stream.html.md

# Data streams

The [`amaranth.lib.stream`](#module-amaranth.lib.stream) module provides a mechanism for unidirectional exchange of arbitrary data between modules.

## Introduction

One of the most common flow control mechanisms is *ready/valid handshaking*, where a *producer* pushes data to a *consumer* whenever it becomes available, and the consumer signals to the producer whether it can accept more data. In Amaranth, this mechanism is implemented using an [interface](wiring.md#wiring) with three members:

- `payload` (driven by the producer), containing the data;
- `valid` (driven by the producer), indicating that data is currently available in `payload`;
- `ready` (driven by the consumer), indicating that data is accepted if available.

This module provides such an interface, [`stream.Interface`](#amaranth.lib.stream.Interface), and defines the exact rules governing the flow of data through it.

<a id="stream-rules"></a>

## Data transfer rules

The producer and the consumer must be synchronized: they must belong to the same [clock domain](../guide.md#lang-clockdomains), and any [control flow modifiers](../guide.md#lang-controlinserter) must be applied to both, in the same order.

Data flows through a stream according to the following four rules:

1. On each cycle where both `valid` and `ready` are asserted, a transfer is performed: the contents of `payload` are conveyed from the producer to the consumer.
2. Once the producer asserts `valid`, it must not deassert `valid` or change the contents of `payload` until a transfer is performed.
3. The producer must not wait for `ready` to be asserted before asserting `valid`: any form of feedback from `ready` that causes `valid` to become asserted is prohibited.
4. The consumer may assert or deassert `ready` at any time, including via combinational feedback from `valid`.

Some producers and consumers may be designed without support for backpressure. Such producers must tie `ready` to `Const(1)` by specifying `always_ready=True` when constructing a stream, and consumers may (but are not required to) do the same. Similarly, some producers and consumers may be designed such that a payload is provided or must be provided on each cycle. Such consumers must tie `valid` to `Const(1)` by specifying `always_valid=True` when constructing a stream, and producers may (but are not required to) do the same.

If these control signals are tied to `Const(1)`, then the [`wiring.connect`](wiring.md#amaranth.lib.wiring.connect) function ensures that only compatible streams are connected together. For example, if the producer does not support backpressure (`ready` tied to `Const(1)`), it can only be connected to consumers that do not require backpressure. However, consumers that do not require backpressure can be connected to producers with or without support for backpressure. The `valid` control signal is treated similarly.

These rules ensure that producers and consumers that are developed independently can be safely used together, without unduly restricting the application-specific conditions that determine assertion of `valid` and `ready`.

## Examples

The following examples demonstrate the use of streams for a data processing pipeline that receives serial data input from an external device, transforms it by negating the 2’s complement value, and transmits it to another external device whenever requested. Similar pipelines, albeit more complex, are widely used in  applications.

The use of a unified data transfer mechanism enables uniform testing of individual units, and makes it possible to add a queue to the pipeline using only two additional connections.

<!-- from amaranth import * -->
```python
from amaranth.lib import stream, wiring
from amaranth.lib.wiring import In, Out
```

The pipeline is tested using the built-in simulator </simulator> and the two helper functions defined below:

```python
from amaranth.sim import Simulator

async def stream_get(ctx, stream):
    ctx.set(stream.ready, 1)
    payload, = await ctx.tick().sample(stream.payload).until(stream.valid)
    ctx.set(stream.ready, 0)
    return payload

async def stream_put(ctx, stream, payload):
    ctx.set(stream.valid, 1)
    ctx.set(stream.payload, payload)
    await ctx.tick().until(stream.ready)
    ctx.set(stream.valid, 0)
```

#### NOTE
“Minimal streams” as defined in [RFC 61](https://amaranth-lang.org/rfcs/0061-minimal-streams.html) do not provide built-in helper functions for testing pending further work on the clock domain system. They will be provided in a later release. For the time being, you can copy the helper functions above to test your designs that use streams.

### Serial receiver

The serial receiver captures the serial output of an external device and converts it to a stream of words. While the `ssel` signal is high, each low-to-high transition on the `sclk` input captures the value of the `sdat` signal; eight consecutive captured bits are assembled into a word ( first) and pushed into the pipeline for processing. If the `ssel` signal is low, no data transmission occurs and the transmitter and the receiver are instead synchronized with each other.

In this example, the external device does not provide a way to pause data transmission. If the pipeline isn’t ready to accept the next payload, it is necessary to discard data at some point; here, it is done in the serial receiver.

```python
class SerialReceiver(wiring.Component):
    ssel: In(1)
    sclk: In(1)
    sdat: In(1)

    stream: Out(stream.Signature(signed(8)))

    def elaborate(self, platform):
        m = Module()

        # Detect edges on the `sclk` input:
        sclk_reg = Signal()
        sclk_edge = ~sclk_reg & self.sclk
        m.d.sync += sclk_reg.eq(self.sclk)

        # Capture `sdat` and bits into payloads:
        count = Signal(range(8))
        data = Signal(8)
        done = Signal()
        with m.If(~self.ssel):
            m.d.sync += count.eq(0)
        with m.Elif(sclk_edge):
            m.d.sync += count.eq(count + 1)
            m.d.sync += data.eq(Cat(self.sdat, data))
            m.d.sync += done.eq(count == 7)

        # Push assembled payloads into the pipeline:
        with m.If(done & (~self.stream.valid | self.stream.ready)):
            m.d.sync += self.stream.payload.eq(data)
            m.d.sync += self.stream.valid.eq(1)
            m.d.sync += done.eq(0)
        with m.Elif(self.stream.ready):
            m.d.sync += self.stream.valid.eq(0)
        # Payload is discarded if `done & self.stream.valid & ~self.stream.ready`.

        return m
```

```python
def test_serial_receiver():
    dut = SerialReceiver()

    async def testbench_input(ctx):
        await ctx.tick()
        ctx.set(dut.ssel, 1)
        await ctx.tick()
        for bit in [1, 0, 1, 0, 0, 1, 1, 1]:
            ctx.set(dut.sdat, bit)
            ctx.set(dut.sclk, 0)
            await ctx.tick()
            ctx.set(dut.sclk, 1)
            await ctx.tick()
        ctx.set(dut.ssel, 0)
        await ctx.tick()

    async def testbench_output(ctx):
        expected_word = 0b10100111
        payload = await stream_get(ctx, dut.stream)
        assert (payload & 0xff) == (expected_word & 0xff), \
            f"{payload & 0xff:08b} != {expected_word & 0xff:08b} (expected)"

    sim = Simulator(dut)
    sim.add_clock(1e-6)
    sim.add_testbench(testbench_input)
    sim.add_testbench(testbench_output)
    with sim.write_vcd("stream_serial_receiver.vcd"):
        sim.run()
```

<!-- test_serial_receiver() -->

The serial protocol recognized by the receiver is illustrated with the following diagram (corresponding to `stream_serial_receiver.vcd`):

### Serial transmitter

The serial transmitter accepts a stream of words and provides it to the serial input of an external device whenever requested. Its serial interface is the same as that of the serial receiver, with the exception that the `sclk` and `sdat` signals are outputs. The `ssel` signal remains an input; the external device uses it for flow control.

```python
class SerialTransmitter(wiring.Component):
    ssel: In(1)
    sclk: Out(1)
    sdat: Out(1)

    stream: In(stream.Signature(signed(8)))

    def elaborate(self, platform):
        m = Module()

        count = Signal(range(9))
        data = Signal(8)

        with m.If(~self.ssel):
            m.d.sync += count.eq(0)
            m.d.sync += self.sclk.eq(1)
        with m.Elif(count != 0):
            m.d.comb += self.stream.ready.eq(0)
            m.d.sync += self.sclk.eq(~self.sclk)
            with m.If(self.sclk):
                m.d.sync += data.eq(Cat(0, data))
                m.d.sync += self.sdat.eq(data[-1])
            with m.Else():
                m.d.sync += count.eq(count - 1)
        with m.Else():
            m.d.comb += self.stream.ready.eq(1)
            with m.If(self.stream.valid):
                m.d.sync += count.eq(8)
                m.d.sync += data.eq(self.stream.payload)

        return m
```

```python
def test_serial_transmitter():
    dut = SerialTransmitter()

    async def testbench_input(ctx):
        await stream_put(ctx, dut.stream, 0b10100111)

    async def testbench_output(ctx):
        await ctx.tick()
        ctx.set(dut.ssel, 1)
        for index, expected_bit in enumerate([1, 0, 1, 0, 0, 1, 1, 1]):
            _, sdat = await ctx.posedge(dut.sclk).sample(dut.sdat)
            assert sdat == expected_bit, \
                f"bit {index}: {sdat} != {expected_bit} (expected)"
        ctx.set(dut.ssel, 0)
        await ctx.tick()

    sim = Simulator(dut)
    sim.add_clock(1e-6)
    sim.add_testbench(testbench_input)
    sim.add_testbench(testbench_output)
    with sim.write_vcd("stream_serial_transmitter.vcd"):
        sim.run()
```

<!-- test_serial_transmitter() -->

### Value negator

The value negator accepts a stream of words, negates the 2’s complement value of these words, and provides the result as a stream of words again. In a practical  application, this unit could be replaced with, for example, a  filter.

```python
class ValueNegator(wiring.Component):
    i_stream: In(stream.Signature(signed(8)))
    o_stream: Out(stream.Signature(signed(8)))

    def elaborate(self, platform):
        m = Module()

        with m.If(self.i_stream.valid & (~self.o_stream.valid | self.o_stream.ready)):
            m.d.comb += self.i_stream.ready.eq(1)
            m.d.sync += self.o_stream.payload.eq(-self.i_stream.payload)
            m.d.sync += self.o_stream.valid.eq(1)
        with m.Elif(self.o_stream.ready):
            m.d.sync += self.o_stream.valid.eq(0)

        return m
```

```python
def test_value_negator():
    dut = ValueNegator()

    async def testbench_input(ctx):
        await stream_put(ctx, dut.i_stream, 1)
        await stream_put(ctx, dut.i_stream, 17)

    async def testbench_output(ctx):
        assert await stream_get(ctx, dut.o_stream) == -1
        assert await stream_get(ctx, dut.o_stream) == -17

    sim = Simulator(dut)
    sim.add_clock(1e-6)
    sim.add_testbench(testbench_input)
    sim.add_testbench(testbench_output)
    with sim.write_vcd("stream_value_negator.vcd"):
        sim.run()
```

<!-- test_value_negator() -->

### Complete pipeline

The complete pipeline consists of a serial receiver, a value negator, a FIFO queue, and a serial transmitter connected in series. Without queueing, any momentary mismatch between the rate at which the serial data is produced and consumed would result in data loss. A FIFO queue from the [`lib.fifo`](fifo.md#module-amaranth.lib.fifo) standard library module is used to avoid this problem.

```python
from amaranth.lib.fifo import SyncFIFOBuffered

class ExamplePipeline(wiring.Component):
    i_ssel: In(1)
    i_sclk: In(1)
    i_sdat: In(1)

    o_ssel: In(1)
    o_sclk: Out(1)
    o_sdat: Out(1)

    def elaborate(self, platform):
        m = Module()

        # Create and connect serial receiver:
        m.submodules.receiver = receiver = SerialReceiver()
        m.d.comb += [
            receiver.ssel.eq(self.i_ssel),
            receiver.sclk.eq(self.i_sclk),
            receiver.sdat.eq(self.i_sdat),
        ]

        # Create and connect value negator:
        m.submodules.negator = negator = ValueNegator()
        wiring.connect(m, receiver=receiver.stream, negator=negator.i_stream)

        # Create and connect FIFO queue:
        m.submodules.queue = queue = SyncFIFOBuffered(width=8, depth=16)
        wiring.connect(m, negator=negator.o_stream, queue=queue.w_stream)

        # Create and connect serial transmitter:
        m.submodules.transmitter = transmitter = SerialTransmitter()
        wiring.connect(m, queue=queue.r_stream, transmitter=transmitter.stream)

        # Connect outputs:
        m.d.comb += [
            transmitter.ssel.eq(self.o_ssel),
            self.o_sclk.eq(transmitter.sclk),
            self.o_sdat.eq(transmitter.sdat),
        ]

        return m
```

```python
def test_example_pipeline():
    dut = ExamplePipeline()

    async def testbench_input(ctx):
        for value in [1, 17]:
            ctx.set(dut.i_ssel, 1)
            for bit in reversed(range(8)):
                ctx.set(dut.i_sclk, 0)
                ctx.set(dut.i_sdat, bool(value & (1 << bit)))
                await ctx.tick()
                ctx.set(dut.i_sclk, 1)
                await ctx.tick()
            await ctx.tick()
            ctx.set(dut.i_ssel, 0)
            ctx.set(dut.i_sclk, 0)
            await ctx.tick()

    async def testbench_output(ctx):
        await ctx.tick()
        ctx.set(dut.o_ssel, 1)
        for index, expected_value in enumerate([-1, -17]):
            value = 0
            for _ in range(8):
                _, sdat = await ctx.posedge(dut.o_sclk).sample(dut.o_sdat)
                value = (value << 1) | sdat
            assert value == (expected_value & 0xff), \
                f"word {index}: {value:08b} != {expected_value & 0xff:08b} (expected)"
        await ctx.tick()
        ctx.set(dut.o_ssel, 0)

    sim = Simulator(dut)
    sim.add_clock(1e-6)
    sim.add_testbench(testbench_input)
    sim.add_testbench(testbench_output)
    with sim.write_vcd("stream_example_pipeline.vcd"):
        sim.run()
```

<!-- test_example_pipeline() -->

This data processing pipeline overlaps reception and transmission of serial data, with only a few cycles of latency between the completion of reception and the beginning of transmission of the processed data:

![image](amaranth/stdlib/_images/stream_pipeline.png)

Implementing such an efficient pipeline can be difficult without the use of appropriate abstractions. The use of streams allows the designer to focus on the data processing and simplifies testing by ensuring that the interaction of the individual units is standard and well-defined.

## Reference

Components that communicate using streams must not only use a [`stream.Interface`](#amaranth.lib.stream.Interface), but also follow the [data transfer rules](#stream-rules).

### *class* amaranth.lib.stream.Signature(payload_shape, \*, payload_init=None, always_valid=False, always_ready=False)

Signature of a unidirectional data stream.

#### NOTE
“Minimal streams” as defined in [RFC 61](https://amaranth-lang.org/rfcs/0061-minimal-streams.html) lack support for complex payloads, such as
multiple lanes or packetization, as well as introspection of the payload. This limitation
will be lifted in a later release.

* **Parameters:**
  * **payload_shape** ([`ShapeLike`](../reference.md#amaranth.hdl.ShapeLike)) – Shape of the payload member.
  * **payload_init** ([constant-castable](../guide.md#lang-constcasting) object) – Initial value of the payload member.
  * **always_valid** ([`bool`](https://docs.python.org/3/library/functions.html#bool)) – Whether the stream has a payload available each cycle.
  * **always_ready** ([`bool`](https://docs.python.org/3/library/functions.html#bool)) – Whether the stream has its payload accepted whenever it is available (i.e. whether it lacks
    support for backpressure).
* **Members:**
  * **payload** (`Out(payload_shape)`) – Payload.
  * **valid** (`Out(1)`) – Whether a payload is available. If the stream is `always_valid`, `Const(1)`.
  * **ready** (`In(1)`) – Whether a payload is accepted. If the stream is `always_ready`, `Const(1)`.

### *class* amaranth.lib.stream.Interface(signature, \*, path=None, src_loc_at=0)

A unidirectional data stream.

* **Attributes:**
  **signature** ([`Signature`](#amaranth.lib.stream.Signature)) – Signature of this data stream.
* **Parameters:**
  **signature** ([*Signature*](#amaranth.lib.stream.Signature))

#### *property* p

Shortcut for `self.payload`.

This shortcut reduces repetition when manipulating the payload, for example:

```default
m.d.comb += [
    self.o_stream.p.result.eq(self.i_stream.p.first + self.i_stream.p.second),
    self.o_stream.valid.eq(self.i_stream.valid),
    self.i_stream.ready.eq(self.o_stream.ready),
]
```


# support.html.md

# Support

* For commercial support, please reach out to us at [sales@chipflow.io](mailto:sales@chipflow.io).
* You can get community support for our alpha releases in our [GitHub Discussions forum](https://github.com/ChipFlow/chipflow-central/discussions).
* Please report any issues you find to the [ChipFlow Central Bug Tracker](https://github.com/ChipFlow/chipflow-central/issues)!


# tutorial-intro-chipflow-platform.html.md

# Introduction to the ChipFlow platform

This tutorial gives an overview of how we can configure an SoC (system on chip) with the ChipFlow platform:

* Simulate an example SoC
* Add a peripheral
* Optionally run on an FPGA

#### IMPORTANT
To test designs on an FPGA, you will need a [ULX3S](https://www.crowdsupply.com/radiona/ulx3s).
Other development boards will be supported in the future.

#### IMPORTANT
This tutorial assumes you are running on macOS 11 or later or Ubuntu 22.04 or later.
The tutorial will work on other Linux distributions, but instructions are not included here.

## Preparing your local environment

We use [PDM](https://pdm.fming.dev/) to manage dependencies and ensure reproducible builds of your design.

First install PDM:

```default
pipx ensurepath
    pipx install pdm
```

You may need to restart your shell session for PDM to become available, using:

```default
exec "$SHELL"
```

To program the FPGA board we use [openFPGAloader](https://trabucayre.github.io/openFPGALoader/guide/install.html).

## Getting started

First use [Git](https://git-scm.com/) to get the example sources.

```default
git clone https://github.com/ChipFlow/chipflow-examples
```

Then set up your environment:

```default
cd chipflow-examples
pdm install
```

## The example project

The project contains:

* `.github/workflows/*` - Runs linting and tests in GitHub Actions.
* `chipflow.toml` - Configuration telling the ChipFlow library how to load your Python design and allows you to configure the ChipFlow platform.
* `Makefile` - Contains helpful shortcuts to the CLI tools used in the project.
* `my_design/design.py` - This has the actual chip design.
* `my_design/steps/*` - These control how your design will be presented to the ChipFlow build steps, `sim``(ulation), (FPGA)``board` and `silicon`.
* `my_design/sim/*` - The C++ and [doit build file](https://pydoit.org/) which builds the binary which will simulate our design.
* `my_design/software/*` - The C++ and [doit build file](https://pydoit.org/) for the software/BIOS which we will load onto our design when it’s running in simulation or on a board.
* `tests/*` - This has some pytest integration tests which cover simulation and board/silicon builds.

## The design

The chip design is contained within the MySoC class in `my_design/design.py`, and is described
using the [Amaranth hardware definition language](https://github.com/amaranth-lang/amaranth).
Amaranth is already well-used for FPGA boards, and at ChipFlow we will be using it
to produce silicon chips.

Something a little unusual about our example Amaranth design is that we change
how the peripherals are physically accessed for use with simulation, a board, or
silicon.

For example, here’s where we add `QSPIFlash` to our design:

```python
m.submodules.rom_provider = rom_provider = platform.providers.QSPIFlashProvider()
self.rom = SPIMemIO(
    flash=rom_provider.pins
)
```

The provider implementations, which are provided by ChipFlow, look a bit different for each context:

### QSPIFlash for a Board

For a board, in our case a ULX3S board, we need a means of accessing the clock pin (`USRMCLK`) and buffer primitives (`OBZ`, `BB`) to access the other pins:

```python
class QSPIFlashProvider(Elaboratable):
    def __init__(self):
        self.pins = QSPIPins()

    def elaborate(self, platform):
        m = Module()

        flash = platform.request("spi_flash", dir=dict(cs='-', copi='-', cipo='-', wp='-', hold='-'))
        # Flash clock requires a special primitive to access in ECP5
        m.submodules.usrmclk = Instance(
            "USRMCLK",
            i_USRMCLKI=self.pins.clk_o,
            i_USRMCLKTS=ResetSignal(),  # tristate in reset for programmer accesss
            a_keep=1,
        )
        # IO pins and buffers
        m.submodules += Instance(
            "OBZ",
            o_O=flash.cs.io,
            i_I=self.pins.csn_o,
            i_T=ResetSignal(),
        )
        # Pins in order
        data_pins = ["copi", "cipo", "wp", "hold"]

        for i in range(4):
            m.submodules += Instance(
                "BB",
                io_B=getattr(flash, data_pins[i]).io,
                i_I=self.pins.d_o[i],
                i_T=~self.pins.d_oe[i],
                o_O=self.pins.d_i[i]
            )
        return m
```

This is specific to the ECP5 family of boards, and the code would look different for others.

### QSPIFlash for Simulation

For simulation, we add a C++ model which will mock/simulate the flash:

```python
class QSPIFlashProvider(Elaboratable):
    def __init__(self):
        self.pins = QSPIPins()

    def elaborate(self, platform):
        return platform.add_model("spiflash_model", self.pins, edge_det=['clk_o', 'csn_o'])
```

### QSPIFlash for Silicon

For Silicon we just hook up the IO.

```python
class QSPIFlashProvider(Elaboratable):
    def __init__(self):
        self.pins = QSPIPins()

    def elaborate(self, platform):
        m = Module()
        m.d.comb += [
            platform.request("flash_clk").eq(self.pins.clk_o),
            platform.request("flash_csn").eq(self.pins.csn_o),
        ]
        for index in range(4):
            pin = platform.request(f"flash_d{index}")
            m.d.comb += [
                self.pins.d_i[index].eq(pin.i),
                pin.o.eq(self.pins.d_o[index]),
                pin.oe.eq(self.pins.d_oe[index])
            ]
        return m
```

## Run the design in simulation

Running our design and its software in simulation allows us to loosely check
that it’s working.

First we need to build a local simulation binary. The simulation uses
blackbox C++ models of external peripherals, such as the flash, to interact
with:

```bash
pdm run chipflow sim build
```

After running this, we will have a simulation binary at `build/sim/sim_soc`.

We can’t run it just yet, as it needs the software/BIOS too. To build the
software we run:

```bash
pdm run chipflow software
```

Now that we have our simulation binary, and a BIOS, we can run it:

```bash
pdm run chipflow sim run
```

You should see console output like this:

```bash
🐱: nyaa~!
SoC type: CA7F100F
SoC version: 2024D6E6
Flash ID: CA7CA7FF
Entering QSPI mode
Initialised!
```

Which means the processor is up and running. You can use Ctrl+C to interrupt it.

## Run the design on a ULX3S board (optional)

We can also run our design on an FPGA board, although currently only the ULX3S
is supported. If you don’t have one, you can
[skip to the next section](#add-peripheral).

First we need to build the design into a bitstream for the board:

```bash
pdm run chipflow board build
```

This will write a file `build/top.bit`. As for the simulation, we need the
software/BIOS too.

If we haven’t already, build the bios:

```bash
pdm run chipflow software
```

Now, we load the software/BIOS and design onto board (program its bitstream):

```bash
pdm run chipflow board load-software-ulx3s
pdm run chipflow board load-ulx3s
```

Your board should now be running. For us to check that it’s working, we can
connect to it via its serial port:

### Connecting to your board

First you need to find the serial port for your board, this is a little tricky but you should only need to do this once.

Below we will refer to the name of your serial port as `$TTYUSB`. This is the full path you saw, starting with `/dev/`.

For ease you can set this in your terminal using `export TTYUSB=/dev/<the tty device you found>`.

Connect to the port via the screen utility, at baud `115200`, with the command:

```bash
screen $TTYUSB 115200
```

Now, press the `PWR` button on your board, which will restart the design,
and give you a chance to see its output. It should look like:

```bash
🐱: nyaa~!
SoC type: CA7F100F
SoC version: 613015FF
Flash ID: EF401800
Entering QSPI mode
Initialised!
```

To exit screen, use `CTRL-A`, then `CTRL-\`.

<a id="add-peripheral"></a>

## Add a peripheral to the design

We’re going to add a very simple peripheral - buttons! This will allow us to press
buttons on our board and see the result, as well as something in simlation.

### Add buttons to the design

In `my_design/design.py` we need to add another GPIO peripheral to read the
button values.

You can uncomment the following:

Add an address space:

```python
self.uart_base = 0xb2000000
self.timer_base = 0xb3000000
self.soc_id_base = 0xb4000000
self.btn_gpio_base = 0xb5000000
```

Add the button peripheral:

```python
soc_type = 0xCA7F100F
self.soc_id = SoCID(type_id=soc_type)
self._decoder.add(self.soc_id.bus, addr=self.soc_id_base)

m.submodules.gpio_provider = gpio_provider = platform.providers.ButtonGPIOProvider()
self.btn = GPIOPeripheral(
    pins=gpio_provider.pins
)
self._decoder.add(self.btn.bus, addr=self.btn_gpio_base)
```

Link up the button submodule:

```python
m.submodules.uart = self.uart
m.submodules.timer = self.timer
m.submodules.soc_id = self.soc_id
m.submodules.btn = self.btn
```

Add the button to our software generator:

```python
sw.add_periph("uart", "UART0", self.uart_base)
sw.add_periph("plat_timer", "TIMER0", self.timer_base)
sw.add_periph("soc_id", "SOC_ID", self.soc_id_base)
sw.add_periph("gpio", "BTN_GPIO", self.btn_gpio_base)
```

### Update our software

So far, we have added the buttons to our design, but nothing will happen if we
press them! So we update our software so it reacts to the button presses:

In `my_design/software/main.c` we uncomment the button press listening code:

```c
while (1) {
        // Listen for button presses
        next_buttons = BTN_GPIO->in;
        if ((next_buttons & 1U) && !(last_buttons & 1U))
                puts("button 1 pressed!\n");
        if ((next_buttons & 2U) && !(last_buttons & 2U))
                puts("button 2 pressed!\n");
        last_buttons = next_buttons;
};
```

Because we called `sw.add_periph("gpio", "BTN_GPIO", self.btn_gpio_base)` in our design above, here in our software we’ll have a `BTN_GPIO` pointer to the peripheral address.

The pointer will be of a type matching the peripheral fields, and its in field contains the input value of the GPIO.

Using this, we’ll now see “button X pressed!” when one of the buttons is pressed.

### Update our simulation

We’re going to simulate the buttons being pressed in the simulation on a timer.

It is possible to listen for keypresses on the keyboard, but that would introduce
too many dependencies for our simple example.

So, in `my_design/sim/main.cc` we will uncomment the button presses code:

```cpp
while (1) {
    tick();
    idx = (idx + 1) % 1000000;

    // Simulate button presses
    if (idx == 100000) // at t=100000, press button 1
        top.p_buttons.set(0b01U);
    else if (idx == 150000) // at t=150000, release button 1
        top.p_buttons.set(0b00U);
    else if (idx == 300000) // at t=300000, press button 2
        top.p_buttons.set(0b10U);
    else if (idx == 350000) // at t=350000, release button 2
        top.p_buttons.set(0b00U);
}
```

See how we’re pressing and releasing button 1, followed by button 2, on a loop, forever.

## See our new peripheral in action

### See the changes in simulation

We can now take a look at our changes in simulation:

```bash
# Rebuild our software
pdm run chipflow software

# Rebuild our simulation
pdm run chipflow sim build

# Run our simulation
pdm run chipflow sim run
```

We should now see the output with button presses:

```bash
🐱: nyaa~!
SoC type: CA7F100F
SoC version: DCBBADEA
Flash ID: CA7CA7FF
Entering QSPI mode
Initialised!
button 1 pressed!
button 2 pressed!
button 1 pressed!
```

### See the changes on our board (optional)

To see the changes on our board, we need to load the updated
software and design:

```bash
# Rebuild our software
pdm run chipflow software

# Rebuild our board
pdm run chipflow board build

# Load software onto board
pdm run chipflow board load-software-ulx3s

# Load design onto board
pdm run chipflow board load-ulx3s
```

Now, as in our first example, we need to connect to the board and
see its output.

When we press the physical buttons on the board, we should see it:

```bash
🐱: nyaa~!
SoC type: CA7F100F
SoC version: DCBBADEA
Flash ID: EF401800
Entering QSPI mode
Initialised!
button 2 pressed!
button 2 pressed!
button 1 pressed!
button 2 pressed!
```

## Building for Silicon

To submit your design for silicon fabrication, see the [Getting Started with ChipFlow Examples](examples/getting-started.md) guide which covers the full submission workflow using the ChipFlow API.

[Sign up](https://chipflow.io/beta) to be notified when new releases are available.

If you are using this tutorial to test out new designs, reach out to us in our [GitHub Discussions forum](https://github.com/ChipFlow/chipflow-central/discussions). We would love to add your designs to our test sets!

## What’s on the roadmap?

We still have a lot of work to do - some things on our roadmap:

* Silicon build API
* Integration tests to test your design in Python.
* Improved simulation tooling.
* Many more high-quality Amaranth Peripheral IP modules to include in your designs.

## Join the Alpha Program

If you’re interested in the platform, you can [join the alpha program](https://chipflow.io/beta)
and help us build the future of Python-powered chip design.

## Troubleshooting

* Python version issues:
  : If you choose to run `pdm install` within a venv, PDM will reuse
    that venv instead of creating a new one.
    Ensure that you use a venv with Python 3.11 or greater.


# tutorial.html.md

# Tutorial


# using-pin-signatures.html.md

# Using Pin Signatures and Software Drivers

This guide explains how to use ChipFlow’s pin signature system and attach software drivers to your hardware designs.

## Overview

ChipFlow provides a standardized way to:

1. Define external pin interfaces for your design using **Pin Signatures** (UARTSignature, GPIOSignature, etc.)
2. Attach software driver code to peripherals using **SoftwareDriverSignature**
3. Connect pre-built software binaries to flash memory using **attach_data()**

## Pin Signatures

Pin signatures define the external interface of your design. ChipFlow provides several built-in signatures for common peripherals:

### Available Pin Signatures

- `UARTSignature()` - Serial UART interface (TX, RX)
- `GPIOSignature(pin_count)` - General purpose I/O pins
- `SPISignature()` - SPI master interface (SCK, COPI, CIPO, CSN)
- `I2CSignature()` - I2C bus interface (SCL, SDA)
- `QSPIFlashSignature()` - Quad SPI flash interface
- `JTAGSignature()` - JTAG debug interface

All pin signatures accept `IOModelOptions` to customize their electrical and behavioral properties (see below).

### Using Pin Signatures in Your Top-Level Design

Pin signatures are used when defining your top-level component’s interface:

```python
# Define a simple SoC with external interfaces
class MySoC(wiring.Component):
    def __init__(self):
        super().__init__({
            "uart": Out(UARTSignature()),
            "gpio": Out(GPIOSignature(pin_count=8)),
            "flash": Out(QSPIFlashSignature()),
        })

# Verify the component can be instantiated
soc = MySoC()
assert hasattr(soc, 'uart')
assert hasattr(soc, 'gpio')
assert hasattr(soc, 'flash')
```

These signatures tell ChipFlow:

- How to connect your design to the physical pins of your chip
- How to select appropriate simulation models for each external interface type
- How to simulate signals and test the interface in a virtual environment
- Requirements for pad and package pin allocation (power domains, drive strength, etc.)

Pin signatures are generic and independent of any particular IP implementation, allowing ChipFlow to match the interface type (UART, GPIO, SPI) to appropriate simulation models and test infrastructure.

### IO Model Options

All pin signatures accept `IOModelOptions` to configure the electrical and behavioral properties of the I/O pins:

```python
from chipflow.platform import GPIOSignature, IOTripPoint

super().__init__({
    # Basic GPIO
    "gpio_basic": Out(GPIOSignature(pin_count=4)),

    # GPIO with custom options
    "gpio_custom": Out(GPIOSignature(
        pin_count=8,
        invert=True,              # Invert all pins
        individual_oe=True,       # Separate OE for each pin
        clock_domain='io_clk',    # Use IO clock domain
        trip_point=IOTripPoint.TTL,  # TTL input thresholds
        init=0x00,                # Initial output values
        init_oe=0xFF              # Initial OE values (all enabled)
    ))
})
```

#### Available IOModelOptions

- **invert** (`bool` or `Tuple[bool, ...]`) - Polarity inversion for pins. Can be a single bool for all pins or a tuple specifying inversion per pin.
- **individual_oe** (`bool`) - If `True`, each output wire has its own Output Enable bit. If `False` (default), a single OE bit controls the entire port.
- **power_domain** (`str`) - Name of the I/O power domain. Pins with different power domains must be in separate signatures.
- **clock_domain** (`str`) - Name of the I/O’s clock domain (default: `'sync'`). Pins with different clock domains must be in separate signatures.
- **buffer_in** (`bool`) - Enable input buffer on the I/O pad.
- **buffer_out** (`bool`) - Enable output buffer on the I/O pad.
- **sky130_drive_mode** (`Sky130DriveMode`) - Drive mode for Sky130 output buffers (see below).
- **trip_point** (`IOTripPoint`) - Input buffer trip point configuration:
  - `IOTripPoint.CMOS` - CMOS switching levels (30%/70%) referenced to I/O power domain
  - `IOTripPoint.TTL` - TTL levels (low < 0.8V, high > 2.0V)
  - `IOTripPoint.VCORE` - CMOS levels referenced to core power domain
  - `IOTripPoint.VREF` - CMOS levels referenced to external reference voltage
  - `IOTripPoint.SCHMITT_TRIGGER` - Schmitt trigger for noise immunity
- **init** (`int` or `bool`) - Initial values for output signals.
- **init_oe** (`int` or `bool`) - Initial values for output enable signals.

### Sky130-Specific Pin Configuration

For Sky130 chips, you can configure the I/O cell drive mode:

```python
from chipflow.platform import Sky130DriveMode, GPIOSignature

# Use open-drain with strong pull-down for I2C
super().__init__({
    "i2c_gpio": Out(GPIOSignature(
        pin_count=2,
        sky130_drive_mode=Sky130DriveMode.OPEN_DRAIN_STRONG_DOWN
    ))
})
```

## Software Driver Signatures

The `SoftwareDriverSignature` allows you to attach C/C++ driver code to your hardware peripherals. This is useful for providing software APIs that match your hardware registers.

### Creating a Peripheral with Driver Code

Here’s how to create a peripheral that includes software driver code:

```python
from amaranth.lib.wiring import In, Out
from amaranth_soc import csr
from chipflow.platform import UARTSignature, SoftwareDriverSignature

class UARTPeripheral(wiring.Component):
    def __init__(self, *, addr_width=5, data_width=8, init_divisor=0):
        # Your peripheral implementation here...

        # Define the signature with driver code attached
        super().__init__(
            SoftwareDriverSignature(
                members={
                    "bus": In(csr.Signature(addr_width=addr_width, data_width=data_width)),
                    "pins": Out(UARTSignature()),
                },
                component=self,
                regs_struct='uart_regs_t',      # Name of register struct in C
                c_files=['drivers/uart.c'],     # C implementation files
                h_files=['drivers/uart.h']      # Header files
            )
        )
```

### Driver File Organization

Driver files should be placed relative to your peripheral’s Python file:

```text
chipflow_digital_ip/io/
├── _uart.py                  # Peripheral definition
└── drivers/
    ├── uart.h                # Header with register struct and API
    └── uart.c                # Implementation
```

### Example Header File (uart.h)

```c
#ifndef UART_H
#define UART_H

#include <stdint.h>

// Register structure matching your hardware
typedef struct __attribute__((packed, aligned(4))) {
    uint8_t config;
    uint8_t padding_0[3];
    uint32_t phy_config;
    uint8_t status;
    uint8_t data;
    uint8_t padding_1[6];
} uart_mod_regs_t;

typedef struct __attribute__((packed, aligned(4))) {
    uart_mod_regs_t rx;
    uart_mod_regs_t tx;
} uart_regs_t;

// Driver API
void uart_init(volatile uart_regs_t *uart, uint32_t divisor);
void uart_putc(volatile uart_regs_t *uart, char c);
void uart_puts(volatile uart_regs_t *uart, const char *s);

#endif
```

The register structure must use `__attribute__((packed, aligned(4)))` to match the hardware layout.

### Example Implementation File (uart.c)

```c
#include "uart.h"

void uart_init(volatile uart_regs_t *uart, uint32_t divisor) {
    uart->tx.config = 0;
    uart->tx.phy_config = divisor & 0x00FFFFFF;
    uart->tx.config = 1;
    uart->rx.config = 0;
    uart->rx.phy_config = divisor & 0x00FFFFFF;
    uart->rx.config = 1;
}

void uart_putc(volatile uart_regs_t *uart, char c) {
    if (c == '\n')
        uart_putc(uart, '\r');
    while (!(uart->tx.status & 0x1))
        ;
    uart->tx.data = c;
}
```

## Using Peripherals in Your SoC

Here’s a complete example of using peripherals with driver code in your top-level design:

```python
from amaranth import Module
from amaranth.lib.wiring import Out, flipped, connect
from amaranth_soc import csr

from chipflow_digital_ip.io import UARTPeripheral, GPIOPeripheral
from chipflow.platform import UARTSignature, GPIOSignature

class MySoC(wiring.Component):
    def __init__(self):
        super().__init__({
            "uart_0": Out(UARTSignature()),
            "gpio_0": Out(GPIOSignature(pin_count=8)),
        })

    def elaborate(self, platform):
        m = Module()

        # Create CSR decoder for peripheral access
        csr_decoder = csr.Decoder(addr_width=28, data_width=8)
        m.submodules.csr_decoder = csr_decoder

        # Instantiate UART peripheral
        m.submodules.uart_0 = uart_0 = UARTPeripheral(
            init_divisor=int(25e6//115200)
        )
        csr_decoder.add(uart_0.bus, name="uart_0", addr=0x02000000)

        # Connect to top-level pins
        connect(m, flipped(self.uart_0), uart_0.pins)

        # Instantiate GPIO peripheral
        m.submodules.gpio_0 = gpio_0 = GPIOPeripheral(pin_count=8)
        csr_decoder.add(gpio_0.bus, name="gpio_0", addr=0x01000000)

        # Connect to top-level pins
        connect(m, flipped(self.gpio_0), gpio_0.pins)

        return m
```

The driver code is automatically collected during the ChipFlow build process and made available to your software.

## Attaching Software Binaries

The `attach_data()` function allows you to attach pre-built software binaries (like bootloaders) to flash memory interfaces.

### Basic Usage

```python
from pathlib import Path
from chipflow.platform import attach_data, SoftwareBuild

def elaborate(self, platform):
    m = Module()

    # ... create your flash peripheral (spiflash) ...

    # Build software from source files
    sw = SoftwareBuild(
        sources=Path('design/software').glob('*.c'),
        offset=0x100000  # Start at 1MB offset in flash
    )

    # Attach to both internal and external interfaces
    attach_data(self.flash, m.submodules.spiflash, sw)

    return m
```

The `attach_data()` function:

1. Takes the **external interface** (`self.flash`) from your top-level component
2. Takes the **internal component** (`m.submodules.spiflash`) that implements the flash controller
3. Takes the **SoftwareBuild** object describing the software to build and load

The software is automatically compiled, linked, and loaded into the simulation or silicon design.

### SoftwareBuild Parameters

```python
SoftwareBuild(
    sources,           # List or glob of .c source files
    includes=[],       # List of .h include files to copy
    include_dirs=[],   # Additional include directories
    offset=0           # Offset in flash memory (in bytes)
)
```

## Complete Example

Here’s a complete working example combining all concepts:

```python
from pathlib import Path
from amaranth import Module
from amaranth.lib import wiring
from amaranth.lib.wiring import Out, flipped, connect
from amaranth_soc import csr, wishbone

from chipflow_digital_ip.io import UARTPeripheral, GPIOPeripheral
from chipflow_digital_ip.memory import QSPIFlash
from chipflow.platform import (
    UARTSignature, GPIOSignature, QSPIFlashSignature,
    Sky130DriveMode, attach_data, SoftwareBuild
)

class MySoC(wiring.Component):
    def __init__(self):
        # Define top-level pin interfaces
        super().__init__({
            "flash": Out(QSPIFlashSignature()),
            "uart": Out(UARTSignature()),
            "gpio": Out(GPIOSignature(pin_count=8)),
            "i2c_pins": Out(GPIOSignature(
                pin_count=2,
                sky130_drive_mode=Sky130DriveMode.OPEN_DRAIN_STRONG_UP
            ))
        })

        self.csr_base = 0xb0000000
        self.bios_offset = 0x100000  # 1MB

    def elaborate(self, platform):
        m = Module()

        # Create bus infrastructure
        csr_decoder = csr.Decoder(addr_width=28, data_width=8)
        m.submodules.csr_decoder = csr_decoder

        # QSPI Flash with driver
        m.submodules.flash = flash = QSPIFlash(addr_width=24, data_width=32)
        csr_decoder.add(flash.csr_bus, name="flash", addr=0x00000000)
        connect(m, flipped(self.flash), flash.pins)

        # UART with driver (115200 baud at 25MHz clock)
        m.submodules.uart = uart = UARTPeripheral(
            init_divisor=int(25e6//115200)
        )
        csr_decoder.add(uart.bus, name="uart", addr=0x02000000)
        connect(m, flipped(self.uart), uart.pins)

        # GPIO with driver
        m.submodules.gpio = gpio = GPIOPeripheral(pin_count=8)
        csr_decoder.add(gpio.bus, name="gpio", addr=0x01000000)
        connect(m, flipped(self.gpio), gpio.pins)

        # I2C pins (using GPIO with open-drain)
        m.submodules.i2c = i2c_gpio = GPIOPeripheral(pin_count=2)
        csr_decoder.add(i2c_gpio.bus, name="i2c", addr=0x01100000)
        connect(m, flipped(self.i2c_pins), i2c_gpio.pins)

        # Build and attach BIOS software
        sw = SoftwareBuild(
            sources=Path('design/software').glob('*.c'),
            offset=self.bios_offset
        )
        attach_data(self.flash, flash, sw)

        return m
```

**Note:** For more advanced examples including CPU cores and Wishbone bus integration, see the [chipflow-examples repository](https://github.com/ChipFlow/chipflow-examples), which contains tested and working SoC designs.

## See Also

- chipflow-toml-guide - Configuring your ChipFlow project
- platform-api - Complete platform API including SimPlatform and attach_data
- [ChipFlow Examples](https://github.com/ChipFlow/chipflow-examples) - Complete working examples with CPU and Wishbone bus


# wiring.html.md

<a id="wiring"></a>

# Interfaces and connections

The [`amaranth.lib.wiring`](#module-amaranth.lib.wiring) module provides a way to declare the interfaces between design components and connect them to each other in a reliable and convenient way.

<!-- from amaranth import * -->

<a id="wiring-introduction"></a>

## Introduction

### Overview

This module provides four related facilities:

1. Description and construction of interface objects via [`Flow`](#amaranth.lib.wiring.Flow) ([`In`](#amaranth.lib.wiring.In) and [`Out`](#amaranth.lib.wiring.Out)), [`Member`](#amaranth.lib.wiring.Member), and [`Signature`](#amaranth.lib.wiring.Signature), as well as the associated container class [`SignatureMembers`](#amaranth.lib.wiring.SignatureMembers). These classes provide the syntax used in defining components, and are also useful for introspection.
2. Flipping of signatures and interface objects via [`FlippedSignature`](#amaranth.lib.wiring.FlippedSignature) and [`FlippedInterface`](#amaranth.lib.wiring.FlippedInterface), as well as the associated container class [`FlippedSignatureMembers`](#amaranth.lib.wiring.FlippedSignatureMembers). This facility reduces boilerplate by adapting existing signatures and interface objects: the flip operation changes the [`In`](#amaranth.lib.wiring.In) data flow of a member to [`Out`](#amaranth.lib.wiring.Out) and vice versa.
3. Connecting interface objects together via [`connect()`](#amaranth.lib.wiring.connect). The [`connect()`](#amaranth.lib.wiring.connect) function ensures that the provided interface objects can be connected to each other, and adds the necessary `.eq()` statements to a `Module`.
4. Defining reusable, self-contained components via [`Component`](#amaranth.lib.wiring.Component). Components are `Elaboratable` objects that interact with the rest of the design through an interface specified by their signature.

To use this module, add the following imports to the beginning of the file:

```python
from amaranth.lib import wiring
from amaranth.lib.wiring import In, Out
```

The [“Motivation”](#wiring-intro1) and [“Reusable interfaces”](#wiring-intro2) sections describe concepts that are essential for using this module and writing idiomatic Amaranth code. The sections after describe advanced use cases that are only relevant for more complex code.

<a id="wiring-intro1"></a>

### Motivation

Consider a reusable counter with an enable input, configurable limit, and an overflow flag. Using only the core Amaranth language, it could be implemented as:

```python
class BasicCounter(Elaboratable):
    def __init__(self):
        self.en  = Signal()

        self.count = Signal(8)
        self.limit = Signal.like(self.count)

        self.overflow  = Signal()

    def elaborate(self, platform):
        m = Module()

        with m.If(self.en):
            m.d.sync += self.overflow.eq(0)
            with m.If(self.count == self.limit):
                m.d.sync += self.overflow.eq(1)
                m.d.sync += self.count.eq(0)
            with m.Else():
                m.d.sync += self.count.eq(self.count + 1)

        return m
```

Nothing in this implementation indicates the directions of its ports (`en`, `count`, `limit`, and `overflow`) in relation to other parts of the design. To understand whether the value of a port is expected to be provided externally or generated internally, it is first necessary to read the body of the `elaborate` method. If the port is not used within that method in a particular elaboratable, it is not possible to determine its direction, or whether it is even meant to be connected.

The [`amaranth.lib.wiring`](#module-amaranth.lib.wiring) module provides a solution for this problem: *components*. A component is an elaboratable that declares the shapes and directions of its ports in its *signature*. The example above can be rewritten to use the [`Component`](#amaranth.lib.wiring.Component) base class (which itself inherits from `Elaboratable`) to be:

```python
class ComponentCounter(wiring.Component):
    en: In(1)

    count: Out(8)
    limit: In(8)

    overflow: Out(1)

    def elaborate(self, platform):
        m = Module()

        with m.If(self.en):
            m.d.sync += self.overflow.eq(0)
            with m.If(self.count == self.limit):
                m.d.sync += self.overflow.eq(1)
                m.d.sync += self.count.eq(0)
            with m.Else():
                m.d.sync += self.count.eq(self.count + 1)

        return m
```

The code in the constructor *creating* the signals of the counter’s interface one by one is now gone, replaced with the [variable annotations](https://docs.python.org/3/glossary.html#term-variable-annotation) *declaring* the counter’s interface. The inherited constructor, `Component.__init__()`, creates the same attributes with the same values as before, and the `elaborate` method is unchanged.

The major difference between the two examples is that the `ComponentCounter` provides unambiguous answers to two questions that previously required examining the `elaborate` method:

1. Which of the Python object’s attributes are ports that are intended to be connected to the rest of the design.
2. What is the direction of the flow of information through the port.

This information, aside from being clear from the source code, can now be retrieved from the `.signature` attribute, which contains an instance of the [`Signature`](#amaranth.lib.wiring.Signature) class:

```pycon
>>> ComponentCounter().signature
Signature({'en': In(1), 'count': Out(8), 'limit': In(8), 'overflow': Out(1)})
```

The [shapes](../guide.md#lang-shapes) of the ports need not be static. The `ComponentCounter` can be made generic, with its range specified when it is constructed, by creating the signature explicitly in its constructor:

```python
class GenericCounter(wiring.Component):
    def __init__(self, width):
        super().__init__({
            "en": In(1),

            "count": Out(width),
            "limit": In(width),

            "overflow": Out(1)
        })

    # The implementation of the `elaborate` method is the same.
    elaborate = ComponentCounter.elaborate
```

```pycon
>>> GenericCounter(16).signature
Signature({'en': In(1), 'count': Out(16), 'limit': In(16), 'overflow': Out(1)})
```

Instances of the `ComponentCounter` and `GenericCounter` class are two examples of *interface objects*. An interface object is a Python object of any type whose a `signature` attribute contains a [`Signature`](#amaranth.lib.wiring.Signature) with which the interface object is compliant (as determined by the [`is_compliant`](#amaranth.lib.wiring.Signature.is_compliant) method of the signature).

The next section introduces the concepts of directionality and connection, and discusses interface objects in more detail.

<a id="wiring-intro2"></a>

### Reusable interfaces

Consider a more complex example where two components are communicating with a *stream* that is using *ready/valid signaling*, where the `valid` signal indicates that the value of `data` provided by the source is meaningful, and the `ready` signal indicates that the sink has consumed the data word:

```python
class DataProducer(wiring.Component):
    en: In(1)

    data: Out(8)
    valid: Out(1)
    ready: In(1)

    def elaborate(self, platform): ...


class DataConsumer(wiring.Component):
    data: In(8)
    valid: In(1)
    ready: Out(1)

    # ... other ports...

    def elaborate(self, platform): ...
```

Data would be transferred between these components by assigning the outputs to the inputs elsewhere in the design:

```python
m = Module()
m.submodules.producer = producer = DataProducer()
m.submodules.consumer = consumer = DataConsumer()

...

m.d.comb += [
    consumer.data.eq(producer.data),
    consumer.valid.eq(producer.valid),
    producer.ready.eq(consumer.ready),
]
```

Although this example is short, it is already repetitive and redundant. The ports on the producer and the consumer, which must match each other for the connection to be made correctly, are declared twice; and the connection itself is made in an error-prone manual way even though the signatures include all of the information required to create it.

The signature of a stream could be defined in a generic way:

```python
class SimpleStreamSignature(wiring.Signature):
    def __init__(self, data_shape):
        super().__init__({
            "data": Out(data_shape),
            "valid": Out(1),
            "ready": In(1)
        })

    def __eq__(self, other):
        return self.members == other.members
```

```pycon
>>> SimpleStreamSignature(8).members
SignatureMembers({'data': Out(8), 'valid': Out(1), 'ready': In(1)})
```

A definition like this is usable, depending on the data flow direction of the members, only in the producer (as in the code above) or only in the consumer. To resolve this problem, this module introduces *flipping*: an operation that reverses the data flow direction of the members of a signature or an interface object while leaving everything else about the object intact. In Amaranth, the (non-flipped) signature definition always declares the data flow directions appropriate for a bus initiator, stream source, controller, and so on. A bus target, stream sink, peripheral, and so on would reuse the source definition by flipping it.

A signature is flipped by calling [`sig.flip()`](#amaranth.lib.wiring.Signature.flip), and an interface object is flipped by calling [`flipped(intf)`](#amaranth.lib.wiring.flipped). These calls return instances of the [`FlippedSignature`](#amaranth.lib.wiring.FlippedSignature) and [`FlippedInterface`](#amaranth.lib.wiring.FlippedInterface) classes, respectively, which use metaprogramming to wrap another object, changing only the data flow directions of its members and forwarding all other method calls and attribute accesses to the wrapped object.

The example above can be rewritten to use this definition of a stream signature as:

```python
class StreamProducer(wiring.Component):
    en: In(1)
    source: Out(SimpleStreamSignature(8))

    def elaborate(self, platform): ...


class StreamConsumer(wiring.Component):
    sink: Out(SimpleStreamSignature(8).flip())

    def elaborate(self, platform): ...


m = Module()
m.submodules.producer = producer = StreamProducer()
m.submodules.consumer = consumer = StreamConsumer()
```

The producer and the consumer reuse the same signature, relying on flipping to make the port directions complementary:

```pycon
>>> producer.source.signature.members
SignatureMembers({'data': Out(8), 'valid': Out(1), 'ready': In(1)})
>>> producer.source.signature.members['data']
Out(8)
>>> consumer.sink.signature.members
SignatureMembers({'data': Out(8), 'valid': Out(1), 'ready': In(1)}).flip()
>>> consumer.sink.signature.members['data']
In(8)
```

In the `StreamConsumer` definition above, the `sink` member has its direction flipped explicitly because the sink is a stream input; this is the case for every interface due to how port directions are defined. Since this operation is so ubiquitous, it is also performed when `In(...)` is used with a signature rather than a shape. The `StreamConsumer` definition above should normally be written as:

```python
class StreamConsumerUsingIn(wiring.Component):
    sink: In(SimpleStreamSignature(8))

    def elaborate(self, platform): ...
```

The data flow directions of the ports are identical between the two definitions:

```pycon
>>> consumer.sink.signature.members == StreamConsumerUsingIn().sink.signature.members
True
```

If signatures are nested within each other multiple levels deep, the final port direction is determined by how many nested `In(...)` members there are. For each `In(...)` signature wrapping a port, the data flow direction of the port is flipped once:

```pycon
>>> sig = wiring.Signature({"port": Out(1)})
>>> sig.members["port"]
Out(1)
>>> in1 = wiring.Signature({"sig": In(sig)})
>>> in1.members["sig"].signature.members["port"]
In(1)
>>> in2 = wiring.Signature({"sig": In(in1)})
>>> in2.members["sig"].signature.members["sig"].signature.members["port"]
Out(1)
```

Going back to the stream example, the producer and the consumer now communicate with one another using the same set of ports with identical shapes and complementary directions (the auxiliary `en` port being outside of the stream signature), and can be *connected* using the [`connect()`](#amaranth.lib.wiring.connect) function:

```python
wiring.connect(m, producer.source, consumer.sink)
```

This function examines the signatures of the two provided interface objects, ensuring that they are exactly complementary, and then adds combinational `.eq()` statements to the module for each of the port pairs to form the connection. Aside from the *connectability* check, the single line above is equivalent to:

```python
m.d.comb += [
    consumer.sink.data.eq(producer.source.data),
    consumer.sink.valid.eq(producer.source.valid),
    producer.source.ready.eq(consumer.sink.ready),
]
```

Even on the simple example of a stream signature it is clear how using the [`connect()`](#amaranth.lib.wiring.connect) function results in more concise, readable, and robust code. The difference is proportionally more pronounced with more complex signatures. When a signature is being refactored, no changes to the code that uses [`connect()`](#amaranth.lib.wiring.connect) is required.

This explanation concludes the essential knowledge necessary for using this module and writing idiomatic Amaranth code.

<a id="wiring-forwarding"></a>

### Forwarding interior interfaces

Consider a case where a component includes another component as a part of its implementation, and where it is necessary to *forward* the ports of the inner component, that is, expose them within the outer component’s signature. To use the `SimpleStreamSignature` definition above in an example:

```python
class DataProcessorImplementation(wiring.Component):
    source: Out(SimpleStreamSignature(8))

    def elaborate(self, platform): ...


class DataProcessorWrapper(wiring.Component):
    source: Out(SimpleStreamSignature(8))

    def elaborate(self, platform):
        m = Module()
        m.submodules.impl = impl = DataProcessorImplementation()
        m.d.comb += [
            self.source.data.eq(impl.source.data),
            self.source.valid.eq(impl.source.valid),
            impl.source.ready.eq(self.source.ready),
        ]
        return m
```

Because forwarding the ports requires assigning an output to an output and an input to an input, the [`connect()`](#amaranth.lib.wiring.connect) function, which connects outputs to inputs and vice versa, cannot be used—at least not directly. The [`connect()`](#amaranth.lib.wiring.connect) function is designed to cover the usual case of connecting the interfaces of modules *from outside* those modules. In order to connect an interface *from inside* a module, it is necessary to flip that interface first using the [`flipped()`](#amaranth.lib.wiring.flipped) function. The `DataProcessorWrapper` should instead be implemented as:

```python
class DataProcessorWrapper(wiring.Component):
    source: Out(SimpleStreamSignature(8))

    def elaborate(self, platform):
        m = Module()
        m.submodules.impl = impl = DataProcessorImplementation()
        wiring.connect(m, wiring.flipped(self.source), impl.source)
        return m
```

In some cases, *both* of the two interfaces provided to [`connect()`](#amaranth.lib.wiring.connect) must be flipped. For example, the correct way to implement a component that forwards an input interface to an output interface with no processing is:

```python
class DataForwarder(wiring.Component):
    sink: In(SimpleStreamSignature(8))
    source: Out(SimpleStreamSignature(8))

    def elaborate(self, platform):
        m = Module()
        wiring.connect(m, wiring.flipped(self.sink), wiring.flipped(self.source))
        return m
```

#### WARNING
It is important to wrap an interface with the [`flipped()`](#amaranth.lib.wiring.flipped) function whenever it is being connected from inside the module. If the `elaborate` function above had made a connection using `wiring.connect(m, self.sink, self.source)`, it would not work correctly. No diagnostic is emitted in this case.

<a id="wiring-constant-inputs"></a>

### Constant inputs

Sometimes, a component must conform to a particular signature, but some of the input ports required by the signature must have a fixed value at all times. This module addresses this case by allowing both `Signal` and `Const` objects to be used to implement port members:

```python
class ProducerRequiringReady(wiring.Component):
    source: Out(SimpleStreamSignature(8))

    def __init__(self):
        super().__init__()
        self.source.ready = Const(1)

    def elaborate(self, platform): ...


class ConsumerAlwaysReady(wiring.Component):
    sink: In(SimpleStreamSignature(8))

    def __init__(self):
        super().__init__()
        self.sink.ready = Const(1)

    def elaborate(self, platform): ...


class ConsumerPossiblyUnready(wiring.Component):
    sink: In(SimpleStreamSignature(8))

    def elaborate(self, platform): ...
```

```pycon
>>> SimpleStreamSignature(8).is_compliant(ProducerRequiringReady().source)
True
>>> SimpleStreamSignature(8).flip().is_compliant(ConsumerAlwaysReady().sink)
True
```

However, the [`connect()`](#amaranth.lib.wiring.connect) function considers a constant input to be connectable only to a constant output with the same value:

```pycon
>>> wiring.connect(m, ProducerRequiringReady().source, ConsumerAlwaysReady().sink)
>>> wiring.connect(m, ProducerRequiringReady().source, ConsumerPossiblyUnready().sink)
Traceback (most recent call last):
  ...
amaranth.lib.wiring.ConnectionError: Cannot connect to the input member 'arg0.ready' that has a constant value 1
```

This feature reduces the proliferation of similar but subtly incompatible interfaces that are semantically similar, only differing in the presence or absence of optional control or status signals.

<a id="wiring-adapting-interfaces"></a>

### Adapting interfaces

Sometimes, a design requires an interface with a particular signature to be used, but the only implementation available is either a component with an incompatible signature or an elaboratable with no signature at all. If this problem cannot be resolved by other means, *interface adaptation* can be used, where the existing signals are placed into a new interface with the appropriate signature. For example:

```python
class LegacyAXIDataProducer(Elaboratable):
    def __init__(self):
        self.adata = Signal(8)
        self.avalid = Signal()
        self.aready = Signal()

    def elaborate(self, platform): ...


class ModernDataConsumer(wiring.Component):
    sink: In(SimpleStreamSignature(8))


data_producer = LegacyAXIDataProducer()
data_consumer = ModernDataConsumer()

adapted_data_source = SimpleStreamSignature(8).create()
adapted_data_source.data = data_producer.adata
adapted_data_source.valid = data_producer.avalid
adapted_data_source.ready = data_producer.aready

m = Module()
wiring.connect(m, adapted_data_source, data_consumer.sink)
```

When creating an adapted interface, use the [`create`](#amaranth.lib.wiring.Signature.create) method of the signature that is required elsewhere in the design.

<a id="wiring-customizing"></a>

### Customizing signatures and interfaces

The [`amaranth.lib.wiring`](#module-amaranth.lib.wiring) module encourages creation of reusable building blocks. In the examples above, a custom signature, `SimpleStreamSignature`, was introduced to illustrate the essential concepts necessary to use this module. While sufficient for that goal, it does not demonstrate the full capabilities provided by the module.

Consider a simple System-on-Chip memory bus with a configurable address width. In an application like that, additional properties and methods could be usefully defined both on the signature (for example, properties to retrieve the parameters of the interface) and on the created interface object (for example, methods to examine the control and status signals). These can be defined as follows:

```python
from amaranth.lib import enum


class TransferType(enum.Enum, shape=1):
    Write = 0
    Read  = 1


class SimpleBusSignature(wiring.Signature):
    def __init__(self, addr_width=32):
        self._addr_width = addr_width
        super().__init__({
            "en":     Out(1),
            "rw":     Out(TransferType),
            "addr":   Out(self._addr_width),
            "r_data": In(32),
            "w_data": Out(32),
        })

    @property
    def addr_width(self):
        return self._addr_width

    def __eq__(self, other):
        return isinstance(other, SimpleBusSignature) and self.addr_width == other.addr_width

    def __repr__(self):
        return f"SimpleBusSignature({self.addr_width})"

    def create(self, *, path=None, src_loc_at=0):
        return SimpleBusInterface(self, path=path, src_loc_at=1 + src_loc_at)


class SimpleBusInterface(wiring.PureInterface):
    def is_read_xfer(self):
        return self.en & (self.rw == TransferType.Read)

    def is_write_xfer(self):
        return self.en & (self.rw == TransferType.Write)
```

This example demonstrates several important principles of use:

* Defining additional properties for a custom signature. The [`Signature`](#amaranth.lib.wiring.Signature) objects are mutable in a restricted way, and can be frozen with the `freeze` method. In almost all cases, the newly defined properties must be immutable, as shown above.
* Defining a signature-specific `__eq__` method. While anonymous (created from a dictionary of members) instances of [`Signature`](#amaranth.lib.wiring.Signature) compare structurally, instances of [`Signature`](#amaranth.lib.wiring.Signature)-derived classes compare by identity unless the equality operator is overridden. In almost all cases, the equality operator should compare the parameters of the signatures rather than their structures.
* Defining a signature-specific `__repr__` method. Similarly to `__eq__`, the default implementation for [`Signature`](#amaranth.lib.wiring.Signature)-derived classes uses the signature’s identity. In almost all cases, the representation conversion operator should return an expression that constructs an equivalent signature.
* Defining a signature-specific `create` method. The default implementation used in anonymous signatures, [`Signature.create()`](#amaranth.lib.wiring.Signature.create), returns a new instance of [`PureInterface`](#amaranth.lib.wiring.PureInterface). Whenever the custom signature has a corresponding custom interface object class, this method should return a new instance of that class. It should not have any required arguments beyond the ones that [`Signature.create()`](#amaranth.lib.wiring.Signature.create) has (required parameters should be provided when creating the signature and not the interface), but may take additional optional arguments, forwarding them to the interface object constructor.

```pycon
>>> sig32 = SimpleBusSignature(); sig32
SimpleBusSignature(32)
>>> sig24 = SimpleBusSignature(24); sig24
SimpleBusSignature(24)
>>> sig24.addr_width
24
>>> sig24 == SimpleBusSignature(24)
True
>>> bus = sig24.create(); bus
<SimpleBusInterface: SimpleBusSignature(24), en=(sig bus__en), rw=EnumView(TransferType, (sig bus__rw)), addr=(sig bus__addr), r_data=(sig bus__r_data), w_data=(sig bus__w_data)>
>>> bus.is_read_xfer()
(& (sig bus__en) (== (sig bus__rw) (const 1'd1)))
```

The custom properties defined for both the signature and the interface object can be used on the flipped signature and the flipped interface in the usual way:

```pycon
>>> sig32.flip().addr_width
32
>>> wiring.flipped(bus).is_read_xfer()
(& (sig bus__en) (== (sig bus__rw) (const 1'd1)))
```

#### NOTE
Unusually for Python, when the implementation of a property or method is invoked through a flipped object, the `self` argument receives the flipped object that has the type [`FlippedSignature`](#amaranth.lib.wiring.FlippedSignature) or [`FlippedInterface`](#amaranth.lib.wiring.FlippedInterface). This wrapper object proxies all attribute accesses and method calls to the original signature or interface, the only change being that of the data flow directions. See the documentation for these classes for a more detailed explanation.

#### WARNING
While the wrapper object forwards attribute accesses and method calls, it does not currently proxy special methods such as `__getitem__` or `__add__` that are rarely, if ever, used with interface objects. This limitation may be lifted in the future.

<a id="wiring-path"></a>

### Paths

Whenever an operation in this module needs to refer to the interior of an object, it accepts or produces a *path*: a tuple of strings and integers denoting the attribute names and indexes through which an interior value can be extracted. For example, the path `("buses", 0, "cyc")` into the object `obj` corresponds to the Python expression `obj.buses[0].cyc`.

When they appear in diagnostics, paths are printed as the corresponding Python expression.

## Signatures

### *class* amaranth.lib.wiring.Flow

Direction of data flow. This enumeration has two values, [`Out`](#amaranth.lib.wiring.Out) and [`In`](#amaranth.lib.wiring.In),
the meaning of which depends on the context in which they are used.

#### Out

Outgoing data flow.

When included in a standalone [`Signature`](#amaranth.lib.wiring.Signature), a port [`Member`](#amaranth.lib.wiring.Member) with an [`Out`](#amaranth.lib.wiring.Out)
data flow carries data from an initiator to a responder. That is, the signature
describes the initiator driving the signal and the responder sampling the signal.

When used as the flow of a signature [`Member`](#amaranth.lib.wiring.Member), indicates that the data flow of
the port members of the inner signature remains the same.

When included in the `signature` property of an `Elaboratable`, the signature
describes the elaboratable driving the corresponding signal. That is, the elaboratable is
treated as the initiator.

#### In

Incoming data flow.

When included in a standalone [`Signature`](#amaranth.lib.wiring.Signature), a port [`Member`](#amaranth.lib.wiring.Member) with an [`In`](#amaranth.lib.wiring.In)
data flow carries data from an responder to a initiator. That is, the signature
describes the initiator sampling the signal and the responder driving the signal.

When used as the flow of a signature [`Member`](#amaranth.lib.wiring.Member), indicates that the data flow of
the port members of the inner signature is flipped.

When included in the `signature` property of an `Elaboratable`, the signature
describes the elaboratable sampling the corresponding signal. That is, the elaboratable is
treated as the initiator, the same as in the [`Out`](#amaranth.lib.wiring.Out) case.

#### flip()

Flip the direction of data flow.

* **Returns:**
  [`In`](#amaranth.lib.wiring.In) if called as `Out.flip()`; [`Out`](#amaranth.lib.wiring.Out) if called as `In.flip()`.
* **Return type:**
  [`Flow`](#amaranth.lib.wiring.Flow)

#### \_\_call_\_(description, \*, init=None, reset=None, src_loc_at=0)

Create a [`Member`](#amaranth.lib.wiring.Member) with this data flow and the provided description and
initial value.

* **Returns:**
  `Member(self, description, init=init)`
* **Return type:**
  [`Member`](#amaranth.lib.wiring.Member)

### amaranth.lib.wiring.Out *= Out*

A shortcut for importing [`Flow.Out`](#amaranth.lib.wiring.Flow.Out) as [`amaranth.lib.wiring.Out`](#amaranth.lib.wiring.Out).

### amaranth.lib.wiring.In *= In*

A shortcut for importing [`Flow.In`](#amaranth.lib.wiring.Flow.In) as [`amaranth.lib.wiring.In`](#amaranth.lib.wiring.In).

### *class* amaranth.lib.wiring.Member(flow, description, \*, init=None)

Description of a signature member.

This class is a discriminated union: its instances describe either a port member or
a signature member, and accessing properties for the wrong kind of member raises
an [`AttributeError`](https://docs.python.org/3/library/exceptions.html#AttributeError).

The class is created from a description: a [`Signature`](#amaranth.lib.wiring.Signature) instance (in which case
the [`Member`](#amaranth.lib.wiring.Member) is created as a signature member), or a [shape-like](../guide.md#lang-shapelike)
object (in which case it is created as a port member). After creation the [`Member`](#amaranth.lib.wiring.Member)
instance cannot be modified.

When a `Signal` is created from a description of a port member, the signal’s initial value
is taken from the member description. If this signal is never explicitly assigned a value, it
will equal `init`.

Although instances can be created directly, most often they will be created through
[`In`](#amaranth.lib.wiring.In) and [`Out`](#amaranth.lib.wiring.Out), e.g. `In(unsigned(1))` or `Out(stream.Signature(RGBPixel))`.

#### flip()

Flip the data flow of this member.

* **Returns:**
  A new `member` with `member.flow` equal to `self.flow.flip()`, and identical
  to `self` other than that.
* **Return type:**
  [`Member`](#amaranth.lib.wiring.Member)

#### array(\*dimensions)

Add array dimensions to this member.

The dimensions passed to this method are prepended to the existing dimensions.
For example, `Out(1).array(2)` describes an array of 2 elements, whereas both
`Out(1).array(2, 3)` and `Out(1).array(3).array(2)` both describe a two dimensional
array of 2 by 3 elements.

Dimensions are passed to [`array()`](#amaranth.lib.wiring.Member.array) in the order in which they would be indexed.
That is, `.array(x, y)` creates a member that can be indexed up to `[x-1][y-1]`.

The [`array()`](#amaranth.lib.wiring.Member.array) method is composable: calling `member.array(x)` describes an array of
`x` members even if `member` was already an array.

* **Returns:**
  A new `member` with `member.dimensions` extended by `dimensions`, and
  identical to `self` other than that.
* **Return type:**
  [`Member`](#amaranth.lib.wiring.Member)

#### *property* flow

Data flow of this member.

* **Return type:**
  [`Flow`](#amaranth.lib.wiring.Flow)

#### *property* is_port

Whether this is a description of a port member.

* **Returns:**
  `True` if this is a description of a port member,
  `False` if this is a description of a signature member.
* **Return type:**
  [`bool`](https://docs.python.org/3/library/functions.html#bool)

#### *property* is_signature

Whether this is a description of a signature member.

* **Returns:**
  `True` if this is a description of a signature member,
  `False` if this is a description of a port member.
* **Return type:**
  [`bool`](https://docs.python.org/3/library/functions.html#bool)

#### *property* shape

Shape of a port member.

* **Returns:**
  The shape that was provided when constructing this [`Member`](#amaranth.lib.wiring.Member).
* **Return type:**
  [shape-like object](../guide.md#lang-shapelike)
* **Raises:**
  [**AttributeError**](https://docs.python.org/3/library/exceptions.html#AttributeError) – If `self` describes a signature member.

#### *property* init

Initial value of a port member.

* **Returns:**
  The initial value that was provided when constructing this [`Member`](#amaranth.lib.wiring.Member).
* **Return type:**
  [const-castable object](../guide.md#lang-constcasting)
* **Raises:**
  [**AttributeError**](https://docs.python.org/3/library/exceptions.html#AttributeError) – If `self` describes a signature member.

#### *property* signature

Signature of a signature member.

* **Returns:**
  The signature that was provided when constructing this [`Member`](#amaranth.lib.wiring.Member).
* **Return type:**
  [`Signature`](#amaranth.lib.wiring.Signature)
* **Raises:**
  [**AttributeError**](https://docs.python.org/3/library/exceptions.html#AttributeError) – If `self` describes a port member.

#### *property* dimensions

Array dimensions.

A member will usually have no dimensions; in this case it does not describe an array.
A single dimension describes one-dimensional array, and so on.

* **Returns:**
  Dimensions, if any, of this member, from most to least major.
* **Return type:**
  [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of [`int`](https://docs.python.org/3/library/functions.html#int)

### *exception* amaranth.lib.wiring.SignatureError

This exception is raised when an invalid operation specific to signature manipulation is
performed with [`SignatureMembers`](#amaranth.lib.wiring.SignatureMembers). Other exceptions, such as [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError) or
[`NameError`](https://docs.python.org/3/library/exceptions.html#NameError), will still be raised where appropriate.

### *class* amaranth.lib.wiring.SignatureMembers(members=())

Mapping of signature member names to their descriptions.

This container, a [`collections.abc.Mapping`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping), is used to implement the `members`
attribute of signature objects.

The keys in this container must be valid Python attribute names that are public (do not begin
with an underscore. The values must be instances of [`Member`](#amaranth.lib.wiring.Member). The container is immutable.

The [`create()`](#amaranth.lib.wiring.SignatureMembers.create) method converts this mapping into a mapping of names to signature members
(signals and interface objects) by creating them from their descriptions. The created mapping
can be used to populate an interface object.

#### flip()

Flip the data flow of the members in this mapping.

* **Returns:**
  Proxy collection `FlippedSignatureMembers(self)` that flips the data flow of
  the members that are accessed using it.
* **Return type:**
  [`FlippedSignatureMembers`](#amaranth.lib.wiring.FlippedSignatureMembers)

#### \_\_eq_\_(other)

Compare the members in this and another mapping.

* **Returns:**
  `True` if the mappings contain the same key-value pairs, `False` otherwise.
* **Return type:**
  [`bool`](https://docs.python.org/3/library/functions.html#bool)

#### \_\_contains_\_(name)

Check whether a member with a given name exists.

* **Return type:**
  [`bool`](https://docs.python.org/3/library/functions.html#bool)

#### \_\_getitem_\_(name)

Retrieves the description of a member with a given name.

* **Return type:**
  [`Member`](#amaranth.lib.wiring.Member)
* **Raises:**
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If `name` is not a string.
  * [**NameError**](https://docs.python.org/3/library/exceptions.html#NameError) – If `name` is not a valid, public Python attribute name.
  * [**SignatureError**](#amaranth.lib.wiring.SignatureError) – If a member called `name` does not exist in the collection.

#### \_\_setitem_\_(name, member)

Stub that forbids addition of members to the collection.

* **Raises:**
  [**SignatureError**](#amaranth.lib.wiring.SignatureError) – Always.

#### \_\_delitem_\_(name)

Stub that forbids removal of members from the collection.

* **Raises:**
  [**SignatureError**](#amaranth.lib.wiring.SignatureError) – Always.

#### \_\_iter_\_()

Iterate through the names of members in the collection.

* **Returns:**
  Names of members, in the order of insertion.
* **Return type:**
  iterator of [`str`](https://docs.python.org/3/library/stdtypes.html#str)

#### flatten(\*, path=())

Recursively iterate through this collection.

#### NOTE
The [paths](#wiring-path) returned by this method and by [`Signature.flatten()`](#amaranth.lib.wiring.Signature.flatten)
differ. This method yields a single result for each [`Member`](#amaranth.lib.wiring.Member) in the collection,
disregarding their dimensions:

```pycon
>>> sig = wiring.Signature({
...     "items": In(1).array(2)
... })
>>> list(sig.members.flatten())
[(('items',), In(1).array(2))]
```

The [`Signature.flatten()`](#amaranth.lib.wiring.Signature.flatten) method yields multiple results for such a member; see
the documentation for that method for an example.

* **Returns:**
  Pairs of [paths](#wiring-path) and the corresponding members. A path yielded by
  this method is a tuple of strings where each item is a key through which the item may
  be reached.
* **Return type:**
  iterator of ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of [`str`](https://docs.python.org/3/library/stdtypes.html#str), [`Member`](#amaranth.lib.wiring.Member))

#### create(\*, path=None, src_loc_at=0)

Create members from their descriptions.

For each port member, this function creates a `Signal` with the shape and initial
value taken from the member description, and the name constructed from
the [paths](#wiring-path) to the member (by concatenating path items with a double
underscore, `__`).

For each signature member, this function calls [`Signature.create()`](#amaranth.lib.wiring.Signature.create) for that signature.
The resulting object can have any type if a [`Signature`](#amaranth.lib.wiring.Signature) subclass overrides
the [`create`](#amaranth.lib.wiring.SignatureMembers.create) method.

If the member description includes dimensions, in each case, instead of a single member,
a [`list`](https://docs.python.org/3/library/stdtypes.html#list) of members is created for each dimension. (That is, for a single dimension
a list of members is returned, for two dimensions a list of lists is returned, and so on.)

* **Returns:**
  Mapping of names to actual signature members.
* **Return type:**
  dict of [`str`](https://docs.python.org/3/library/stdtypes.html#str) to [value-like](../guide.md#lang-valuelike) or interface object or a potentially nested list of these

### *class* amaranth.lib.wiring.FlippedSignatureMembers(unflipped)

Mapping of signature member names to their descriptions, with the directions flipped.

Although an instance of [`FlippedSignatureMembers`](#amaranth.lib.wiring.FlippedSignatureMembers) could be created directly, it will
be usually created by a call to [`SignatureMembers.flip()`](#amaranth.lib.wiring.SignatureMembers.flip).

This container is a wrapper around [`SignatureMembers`](#amaranth.lib.wiring.SignatureMembers) that contains the same members
as the inner mapping, but flips their data flow when they are accessed. For example:

```python
members = wiring.SignatureMembers({"foo": Out(1)})

flipped_members = members.flip()
assert flipped_members["foo"].flow == In
```

This class implements the same methods, with the same functionality (other than the flipping of
the data flow), as the [`SignatureMembers`](#amaranth.lib.wiring.SignatureMembers) class; see the documentation for that class
for details.

#### flip()

Flips this mapping back to the original one.

* **Returns:**
  `unflipped`
* **Return type:**
  [`SignatureMembers`](#amaranth.lib.wiring.SignatureMembers)

### *class* amaranth.lib.wiring.Signature(members)

Description of an interface object.

An interface object is a Python object that has a `signature` attribute containing
a [`Signature`](#amaranth.lib.wiring.Signature) object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when [`connect()`](#amaranth.lib.wiring.connect)ing two interface objects
together. See the [introduction to interfaces](#wiring-intro1) for a more detailed
explanation of why this is useful.

[`Signature`](#amaranth.lib.wiring.Signature) can be used as a base class to define [customized](#wiring-customizing)
signatures and interface objects.

#### WARNING
[`Signature`](#amaranth.lib.wiring.Signature) objects are immutable. Classes inheriting from [`Signature`](#amaranth.lib.wiring.Signature) must
ensure this remains the case when additional functionality is added.

#### flip()

Flip the data flow of the members in this signature.

* **Returns:**
  Proxy object `FlippedSignature(self)` that flips the data flow of the attributes
  corresponding to the members that are accessed using it.

  See the documentation for the [`FlippedSignature`](#amaranth.lib.wiring.FlippedSignature) class for a detailed discussion
  of how this proxy object works.
* **Return type:**
  [`FlippedSignature`](#amaranth.lib.wiring.FlippedSignature)

#### *property* members

Members in this signature.

* **Return type:**
  [`SignatureMembers`](#amaranth.lib.wiring.SignatureMembers)

#### \_\_eq_\_(other)

Compare this signature with another.

The behavior of this operator depends on the types of the arguments. If both `self`
and `other` are instances of the base [`Signature`](#amaranth.lib.wiring.Signature) class, they are compared
structurally (the result is `self.members == other.members`); otherwise they are
compared by identity (the result is `self is other`).

Subclasses of [`Signature`](#amaranth.lib.wiring.Signature) are expected to override this method to take into account
the specifics of the domain. If the subclass has additional properties that do not influence
the [`members`](#amaranth.lib.wiring.Signature.members) dictionary but nevertheless make its instance incompatible with other
instances (for example, whether the feedback is combinational or registered),
the overridden method must take that into account.

* **Return type:**
  [`bool`](https://docs.python.org/3/library/functions.html#bool)

#### flatten(obj)

Recursively iterate through this signature, retrieving member values from an interface
object.

#### NOTE
The [paths](#wiring-path) returned by this method and by
[`SignatureMembers.flatten()`](#amaranth.lib.wiring.SignatureMembers.flatten) differ. This method yield several results for each
[`Member`](#amaranth.lib.wiring.Member) in the collection that has a dimension:

```pycon
>>> sig = wiring.Signature({
...     "items": In(1).array(2)
... })
>>> obj = sig.create()
>>> list(sig.flatten(obj))
[(('items', 0), In(1), (sig obj__items__0)),
 (('items', 1), In(1), (sig obj__items__1))]
```

The [`SignatureMembers.flatten()`](#amaranth.lib.wiring.SignatureMembers.flatten) method yields one result for such a member; see
the documentation for that method for an example.

* **Returns:**
  Tuples of [paths](#wiring-path), flow, and the corresponding member values. A path
  yielded by this method is a tuple of strings or integers where each item is an attribute
  name or index (correspondingly) using which the member value was retrieved.
* **Return type:**
  iterator of ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of [`str`](https://docs.python.org/3/library/stdtypes.html#str) or [`int`](https://docs.python.org/3/library/functions.html#int), [`Flow`](#amaranth.lib.wiring.Flow), [value-like](../guide.md#lang-valuelike))

#### is_compliant(obj, \*, reasons=None, path=('obj',))

Check whether an object matches the description in this signature.

This module places few restrictions on what an interface object may be; it does not
prescribe a specific base class or a specific way of constructing the object, only
the values that its attributes should have. This method ensures consistency between
the signature and the interface object, checking every aspect of the provided interface
object for compliance with the signature.

It verifies that:

* `obj` has a `signature` attribute whose value a [`Signature`](#amaranth.lib.wiring.Signature) instance
  such that `self == obj.signature`;
* for each member, `obj` has an attribute with the same name, whose value:
  * for members with [`dimensions`](#amaranth.lib.wiring.Member.dimensions) specified, contains a list or
    a tuple (or several levels of nested lists or tuples, for multiple dimensions)
    satisfying the requirements below;
  * for port members, is a [value-like](../guide.md#lang-valuelike) object casting to
    a `Signal` or a `Const` whose width and signedness is the same as that
    of the member, and (in case of a `Signal`) whose initial value is that of the
    member;
  * for signature members, matches the description in the signature as verified by
    [`Signature.is_compliant()`](#amaranth.lib.wiring.Signature.is_compliant).

If the verification fails, this method reports the reason(s) by filling the `reasons`
container. These reasons are intended to be human-readable: more than one reason may be
reported but only in cases where this is helpful (e.g. the same error message will not
repeat 10 times for each of the 10 ports in a list).

* **Parameters:**
  * **reasons** ([`list`](https://docs.python.org/3/library/stdtypes.html#list) or `None`) – If provided, a container that receives diagnostic messages.
  * **path** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) of [`str`](https://docs.python.org/3/library/stdtypes.html#str)) – The [path](#wiring-path) to `obj`. Could be set to improve diagnostic
    messages if `obj` is nested within another object, or for clarity.
* **Returns:**
  `True` if `obj` matches the description in this signature, `False`
  otherwise. If `False` and `reasons` was not `None`, it will contain
  a detailed explanation why.
* **Return type:**
  [`bool`](https://docs.python.org/3/library/functions.html#bool)

#### create(\*, path=None, src_loc_at=0)

Create an interface object from this signature.

The default [`Signature.create()`](#amaranth.lib.wiring.Signature.create) implementation consists of one line:

```default
def create(self, *, path=None, src_loc_at=0):
    return PureInterface(self, path=path, src_loc_at=1 + src_loc_at)
```

This implementation creates an interface object from this signature that serves purely
as a container for the attributes corresponding to the signature members, and implements
no behavior. Such an implementation is sufficient for signatures created ad-hoc using
the `Signature({ ... })` constructor as well as simple signature subclasses.

When defining a [`Signature`](#amaranth.lib.wiring.Signature) subclass that needs to customize the behavior of
the created interface objects, override this method with a similar implementation
that references the class of your custom interface object:

```python
class CustomSignature(wiring.Signature):
    def create(self, *, path=None, src_loc_at=0):
        return CustomInterface(self, path=path, src_loc_at=1 + src_loc_at)

class CustomInterface(wiring.PureInterface):
    @property
    def my_property(self):
        ...
```

The `path` and `src_loc_at` arguments are necessary to ensure the generated signals
have informative names and accurate source location information.

The custom [`create()`](#amaranth.lib.wiring.Signature.create) method may take positional or keyword arguments in addition to
the two listed above. Such arguments must have a default value, because
the [`SignatureMembers.create()`](#amaranth.lib.wiring.SignatureMembers.create) method will call the [`Signature.create()`](#amaranth.lib.wiring.Signature.create) member
without these additional arguments when this signature is a member of another signature.

#### annotations(obj, /)

Annotate an interface object.

Subclasses of [`Signature`](#amaranth.lib.wiring.Signature) may override this method to provide annotations for
a corresponding interface object. The default implementation provides none.

See [`amaranth.lib.meta`](meta.md#module-amaranth.lib.meta) for details.

* **Returns:**
  `tuple()`
* **Return type:**
  iterable of [`Annotation`](meta.md#amaranth.lib.meta.Annotation)

### *class* amaranth.lib.wiring.FlippedSignature(unflipped)

Description of an interface object, with the members’ directions flipped.

Although an instance of [`FlippedSignature`](#amaranth.lib.wiring.FlippedSignature) could be created directly, it will be usually
created by a call to [`Signature.flip()`](#amaranth.lib.wiring.Signature.flip).

This proxy is a wrapper around [`Signature`](#amaranth.lib.wiring.Signature) that contains the same description as
the inner mapping, but flips the members’ data flow when they are accessed. It is useful
because [`Signature`](#amaranth.lib.wiring.Signature) objects are mutable and may include custom behavior, and if one was
copied (rather than wrapped) by [`Signature.flip()`](#amaranth.lib.wiring.Signature.flip), the wrong object would be mutated, and
custom behavior would be unavailable.

For example:

```python
sig = wiring.Signature({"foo": Out(1)})

flipped_sig = sig.flip()
assert flipped_sig.members["foo"].flow == In

sig.attr = 1
assert flipped_sig.attr == 1
flipped_sig.attr += 1
assert sig.attr == flipped_sig.attr == 2
```

This class implements the same methods, with the same functionality (other than the flipping of
the members’ data flow), as the [`Signature`](#amaranth.lib.wiring.Signature) class; see the documentation for that class
for details.

It is not possible to inherit from [`FlippedSignature`](#amaranth.lib.wiring.FlippedSignature) and [`Signature.flip()`](#amaranth.lib.wiring.Signature.flip) must not
be overridden. If a [`Signature`](#amaranth.lib.wiring.Signature) subclass defines a method and this method is called on
a flipped instance of the subclass, it receives the flipped instance as its `self` argument.
To distinguish being called on the flipped instance from being called on the unflipped one, use
`isinstance(self, FlippedSignature)`:

```python
class SignatureKnowsWhenFlipped(wiring.Signature):
    @property
    def is_flipped(self):
        return isinstance(self, wiring.FlippedSignature)

sig = SignatureKnowsWhenFlipped({})
assert sig.is_flipped == False
assert sig.flip().is_flipped == True
```

#### flip()

Flips this signature back to the original one.

* **Returns:**
  `unflipped`
* **Return type:**
  [`Signature`](#amaranth.lib.wiring.Signature)

#### \_\_getattr_\_(name)

Retrieves attribute or method `name` of the unflipped signature.

Performs `getattr(unflipped, name)`, ensuring that, if `name` refers to a property
getter or a method, its `self` argument receives the *flipped* signature. A class
method’s `cls` argument receives the class of the *unflipped* signature, as usual.

#### \_\_setattr_\_(name, value)

Assigns attribute `name` of the unflipped signature to `value`.

Performs `setattr(unflipped, name, value)`, ensuring that, if `name` refers to
a property setter, its `self` argument receives the flipped signature.

#### \_\_delattr_\_(name)

Removes attribute `name` of the unflipped signature.

Performs `delattr(unflipped, name)`, ensuring that, if `name` refers to a property
deleter, its `self` argument receives the flipped signature.

### *class* amaranth.lib.wiring.SignatureMeta

Metaclass for [`Signature`](#amaranth.lib.wiring.Signature) that makes [`FlippedSignature`](#amaranth.lib.wiring.FlippedSignature) its
‘virtual subclass’.

The object returned by [`Signature.flip()`](#amaranth.lib.wiring.Signature.flip) is an instance of [`FlippedSignature`](#amaranth.lib.wiring.FlippedSignature).
It implements all of the methods [`Signature`](#amaranth.lib.wiring.Signature) has, and for subclasses of
[`Signature`](#amaranth.lib.wiring.Signature), it implements all of the methods defined on the subclass as well.
This makes it effectively a subtype of [`Signature`](#amaranth.lib.wiring.Signature) (or a derived class of it), but this
relationship is not captured by the Python type system: [`FlippedSignature`](#amaranth.lib.wiring.FlippedSignature) only has
[`object`](https://docs.python.org/3/library/functions.html#object) as its base class.

This metaclass extends [`issubclass()`](https://docs.python.org/3/library/functions.html#issubclass) and [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance) so that they take into
account the subtyping relationship between [`Signature`](#amaranth.lib.wiring.Signature) and [`FlippedSignature`](#amaranth.lib.wiring.FlippedSignature),
described below.

#### \_\_subclasscheck_\_(subclass)

Override of `issubclass(cls, Signature)`.

In addition to the standard behavior of [`issubclass()`](https://docs.python.org/3/library/functions.html#issubclass), this override makes
[`FlippedSignature`](#amaranth.lib.wiring.FlippedSignature) a subclass of [`Signature`](#amaranth.lib.wiring.Signature) or any of its subclasses.

#### \_\_instancecheck_\_(instance)

Override of `isinstance(obj, Signature)`.

In addition to the standard behavior of [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance), this override makes
`isinstance(obj, cls)` act as `isinstance(obj.flip(), cls)` where
`obj` is an instance of [`FlippedSignature`](#amaranth.lib.wiring.FlippedSignature).

## Interfaces

### *class* amaranth.lib.wiring.PureInterface(signature, \*, path=None, src_loc_at=0)

A helper for constructing ad-hoc interfaces.

The [`PureInterface`](#amaranth.lib.wiring.PureInterface) helper primarily exists to be used by the default implementation of
[`Signature.create()`](#amaranth.lib.wiring.Signature.create), but it can also be used in any other context where an interface
object needs to be created without the overhead of defining a class for it.

#### \_\_init_\_(signature, \*, path=None, src_loc_at=0)

Create attributes from a signature.

The sole method defined by this helper is its constructor, which only defines
the `self.signature` attribute as well as the attributes created from the signature
members:

```default
def __init__(self, signature, *, path):
    self.__dict__.update({
        "signature": signature,
        **signature.members.create(path=path)
    })
```

#### NOTE
This implementation can be copied and reused in interface objects that *do* include
custom behavior, if the signature serves as the source of truth for attributes
corresponding to its members. Although it is less repetitive, this approach can confuse
IDEs and type checkers.

### *class* amaranth.lib.wiring.FlippedInterface(unflipped)

An interface object, with its members’ directions flipped.

An instance of [`FlippedInterface`](#amaranth.lib.wiring.FlippedInterface) should only be created by calling [`flipped()`](#amaranth.lib.wiring.flipped),
which ensures that a `FlippedInterface(FlippedInterface(...))` object is never created.

This proxy wraps any interface object and forwards attribute and method access to the wrapped
interface object while flipping its signature and the values of any attributes corresponding to
interface members. It is useful because interface objects may be mutable or include custom
behavior, and explicitly keeping track of whether the interface object is flipped would be very
burdensome.

For example:

```python
intf = wiring.PureInterface(wiring.Signature({"foo": Out(1)}), path=())

flipped_intf = wiring.flipped(intf)
assert flipped_intf.signature.members["foo"].flow == In

intf.attr = 1
assert flipped_intf.attr == 1
flipped_intf.attr += 1
assert intf.attr == flipped_intf.attr == 2
```

It is not possible to inherit from [`FlippedInterface`](#amaranth.lib.wiring.FlippedInterface). If an interface object class
defines a method or a property and it is called on the flipped interface object, the method
receives the flipped interface object as its `self` argument. To distinguish being called
on the flipped interface object from being called on the unflipped one, use
`isinstance(self, FlippedInterface)`:

```python
class InterfaceKnowsWhenFlipped:
    signature = wiring.Signature({})

    @property
    def is_flipped(self):
        return isinstance(self, wiring.FlippedInterface)

intf = InterfaceKnowsWhenFlipped()
assert intf.is_flipped == False
assert wiring.flipped(intf).is_flipped == True
```

#### *property* signature

Signature of the flipped interface.

* **Returns:**
  `unflipped.signature.flip()`
* **Return type:**
  [`Signature`](#amaranth.lib.wiring.Signature)

#### \_\_eq_\_(other)

Compare this flipped interface with another.

* **Returns:**
  `True` if `other` is an instance `FlippedInterface(other_unflipped)` where
  `unflipped == other_unflipped`, `False` otherwise.
* **Return type:**
  [`bool`](https://docs.python.org/3/library/functions.html#bool)

#### \_\_getattr_\_(name)

Retrieves attribute or method `name` of the unflipped interface.

Performs `getattr(unflipped, name)`, with the following caveats:

1. If `name` refers to a signature member, the returned interface object is flipped.
2. If `name` refers to a property getter or a method, its `self` argument receives
   the *flipped* interface. A class method’s `cls` argument receives the class of
   the *unflipped* interface, as usual.

#### \_\_setattr_\_(name, value)

Assigns attribute `name` of the unflipped interface to `value`.

Performs `setattr(unflipped, name, value)`, with the following caveats:

1. If `name` refers to a signature member, the assigned interface object is flipped.
2. If `name` refers to a property setter, its `self` argument receives the flipped
   interface.

#### \_\_delattr_\_(name)

Removes attribute `name` of the unflipped interface.

Performs `delattr(unflipped, name)`, ensuring that, if `name` refers to a property
deleter, its `self` argument receives the flipped interface.

### amaranth.lib.wiring.flipped(interface)

Flip the data flow of the members of the interface object `interface`.

If an interface object is flipped twice, returns the original object:
`flipped(flipped(interface)) is interface`. Otherwise, wraps `interface` in
a [`FlippedInterface`](#amaranth.lib.wiring.FlippedInterface) proxy object that flips the directions of its members.

See the documentation for the [`FlippedInterface`](#amaranth.lib.wiring.FlippedInterface) class for a detailed discussion of how
this proxy object works.

## Making connections

### *exception* amaranth.lib.wiring.ConnectionError

Exception raised when the [`connect()`](#amaranth.lib.wiring.connect) function is requested to perform an impossible,
meaningless, or forbidden connection.

### amaranth.lib.wiring.connect(m, \*args, \*\*kwargs)

Connect interface objects to each other.

This function creates connections between ports of several interface objects. (Any number of
interface objects may be provided; in most cases it is two.)

The connections can be made only if all of the objects satisfy a number of requirements:

* Every interface object must have the same set of port members, and they must have the same
  [`dimensions`](#amaranth.lib.wiring.Member.dimensions).
* For each path, the port members of every interface object must have the same width and initial
  value (for port members corresponding to signals) or constant value (for port members
  corresponding to constants). Signedness may differ.
* For each path, at most one interface object must have the corresponding port member be
  an output.
* For a given path, if any of the interface objects has an input port member corresponding
  to a constant value, then the rest of the interface objects must have output port members
  corresponding to the same constant value.
* When connecting multiple interface objects, at least one connection must be made.

For example, if `obj1` is being connected to `obj2` and `obj3`, and `obj1.a.b`
is an output, then `obj2.a.b` and `obj2.a.b` must exist and be inputs. If `obj2.c`
is an input and its value is `Const(1)`, then `obj1.c` and `obj3.c` must be outputs
whose value is also `Const(1)`. If no ports besides `obj1.a.b` and `obj1.c` exist,
then no ports except for those two must exist on `obj2` and `obj3` either.

Once it is determined that the interface objects can be connected, this function performs
an equivalent of:

```default
m.d.comb += [
    in1.eq(out1),
    in2.eq(out1),
    ...
]
```

Where `out1` is an output and `in1`, `in2`, … are the inputs that have the same
path. (If no interface object has an output for a given path, **no connection at all** is made.)

The positions (within `args`) or names (within `kwargs`) of the arguments do not affect
the connections that are made. There is no difference in behavior between `connect(m, a, b)`
and `connect(m, b, a)` or `connect(m, arbiter=a, decoder=b)`. The names of the keyword
arguments serve only a documentation purpose: they clarify the diagnostic messages when
a connection cannot be made.

## Components

### *class* amaranth.lib.wiring.Component(\*args, src_loc_at=0, \*\*kwargs)

Base class for elaboratable interface objects.

A component is an `Elaboratable` whose interaction with other parts of the design is
defined by its signature. Most if not all elaboratables in idiomatic Amaranth code should be
components, as the signature clarifies the direction of data flow at their boundary. See
the [introduction to interfaces](#wiring-intro1) section for a practical guide to defining
and using components.

There are two ways to define a component. If all instances of a component have the same
signature, it can be defined using [variable annotations](https://docs.python.org/3/glossary.html#term-variable-annotation):

```python
class FixedComponent(wiring.Component):
    en: In(1)
    data: Out(8)
```

The variable annotations are collected by the constructor `Component.__init__()`. Only
public (not starting with `_`) annotations with [`In`](#amaranth.lib.wiring.Member) or [`Out`](#amaranth.lib.wiring.Member)
objects are considered; all other annotations are ignored under the assumption that they are
interpreted by some other tool.

It is possible to use inheritance to extend a component: the component’s signature is composed
from the variable annotations in the class that is being constructed as well as all of its
base classes. It is an error to have more than one variable annotation for the same attribute.

If different instances of a component may need to have different signatures, variable
annotations cannot be used. In this case, the constructor should be overridden, and
the computed signature members should be provided to the superclass constructor:

```python
class ParametricComponent(wiring.Component):
    def __init__(self, data_width):
        super().__init__({
            "en": In(1),
            "data": Out(data_width)
        })
```

It is also possible to pass a [`Signature`](#amaranth.lib.wiring.Signature) instance to the superclass constructor.

Aside from initializing the [`signature`](#amaranth.lib.wiring.Component.signature) attribute, the `Component.__init__()`
constructor creates attributes corresponding to all of the members defined in the signature.
If an attribute with the same name as that of a member already exists, an error is raied.

* **Raises:**
  * [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError) – If the `signature` object is neither a [`Signature`](#amaranth.lib.wiring.Signature) nor a [`dict`](https://docs.python.org/3/library/stdtypes.html#dict).
        If neither variable annotations nor the `signature` argument are present, or if
        both are present.
  * [**NameError**](https://docs.python.org/3/library/exceptions.html#NameError) – If a name conflict is detected between two variable annotations, or between a member
        and an existing attribute.

#### *property* signature

Signature of the component.

#### WARNING
Do not override this property. Once a component is constructed, its [`signature`](#amaranth.lib.wiring.Component.signature)
property must always return the same [`Signature`](#amaranth.lib.wiring.Signature) instance. The constructor
can be used to customize a component’s signature.

#### *property* metadata

Metadata attached to the component.

* **Return type:**
  [`ComponentMetadata`](#amaranth.lib.wiring.ComponentMetadata)

## Component metadata

### *exception* amaranth.lib.wiring.InvalidMetadata

Exception raised by [`ComponentMetadata.validate()`](#amaranth.lib.wiring.ComponentMetadata.validate) when the JSON representation of
a component’s metadata does not conform to its schema.

### *class* amaranth.lib.wiring.ComponentMetadata(origin)

Component metadata.

Component [metadata](meta.md#meta) describes the interface of a [`Component`](#amaranth.lib.wiring.Component) and can be
exported to JSON for interoperability with non-Amaranth tooling.

* **Parameters:**
  **origin** ([`Component`](#amaranth.lib.wiring.Component)) – Component described by this metadata instance.

#### schema *= { "$id": "https://amaranth-lang.org/schema/amaranth/0.5/component.json", ... }*

Schema of component metadata, expressed in the [JSON Schema](https://json-schema.org) language.

A copy of this schema can be retrieved [from amaranth-lang.org](https://amaranth-lang.org/schema/amaranth/0.5/component.json).

* **Type:**
  [`dict`](https://docs.python.org/3/library/stdtypes.html#dict)

#### *property* origin

Component described by this metadata.

* **Return type:**
  [`Component`](#amaranth.lib.wiring.Component)

#### *classmethod* validate(instance)

Validate a JSON representation of component metadata against [`schema`](#amaranth.lib.wiring.ComponentMetadata.schema).

This method does not validate annotations of the interface members, and consequently does
not make network requests.

* **Parameters:**
  **instance** ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict)) – JSON representation to validate, either previously returned by [`as_json()`](#amaranth.lib.wiring.ComponentMetadata.as_json) or
  retrieved from an external source.
* **Raises:**
  [**InvalidMetadata**](#amaranth.lib.wiring.InvalidMetadata) – If `instance` doesn’t conform to [`schema`](#amaranth.lib.wiring.ComponentMetadata.schema).

#### as_json()

Translate to JSON.

* **Returns:**
  JSON representation of [`origin`](#amaranth.lib.wiring.ComponentMetadata.origin) that describes its interface members and includes
  their annotations.
* **Return type:**
  [`dict`](https://docs.python.org/3/library/stdtypes.html#dict)


# wishbone.html.md

# Wishbone

#### WARNING
This manual is a work in progress and is seriously incomplete!

<a id="module-amaranth_soc.wishbone"></a>

* [Wishbone bus](wishbone/bus.md)
  * [`CycleType`](wishbone/bus.md#amaranth_soc.wishbone.bus.CycleType)
  * [`BurstTypeExt`](wishbone/bus.md#amaranth_soc.wishbone.bus.BurstTypeExt)
  * [`Feature`](wishbone/bus.md#amaranth_soc.wishbone.bus.Feature)
  * [`Signature`](wishbone/bus.md#amaranth_soc.wishbone.bus.Signature)
  * [`Interface`](wishbone/bus.md#amaranth_soc.wishbone.bus.Interface)
  * [`Decoder`](wishbone/bus.md#amaranth_soc.wishbone.bus.Decoder)
  * [`Arbiter`](wishbone/bus.md#amaranth_soc.wishbone.bus.Arbiter)


# xilinx.html.md

# Xilinx

The [`XilinxPlatform`](#amaranth.vendor.XilinxPlatform) class provides a base platform to support Xilinx toolchains.

The ISE, Vivado, and Symbiflow toolchains are supported.

### *class* amaranth.vendor.XilinxPlatform(\*, toolchain=None)

### Vivado toolchain

Required tools:
: * `vivado`

The environment is populated by running the script specified in the environment variable
`AMARANTH_ENV_VIVADO`, if present.

Available overrides:
: * `script_after_read`: inserts commands after `read_xdc` in Tcl script.
  * `synth_design_opts`: sets options for `synth_design`.
  * `script_after_synth`: inserts commands after `synth_design` in Tcl script.
  * `script_after_place`: inserts commands after `place_design` in Tcl script.
  * `script_after_route`: inserts commands after `route_design` in Tcl script.
  * `script_before_bitstream`: inserts commands before `write_bitstream` in Tcl script.
  * `script_after_bitstream`: inserts commands after `write_bitstream` in Tcl script.
  * `add_constraints`: inserts commands in XDC file.
  * `vivado_opts`: adds extra options for `vivado`.

Build products:
: * `{{name}}.log`: Vivado log.
  * `{{name}}_timing_synth.rpt`: Vivado report.
  * `{{name}}_utilization_hierarchical_synth.rpt`: Vivado report.
  * `{{name}}_utilization_synth.rpt`: Vivado report.
  * `{{name}}_utilization_hierarchical_place.rpt`: Vivado report.
  * `{{name}}_utilization_place.rpt`: Vivado report.
  * `{{name}}_io.rpt`: Vivado report.
  * `{{name}}_control_sets.rpt`: Vivado report.
  * `{{name}}_clock_utilization.rpt`:  Vivado report.
  * `{{name}}_route_status.rpt`: Vivado report.
  * `{{name}}_drc.rpt`: Vivado report.
  * `{{name}}_methodology.rpt`: Vivado report.
  * `{{name}}_timing.rpt`: Vivado report.
  * `{{name}}_power.rpt`: Vivado report.
  * `{{name}}_route.dcp`: Vivado design checkpoint.
  * `{{name}}.bit`: binary bitstream with metadata.
  * `{{name}}.bin`: binary bitstream.

### ISE toolchain

Required tools:
: * `xst`
  * `ngdbuild`
  * `map`
  * `par`
  * `bitgen`

The environment is populated by running the script specified in the environment variable
`AMARANTH_ENV_ISE`, if present.

Available overrides:
: * `script_after_run`: inserts commands after `run` in XST script.
  * `add_constraints`: inserts commands in UCF file.
  * `xst_opts`: adds extra options for `xst`.
  * `ngdbuild_opts`: adds extra options for `ngdbuild`.
  * `map_opts`: adds extra options for `map`.
  * `par_opts`: adds extra options for `par`.
  * `bitgen_opts`: adds extra and overrides default options for `bitgen`;
    default options: `-g Compress`.

Build products:
: * `{{name}}.srp`: synthesis report.
  * `{{name}}.ngc`: synthesized RTL.
  * `{{name}}.bld`: NGDBuild log.
  * `{{name}}.ngd`: design database.
  * `{{name}}_map.map`: MAP log.
  * `{{name}}_map.mrp`: mapping report.
  * `{{name}}_map.ncd`: mapped netlist.
  * `{{name}}.pcf`: physical constraints.
  * `{{name}}_par.par`: PAR log.
  * `{{name}}_par_pad.txt`: I/O usage report.
  * `{{name}}_par.ncd`: place and routed netlist.
  * `{{name}}.drc`: DRC report.
  * `{{name}}.bgn`: BitGen log.
  * `{{name}}.bit`: binary bitstream with metadata.
  * `{{name}}.bin`: raw binary bitstream.

### Symbiflow toolchain

Required tools:
: * `symbiflow_synth`
  * `symbiflow_pack`
  * `symbiflow_place`
  * `symbiflow_route`
  * `symbiflow_write_fasm`
  * `symbiflow_write_bitstream`

The environment is populated by running the script specified in the environment variable
`AMARANTH_ENV_SYMBIFLOW`, if present.

Available overrides:
: * `add_constraints`: inserts commands in XDC file.

### Xray toolchain

Required tools:
: * `yosys`
  * `nextpnr-xilinx`
  * `fasm2frames`
  * `xc7frames2bit`

The environment is populated by running the script specified in the environment variable
`AMARANTH_ENV_XRAY`, if present.


